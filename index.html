<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>StudyStack Revise</title>
    <script src="./assets/js/pdf.min.js"></script>
    <script src="./assets/js/mammoth.browser.min.js"></script>
    <script src="./assets/js/chart.js"></script>
    <link href="./assets/css/style.css" rel="stylesheet">

    <link rel="icon" type="image/png" href="https://i.ibb.co/1fyDzymL/Study-Stack-Pro-Photoroom.png">
    <style>
        :root {
            --bg-color: #f7fafc; --text-color: #333; --header-bg: white; --card-bg: white; --border-color: #e2e8f0; --border-dashed: #e2e8f0; --primary-color: #667eea; --primary-hover: #5a67d8; --secondary-text: #718096; --shadow-color: rgba(0,0,0,0.05); --input-bg: #f7fafc; --input-focus-bg: white; --button-secondary-bg: #e2e8f0; --button-secondary-text: #4a5568; --button-secondary-hover: #cbd5e0; --success-color: #38a169; --danger-color: #e53e3e;
        }
        .dark-mode {
            --bg-color: #1a202c; --text-color: #e2e8f0; --header-bg: #2d3748; --card-bg: #2d3748; --border-color: #4a5568; --border-dashed: #4a5568; --primary-color: #7f9cf5; --primary-hover: #667eea; --secondary-text: #a0aec0; --shadow-color: rgba(0,0,0,0.2); --input-bg: #2d3748; --input-focus-bg: #4a5568; --button-secondary-bg: #4a5568; --button-secondary-text: #e2e8f0; --button-secondary-hover: #718096; --success-color: #68d391; --danger-color: #fc8181;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: var(--bg-color); min-height: 100vh; color: var(--text-color); transition: background-color 0.3s, color 0.3s; }
        .view-container { display: none; }
        .view-container.animating { animation-duration: 0.4s; animation-timing-function: ease-in-out; animation-fill-mode: forwards; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes fadeOut { from { opacity: 1; transform: translateY(0); } to { opacity: 0; transform: translateY(-10px); } }
        .fade-in { display: block !important; animation-name: fadeIn; }
        .fade-out { animation-name: fadeOut; }
        .sub-view.animating { animation-duration: 0.4s; animation-timing-function: ease-in-out; animation-fill-mode: forwards; }
        .sub-view-fade-in { display: flex !important; flex-direction: column; animation-name: fadeIn; }
        .sub-view-fade-out { animation-name: fadeOut; }
        @keyframes deckClick { 0% { transform: scale(1); } 50% { transform: scale(0.97); } 100% { transform: scale(1); } }
        .deck-clicked { animation: deckClick 0.3s ease-in-out; }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        .section-title { font-size: 1.4rem; font-weight: 600; color: var(--text-color); margin-bottom: 25px; }
        .hidden { display: none !important; }
        .app-header { background: var(--header-bg); padding: 15px 20px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; position: sticky; top: 0; z-index: 100; }
        .logo-section { display: flex; align-items: center; gap: 15px; }
        .header-btn { background: var(--button-secondary-bg); border: none; border-radius: 50%; width: 40px; height: 40px; cursor: pointer; display: flex; align-items: center; justify-content: center; color: var(--button-secondary-text); transition: all 0.2s; }
        .header-btn:hover { background: var(--button-secondary-hover); transform: scale(1.05); }
        .logo {width: 48px; height: 48px; border-radius: 10px; overflow: hidden; cursor: pointer; display: flex; align-items: center; justify-content: center; color: white;}
        .logo img {width: 100%; height: 100%; object-fit: contain}
        .welcome-text { display: flex; align-items: baseline; gap: 10px; }
        .welcome-text h1 { font-size: 1.8rem; font-weight: 700; color: var(--text-color); }
        .welcome-text p { color: var(--secondary-text); font-size: 1rem; }
        .header-actions { display: flex; align-items: center; gap: 15px; }
        .search-bar { position: relative; width: 350px; max-width: 100%; }
        .search-input { width: 100%; padding: 12px 20px 12px 45px; border: 2px solid var(--border-color); border-radius: 25px; font-size: 16px; background: var(--input-bg); color: var(--text-color); transition: all 0.3s; }
        .search-input:focus { outline: none; border-color: var(--primary-color); background: var(--input-focus-bg); box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1); }
        .search-icon { position: absolute; left: 15px; top: 50%; transform: translateY(-50%); color: var(--secondary-text); width: 20px; height: 20px; }
        .main-content { margin-bottom: 40px; padding-top: 30px; }
        .decks-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 25px; }
        .category-folder { margin-bottom: 40px; }
        .category-title { font-size: 1.5rem; font-weight: 600; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 2px solid var(--border-color); }
        .deck-card { background: var(--card-bg); border-radius: 20px; padding: 25px; box-shadow: 0 8px 25px var(--shadow-color); transition: all 0.3s; position: relative; overflow: hidden; display: flex; flex-direction: column; border-top: 6px solid; }
        .deck-card-main-clickable { cursor: pointer; flex-grow: 1; display: flex; flex-direction: column; }
        .deck-card:hover { transform: translateY(-5px); box-shadow: 0 12px 35px var(--shadow-color); }
        .deck-card[data-category="Science"] { border-color: #4ecdc4; } .deck-card[data-category="Math"] { border-color: #667eea; } .deck-card[data-category="Language"] { border-color: #fab1a0; } .deck-card[data-category="History"] { border-color: #fd79a8; } .deck-card[data-category="Other"] { border-color: #a29bfe; }
        .deck-category { font-size: 0.8rem; font-weight: 600; padding: 4px 10px; border-radius: 20px; display: inline-block; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 0.5px; }
        .deck-card[data-category="Science"] .deck-category, .deck-detail-category.Science { color: #317b75; background-color: #e6fffa; } .deck-card[data-category="Math"] .deck-category, .deck-detail-category.Math { color: #5a67d8; background-color: #ebf4ff; } .deck-card[data-category="Language"] .deck-category, .deck-detail-category.Language { color: #c53030; background-color: #fff5f5; } .deck-card[data-category="History"] .deck-category, .deck-detail-category.History { color: #b83280; background-color: #fff5f7; } .deck-card[data-category="Other"] .deck-category, .deck-detail-category.Other { color: #6c5ce7; background-color: #f3f2ff; }
        .dark-mode .deck-card[data-category="Science"] .deck-category, .dark-mode .deck-detail-category.Science { color: #81e6d9; background-color: #2c7a7b; } .dark-mode .deck-card[data-category="Math"] .deck-category, .dark-mode .deck-detail-category.Math { color: #9f7aea; background-color: #5a67d830; } .dark-mode .deck-card[data-category="Language"] .deck-category, .dark-mode .deck-detail-category.Language { color: #f6ad55; background-color: #c5303030; } .dark-mode .deck-card[data-category="History"] .deck-category, .dark-mode .deck-detail-category.History { color: #f687b3; background-color: #b8328030; } .dark-mode .deck-card[data-category="Other"] .deck-category, .dark-mode .deck-detail-category.Other { color: #a3bffa; background-color: #6c5ce730; }
        .deck-header { margin-bottom: 15px; flex-grow: 1; }
        .deck-name { font-size: 1.4rem; font-weight: 700; color: var(--text-color); margin-bottom: 5px; line-height: 1.3; }
        .deck-info { display: flex; align-items: center; gap: 15px; color: var(--secondary-text); font-size: 0.9rem; font-weight: 500; }
        .deck-date { font-size: 0.8rem; color: var(--secondary-text); margin-top: auto; padding-bottom: 15px; } 
        .deck-progress-container { margin-top: 10px; }
        .deck-progress-label { font-size: 0.8rem; color: var(--secondary-text); margin-bottom: 5px; display: flex; justify-content: space-between; }
        .deck-progress-bar-outer { width: 100%; height: 8px; background: var(--border-color); border-radius: 4px; overflow: hidden; }
        .deck-progress-bar-inner { height: 100%; border-radius: 4px; transition: width 0.5s ease-in-out; }
        .deck-card[data-category="Science"] .deck-progress-bar-inner { background-color: #4ecdc4; } .deck-card[data-category="Math"] .deck-progress-bar-inner { background-color: #667eea; } .deck-card[data-category="Language"] .deck-progress-bar-inner { background-color: #fab1a0; } .deck-card[data-category="History"] .deck-progress-bar-inner { background-color: #fd79a8; } .deck-card[data-category="Other"] .deck-progress-bar-inner { background-color: #a29bfe; }
        .deck-actions { display: grid; grid-template-columns: 1fr 1fr auto; gap: 12px; margin-top: 15px; }
        .action-btn { flex: 1; padding: 12px 10px; border: none; border-radius: 12px; font-weight: 600; font-size: 14px; cursor: pointer; transition: all 0.3s; font-family: 'Inter', sans-serif; display: inline-flex; align-items: center; justify-content: center; gap: 6px; }
        .export-btn { background: var(--button-secondary-bg); color: var(--button-secondary-text); border: 2px solid var(--border-color); padding: 10px; flex: 0 0 auto; width: 44px; grid-column: 3 / 4; grid-row: 1 / 3;}
        .export-btn:hover { background: var(--button-secondary-hover); border-color: #cbd5e0; }
        .learn-btn { background: var(--primary-color); color: white; }
        .learn-btn:hover { background: var(--primary-hover); transform: translateY(-1px); }
        .review-btn { background: var(--button-secondary-bg); color: var(--button-secondary-text); border: 2px solid var(--border-color); }
        .review-btn:hover { background: var(--button-secondary-hover); border-color: #cbd5e0; }
        .spaced-btn { background: #38b2ac; color: white; grid-column: 1 / 3; }
        .spaced-btn:hover { background: #319795; transform: translateY(-1px); }
        .deck-detail-view { background: var(--card-bg); border-radius: 20px; padding: 30px; box-shadow: 0 8px 25px var(--shadow-color); margin-bottom: 30px; }
        .deck-detail-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 25px; }
        .deck-detail-title { font-size: 1.8rem; font-weight: 700; color: var(--text-color); margin-bottom: 5px; }
        .deck-detail-category { display: inline-block; padding: 5px 12px; border-radius: 20px; font-size: 0.9rem; font-weight: 500; }
        .deck-detail-actions { display: flex; flex-wrap: wrap; gap: 10px; }
        .deck-cards-list { max-height: 400px; overflow-y: auto; border: 2px solid var(--border-color); border-radius: 15px; padding: 20px; }
        .deck-card-item { padding: 15px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: flex-start; gap: 15px; }
        .deck-card-item:last-child { border-bottom: none; }
        .deck-card-content { flex: 1; }
        .deck-card-question { font-weight: 500; color: var(--text-color); margin-bottom: 5px; }
        .deck-card-answer { color: var(--secondary-text); font-size: 0.95rem; }
        .card-image { max-width: 200px; max-height: 150px; border-radius: 8px; margin-top: 8px; }
        .deck-card-meta { display: flex; align-items: center; gap: 10px; }
        .new-badge { font-size: 0.75rem; font-weight: 600; color: var(--primary-color); background-color: #ebf4ff; padding: 2px 8px; border-radius: 10px; margin-left: 8px; }
        .dark-mode .new-badge { color: #9f7aea; background-color: #5a67d830; }
        .deck-card-actions { display: flex; gap: 10px; }
        .deck-card-action-btn { background: none; border: none; cursor: pointer; padding: 5px; border-radius: 6px; color: var(--secondary-text); transition: all 0.3s; }
        .deck-card-action-btn:hover { background: var(--input-bg); color: var(--text-color); }
        .deck-card-action-btn.edit:hover { color: var(--primary-color); }
        .deck-card-action-btn.delete:hover { color: var(--danger-color); }
        .create-options { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; }
        .create-card { background: var(--card-bg); border: 3px dashed var(--border-dashed); border-radius: 20px; padding: 40px 30px; text-align: center; cursor: pointer; transition: all 0.3s; position: relative; overflow: hidden; }
        .create-card:hover { border-color: var(--primary-color); background: var(--input-focus-bg); }
        .create-icon { font-size: 2.5rem; margin: 0 auto 15px auto; display: block; width: 40px; height: 40px; color: var(--primary-color); }
        .create-title { font-size: 1.2rem; font-weight: 600; color: var(--text-color); margin-bottom: 8px; }
        .create-desc { color: var(--secondary-text); font-size: 0.95rem; line-height: 1.4; }
        .no-decks { text-align: center; color: var(--secondary-text); font-size: 1.1rem; padding: 60px 20px; background: var(--card-bg); border-radius: 20px; border: 2px dashed var(--border-dashed); }
        .no-decks-icon { font-size: 4rem; margin: 0 auto 20px auto; display: block; width: 64px; height: 64px; opacity: 0.5; color: var(--secondary-text); }
        .btn { background: var(--primary-color); color: white; border: none; padding: 12px 24px; border-radius: 10px; font-size: 16px; font-weight: 500; cursor: pointer; transition: all 0.3s; font-family: 'Inter', sans-serif; display: inline-flex; align-items: center; justify-content: center; gap: 8px; }
        .btn svg { width: 20px; height: 20px; }
        .btn:hover { background: var(--primary-hover); transform: translateY(-1px); }
        .btn:disabled { background: #cbd5e0; cursor: not-allowed; transform: none; }
        .btn-secondary { background: var(--button-secondary-bg); color: var(--button-secondary-text); }
        .btn-secondary:hover { background: var(--button-secondary-hover); }
        .btn-danger { background: var(--danger-color); }
        .btn-danger:hover { background: #c53030; }
        .btn-success { background: var(--success-color); }
        .btn-success:hover { background: #2f855a; }
        .btn-prominent { padding: 16px 32px; font-size: 18px; font-weight: 600; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3); }
        .form-group { margin-bottom: 25px; }
        .form-group label { display: block; margin-bottom: 8px; color: var(--secondary-text); font-weight: 500; }
        .form-group input, .form-group textarea, .form-group select { width: 100%; padding: 12px 15px; border: 2px solid var(--border-color); background-color: var(--input-bg); color: var(--text-color); border-radius: 10px; font-size: 16px; font-family: 'Inter', sans-serif; transition: border-color 0.3s, background-color 0.3s; }
        .form-group input:focus, .form-group textarea:focus, .form-group select:focus { outline: none; border-color: var(--primary-color); background-color: var(--input-focus-bg); }
        .form-group textarea { min-height: 120px; resize: vertical; }
        .back-btn { background: none; border: none; color: var(--primary-color); font-size: 16px; cursor: pointer; margin-bottom: 20px; display: flex; align-items: center; gap: 8px; font-weight: 500; }
        .back-btn:hover { color: var(--primary-hover); }
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); backdrop-filter: blur(5px); align-items: center; justify-content: center; }
        .modal.show { display: flex; }
        .modal-content { background-color: var(--card-bg); padding: 40px; border-radius: 20px; width: 90%; max-width: 500px; max-height: 90vh; overflow-y: auto; position: relative; animation: modalSlideIn 0.3s ease-out; text-align: left; }
        .modal-content.text-center { text-align: center; }
        @keyframes modalSlideIn { from { opacity: 0; transform: translateY(-30px) scale(0.95); } to { opacity: 1; transform: translateY(0) scale(1); } }
        .close { position: absolute; right: 20px; top: 20px; font-size: 24px; font-weight: bold; cursor: pointer; color: var(--secondary-text); transition: color 0.3s; }
        .close:hover { color: var(--text-color); }
        .modal h2 { color: var(--text-color); margin-bottom: 15px; font-size: 1.8rem; font-weight: 700; text-align: center; }
        .modal p { color: var(--secondary-text); margin-bottom: 30px; line-height: 1.5; text-align: center; }
        .modal-actions { display: flex; gap: 15px; justify-content: center; }
        .settings-container { background: var(--card-bg); border-radius: 20px; padding: 40px; box-shadow: 0 8px 25px var(--shadow-color); }
        .settings-section { padding-bottom: 20px; margin-bottom: 20px; border-bottom: 2px solid var(--border-color); }
        .settings-section:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
        .settings-section h2, .settings-section h4 { font-size: 1.3rem; font-weight: 600; color: var(--text-color); margin-bottom: 20px; }
        .dark-mode-toggle { display: flex; align-items: center; justify-content: space-between; }
        .switch { position: relative; display: inline-block; width: 50px; height: 28px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--primary-color); }
        input:checked + .slider:before { transform: translateX(22px); }
        .study-container { max-width: 800px; margin: 0 auto; padding: 20px; position: relative; display: flex; flex-direction: column; min-height: calc(100vh - 100px); background-color: var(--bg-color);}
        .study-header { text-align: center; margin-bottom: 30px; display: flex; justify-content: center; align-items: center; position: relative; }
        .study-header-content { flex-grow: 1; }
        .study-header-actions { position: absolute; right: 0; top: 50%; transform: translateY(-50%); display: flex; gap: 10px; }
        .study-title { font-size: 2rem; font-weight: 700; color: var(--text-color); margin-bottom: 10px; }
        .study-subtitle { color: var(--secondary-text); font-size: 1.1rem; }
        .flashcard-inner {
            display: grid;
            width: 100%;
            height: 100%;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        } 
       .flashcard.is-flipped .flashcard-inner { transform: rotateY(180deg); }
        .flashcard { width: 100%; max-width: 1500px; background: transparent; perspective: 1000px; margin-bottom: 0px; flex-grow: 0; display: flex; flex-direction: column; }
        .flashcard-front, .flashcard-back {
            grid-area: 1 / 1 / 1 / 1;
            padding: 40px;
            min-height: 250px;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            background: var(--card-bg);
            border-radius: 20px;
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-shadow: 0 10px 30px var(--shadow-color);
            overflow-y: auto;
        }
        .flashcard-back { transform: rotateY(180deg); }
        #cardBucketInfo { position: absolute; top: 15px; left: 20px; font-size: 0.9rem; font-weight: 500; color: var(--secondary-text); background-color: var(--input-bg); padding: 4px 10px; border-radius: 12px; z-index: 5; }
        .question { font-size: 1.5rem; font-weight: 600; color: var(--text-color); margin-bottom: 25px; line-height: 1.4; }
        .answer { font-size: 1.2rem; color: var(--text-color); background: var(--input-bg); padding: 20px; border-radius: 12px; margin-top: 20px; line-height: 1.5; }
        #writeAnswerInput { width: 100%; min-height: 100px; margin-top: 20px; font-family: 'Inter', sans-serif; font-size: 1.1rem; padding: 20px; border-radius: 12px; transition: all 0.3s; }
        #writeAnswerInput:focus { border-color: var(--primary-color); box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1); }
        #writeAnswerInput.correct { border-color: var(--success-color); background-color: #f0fff4; }
        .dark-mode #writeAnswerInput.correct { background-color: #2c7a7b; }
        #writeAnswerInput.incorrect { border-color: var(--danger-color); background-color: #fff5f5; }
        .dark-mode #writeAnswerInput.incorrect { background-color: #c5303030; }
        .accent-buttons { margin-top: 15px; display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; }
        .accent-buttons button { background: var(--button-secondary-bg); border: 1px solid var(--border-color); color: var(--button-secondary-text); padding: 5px 12px; border-radius: 8px; cursor: pointer; font-size: 1rem; }
        .accent-buttons button:hover { background: var(--button-secondary-hover); }
        .answer-buttons { display: flex; justify-content: center; gap: 10px; margin-top: 20px; flex-wrap: wrap; }
        .btn-show { background: #38b2ac; padding: 15px 30px; font-size: 16px; }
        .btn-show:hover { background: #319795; }
        .btn-correct { background: var(--success-color); order: 2; }
        .btn-incorrect { background: var(--danger-color); order: 1; }
        .btn-correct:hover { background: #2f855a; }
        .btn-incorrect:hover { background: #c53030; }
        .advanced-answer-btn { flex: 1; min-width: 100px; padding: 12px 15px; font-size: 14px; }
        .btn-again { background: #e53e3e; } .btn-again:hover { background: #c53030; }
        .btn-hard { background: #dd6b20; } .btn-hard:hover { background: #c05621; }
        .btn-good { background: #3182ce; } .btn-good:hover { background: #2b6cb0; }
        .btn-easy { background: #38a169; } .btn-easy:hover { background: #2f855a; }
        .progress-dashboard { background: var(--card-bg); border-radius: 20px; padding: 30px; margin-bottom: 30px; box-shadow: 0 8px 25px var(--shadow-color); position: relative; }
        #deckNotesDisplay { background: var(--input-bg); border: 2px solid var(--border-color); padding: 20px; border-radius: 15px; margin-bottom: 25px; }
        #deckNotesDisplay h3 { margin-bottom: 10px; }
        #deckNotesDisplay img { max-width: 100%; height: auto; border-radius: 8px; margin-top: 10px; }
        .progress-title { font-size: 1.8rem; font-weight: 700; text-align: center; margin-bottom: 25px; color: var(--text-color); }
        .round-info { text-align: center; margin-bottom: 25px; padding: 15px; background: var(--input-bg); border-radius: 12px; color: var(--primary-color); font-weight: 500; }
        .buckets-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 15px; margin-bottom: 25px; }
        .bucket { background: var(--input-bg); border-radius: 12px; padding: 20px; text-align: center; border: 2px solid var(--border-color); }
        .bucket-number { font-size: 1rem; font-weight: 600; color: var(--primary-color); margin-bottom: 5px; }
        .bucket-count { font-size: 1.8rem; font-weight: 700; color: var(--text-color); }
        .progress-bar-container { width: 100%; height: 10px; background: var(--border-color); border-radius: 5px; overflow: hidden; margin: 20px 0; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #38a169, #48bb78); transition: width 0.5s ease; }
        .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 20px; margin: 25px 0; }
        .stat { text-align: center; padding: 15px; background: var(--input-bg); border-radius: 12px; border: 2px solid var(--border-color); }
        .stat-value { font-size: 1.5rem; font-weight: 700; color: var(--primary-color); }
        .stat-label { font-size: 0.9rem; color: var(--secondary-text); margin-top: 5px; }
        #cardView { display: flex; flex-direction: column; flex-grow: 1; }
        .ai-generator-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 25px; }
        .ai-panel { background: var(--card-bg); border-radius: 20px; padding: 30px; box-shadow: 0 8px 25px var(--shadow-color); display: flex; flex-direction: column; }
        .ai-panel h2 { font-size: 1.3rem; font-weight: 600; color: var(--text-color); margin-bottom: 20px; }
        .ai-tabs, .import-tabs { display: flex; border-bottom: 2px solid var(--border-color); margin-bottom: 20px; }
        .ai-tab, .import-tab { padding: 10px 15px; cursor: pointer; font-weight: 500; color: var(--secondary-text); border-bottom: 3px solid transparent; margin-bottom: -2px; transition: all 0.3s; }
        .ai-tab.active, .import-tab.active { color: var(--primary-color); border-bottom-color: var(--primary-color); }
        .file-drop-zone { border: 3px dashed var(--border-dashed); border-radius: 15px; padding: 25px; text-align: center; cursor: pointer; transition: all 0.3s; }
        .file-drop-zone:hover, .file-drop-zone.dragover { border-color: var(--primary-color); background: var(--input-focus-bg); }
        .file-drop-zone p { color: var(--secondary-text); margin-bottom: 10px; }
        .processing-controls { margin-top: auto; background: var(--input-bg); border-radius: 15px; padding: 25px; border: 2px solid var(--border-color); }
        .processing-controls h3 { font-size: 1.2rem; font-weight: 600; color: var(--text-color); margin-bottom: 15px; }
        .document-list, .flashcard-list { flex-grow: 1; overflow-y: auto; max-height: 500px; padding-right: 10px; }
        .document-item { background: var(--input-bg); border: 2px solid var(--border-color); border-radius: 12px; padding: 15px; margin-bottom: 10px; display: flex; flex-direction: column; }
        .document-item-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        .document-name { font-weight: 500; color: var(--text-color); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; padding-right: 10px; display: flex; align-items: center; }
        .document-status-icon { width: 20px; height: 20px; margin-right: 8px; flex-shrink: 0; }
        .remove-doc-btn { background: none; border: none; cursor: pointer; color: var(--secondary-text); padding: 0; width: 20px; height: 20px; }
        .remove-doc-btn:hover { color: #e53e3e; }
        .document-info { font-size: 0.9rem; color: var(--secondary-text); }
        .generated-card { background: var(--input-bg); border: 2px solid var(--border-color); border-radius: 12px; padding: 15px; margin-bottom: 10px; position: relative; }
        .generated-card .question { font-size: 1rem; margin-bottom: 8px; font-weight: 500; padding-right: 60px; }
        .generated-card .answer { font-size: 0.95rem; background: none; padding: 0; margin: 0; padding-right: 60px; }
        .generated-card-actions { position: absolute; top: 15px; right: 15px; display: flex; gap: 8px; }
        .generated-card-action-btn { background: none; border: none; cursor: pointer; padding: 5px; border-radius: 6px; color: var(--secondary-text); transition: all 0.3s; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; }
        .generated-card-action-btn:hover { background: var(--border-color); }
        .generated-card-action-btn.edit:hover { color: var(--primary-color); }
        .generated-card-action-btn.delete:hover { color: #e53e3e; }
        .list-empty-state { display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100%; text-align: center; color: var(--secondary-text); }
        .list-empty-state-icon { width: 48px; height: 48px; margin-bottom: 10px; opacity: 0.6; }
        .spinner { width: 20px; height: 20px; border: 3px solid var(--primary-color); border-bottom-color: transparent; border-radius: 50%; animation: spin 1s ease-in-out infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .editor-container { background: var(--card-bg); border-radius: 20px; padding: 40px; box-shadow: 0 8px 25px var(--shadow-color); }
        .editor-container .question-input,
        .editor-container .solution-input {
            font-family: 'Inter', sans-serif;
            border: 2px solid var(--border-color);
            border-radius: 12px;
            padding: 15px;
            font-size: 1rem;
            transition: all 0.3s ease;
            background-color: var(--input-bg);
            color: var(--text-color);
            width: 100%;
        }
        #testAnswerInput {
            width: 100%;
            min-height: 120px;
            margin-top: 20px;
            font-family: 'Inter', sans-serif;
            font-size: 1.1rem;
            padding: 20px;
            border-radius: 12px;
            border: 2px solid var(--border-color);
            background-color: var(--input-bg);
            color: var(--text-color);
            transition: all 0.3s ease;
        }
        #testAnswerInput:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
        }
        #testAnswerInput.correct {
            border-color: var(--success-color);
            background-color: #f0fff4; 
        }
        .dark-mode #testAnswerInput.correct {
            background-color: #2c7a7b;
        }
        #testAnswerInput.incorrect {
            border-color: var(--danger-color);
            background-color: #fff5f5; 
        }
        .dark-mode #testAnswerInput.incorrect {
            background-color: #c5303030;
        }
        .editor-container .question-input:focus,
        .editor-container .solution-input:focus {
            outline: none;
            border-color: var(--primary-color);
            background-color: var(--input-focus-bg);
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
        }
        .form-section { margin-bottom: 40px; }
        .form-row { display: flex; gap: 20px; margin-bottom: 25px; }
        .form-group { flex: 1; }
        .form-group.full-width { flex: 1 1 100%; }
        .form-group label { font-size: 16px; }
        .form-group input, .form-group textarea { padding: 15px 20px !important; border-radius: 10px !important; font-size: 16px !important; margin-bottom: 10px; min-height: 80px; resize: vertical; font-family: 'Inter', sans-serif; }
        .flashcard-editor-row {
            display: flex;
            align-items: center; 
            gap: 15px; 
            margin-bottom: 25px; 
        }
        .flashcard-item {
            flex-grow: 1; 
            padding: 25px;
            border: 2px solid var(--border-color);
            border-radius: 15px;
            background-color: var(--input-bg);
            position: relative; 
        }
        .image-preview { min-height: 20px; margin-bottom: 10px; }
        .image-preview img { max-width: 150px; max-height: 150px; border-radius: 8px; margin-top: 10px; display: block; }
        .image-controls { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; }
        .image-controls span { font-size: 0.9rem; color: var(--secondary-text); }
        .question-input { border-color: var(--border-color) !important; }
        .solution-input { border-color: var(--border-color) !important; margin-bottom: 0; }
        .remove-card-btn {
            position: static; 
            background: #fee2e2;
            border: 2px solid #fca5a5;
            color: #dc2626;
            cursor: pointer;
            padding: 8px;
            border-radius: 10px;
            transition: all 0.3s;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        .remove-card-btn:hover { background: #fecaca; border-color: #f87171; color: #b91c1c; transform: scale(1.05); }
        .add-question-btn { width: 100%; padding: 20px; border: 3px dashed var(--border-dashed); border-radius: 15px; background: var(--card-bg); color: var(--secondary-text); font-size: 16px; font-weight: 500; cursor: pointer; transition: all 0.3s; margin-bottom: 30px; }
        .add-question-btn:hover { border-color: var(--primary-color); background: var(--input-focus-bg); color: var(--primary-color); }
        .actions-section { display: flex; justify-content: flex-end; padding-top: 20px; border-top: 2px solid var(--border-color); }
        .checkbox-group { display: flex; align-items: center; gap: 10px; margin-bottom: 15px; }
        .checkbox-group input[type="radio"], .checkbox-group input[type="checkbox"] { width: 18px; height: 18px; accent-color: var(--primary-color); }
        .checkbox-group label { margin: 0; font-weight: 500; color: var(--text-color); }
        .form-group-inline { display: flex; align-items: center; gap: 10px; }
        #toast-container { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 2000; display: flex; flex-direction: column; align-items: center; gap: 10px; }
        .toast { background-color: var(--header-bg); color: var(--text-color); padding: 12px 20px; border-radius: 25px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); font-size: 15px; font-weight: 500; display: flex; align-items: center; gap: 10px; transition: all 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55); opacity: 0; transform: translateY(20px) scale(0.9); }
        .toast.show { opacity: 1; transform: translateY(0) scale(1); }
        .toast.success { background-color: var(--success-color); color: white; }
        .toast.error { background-color: var(--danger-color); color: white; }
        @keyframes button-feedback-correct { 0% { background-color: var(--success-color); } 50% { background-color: #2f855a; transform: scale(1.05); } 100% { background-color: var(--success-color); } }
        @keyframes button-feedback-incorrect { 0% { background-color: var(--danger-color); } 50% { background-color: #c53030; transform: scale(1.05); } 100% { background-color: var(--danger-color); } }
        .feedback-correct { animation: button-feedback-correct 0.4s ease-in-out; }
        .feedback-incorrect { animation: button-feedback-incorrect 0.4s ease-in-out; }
        .custom-file-upload { border: 2px solid var(--border-color); border-radius: 10px; display: inline-block; padding: 12px 20px; cursor: pointer; background-color: var(--button-secondary-bg); color: var(--button-secondary-text); font-weight: 500; transition: all 0.3s; }
        .custom-file-upload:hover { background-color: var(--button-secondary-hover); }
        #importFileInput { display: none; }
        #fileNameDisplay { margin-top: 10px; color: var(--secondary-text); font-style: italic; }
        #testCardView { display: flex; flex-direction: column; flex-grow: 1; }
        #testOptions { width: 100%; margin-top: 20px; display: flex; flex-direction: column; gap: 10px; }
        #testOptions .btn { width: 100%; margin: 0; padding: 15px; font-size: 1rem; }
        .dashboard-footer { text-align: center; margin-top: 40px; }
        @media (max-width: 1024px) { .ai-generator-grid { grid-template-columns: 1fr; } }
        @media (max-width: 768px) {
            .app-header { flex-direction: column; gap: 15px; padding: 15px; }
            .header-actions { width: 100%; justify-content: space-between; }
            .search-bar { order: 2; width: 100%; }
            .header-settings-btn { order: 3;}
            .welcome-text h1 { font-size: 1.5rem; text-align: center;}
            .welcome-text p { display: none; }
            .decks-grid { grid-template-columns: 1fr; }
            .create-options { grid-template-columns: 1fr; }
            .answer-buttons { flex-direction: column; align-items: center; }
            .action-btn { padding: 10px 16px; font-size: 13px; }
            .form-row { flex-direction: column; gap: 15px; }
            .editor-container, .settings-container { padding: 25px; }
            .deck-detail-header { flex-direction: column; gap: 15px; }
            .deck-detail-actions { width: 100%; justify-content: center; }
            .generated-card .question, .generated-card .answer { padding-right: 0; }
            .generated-card-actions { position: static; margin-top: 10px; justify-content: flex-end; }
            .flashcard-front, .flashcard-back { padding: 20px; }
        }
        .settings-option-group {
            border: 2px solid var(--border-color);
            border-radius: 12px;
            padding: 10px 15px 15px 15px; 
            margin-top: 10px;
        }
        .settings-option-group legend {
            font-weight: 600;
            color: var(--text-color);
            padding: 0 8px; 
            margin-left: 10px;
            font-size: 0.95rem;
        }
        .radio-option-row {
            display: flex;
            align-items: center;
            padding: 5px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            margin-top: 5px;
        }
        .radio-option-row:hover {
            background-color: var(--input-bg);
        }
        .radio-option-row input[type="radio"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary-color);
            cursor: pointer;
        }
        .radio-option-row label {
            margin: 0 0 0 12px; 
            font-weight: 500;
            color: var(--text-color);
            cursor: pointer;
        }
    </style>
</head>
<body>
    <div id="toast-container"></div>

    <header class="app-header">
         <div class="logo-section">
            <button id="headerBackBtn" class="header-btn hidden" title="Go Back">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" width="20" height="20"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5 8.25 12l7.5-7.5" /></svg>
            </button>
            <div class="logo" onclick="backToDashboard(true)">
                <img src='https://i.ibb.co/1fyDzymL/Study-Stack-Pro-Photoroom.png'>
            </div>
            <div class="welcome-text">
                <h1 id="welcomeMessage">StudyStack Revise</h1>
                <span style="font-size: 0.8rem; color: var(--secondary-text); align-self: flex-end; padding-bottom: 5px;">v1.01</span>
            </div>
        </div>
        <div class="header-actions">
            <div class="search-bar">
                <span class="search-icon"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607Z" /></svg></span>
                <input type="text" class="search-input" placeholder="Search decks..." id="searchInput">
            </div>
            <button id="headerSettingsBtn" class="header-btn header-settings-btn" title="Settings" onclick="showSettings()">
                 <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" width="20" height="20"><path stroke-linecap="round" stroke-linejoin="round" d="M10.343 3.94c.09-.542.56-.94 1.11-.94h1.093c.55 0 1.02.398 1.11.94l.149.894c.07.424.384.764.78.93.398.164.855.142 1.205-.108l.737-.527a1.125 1.125 0 0 1 1.45.12l.773.774c.39.39.44 1.02.12 1.45l-.527.737c-.25.35-.272.806-.108 1.204.165.397.505.71.93.78l.893.15c.543.09.94.56.94 1.11v1.093c0 .55-.397 1.02-.94 1.11l-.893.149c-.425.07-.765.383-.93.78-.165.398-.143.854.108 1.204l.527.738c.32.43.27.96-.12 1.45l-.773.773a1.125 1.125 0 0 1-1.45.12l-.737-.527c-.35-.25-.806-.272-1.204-.108-.397.165-.71.505-.78.93l-.15.893c-.09.543-.56.94-1.11.94h-1.093c-.55 0-1.02-.398-1.11-.94l-.149-.894c-.07-.424-.384-.764-.78-.93-.398-.164-.855-.142-1.205.108l-.737.527a1.125 1.125 0 0 1-1.45-.12l-.773-.774a1.125 1.125 0 0 1-.12-1.45l.527-.737c.25-.35.272-.806.108-1.204-.165-.397-.505-.71-.93-.78l-.894-.15c-.542-.09-.94-.56-.94-1.11v-1.093c0-.55.398-1.02.94-1.11l.894-.149c.424-.07.765-.383.93-.78.165-.398.143-.854-.108-1.204l-.527-.738a1.125 1.125 0 0 1 .12-1.45l.773-.773a1.125 1.125 0 0 1 1.45-.12l.737.527c.35.25.806.272 1.204.108.397-.165.71.505.78-.93l.15-.893Z" /><path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z" /></svg>
            </button>
        </div>
    </header>

    <div id="dashboard" class="container view-container">
        <div class="main-content">
            <div id="decksSection">
                <p id="subtitle" style="color: var(--secondary-text); font-size: 1.1rem; margin-bottom: 25px;"></p>
                <div id="decksContainer"></div><br><br>
            </div>
            <div id="deckDetailView" class="deck-detail-view hidden">
                <div class="deck-detail-header">
                    <div>
                        <span class="deck-detail-category" id="deckDetailCategory"></span>
                        <h2 class="deck-detail-title" id="deckDetailTitle"></h2>
                    </div>
                    <div class="deck-detail-actions">
                        <button class="btn learn-btn" onclick="configureStudy('learn')">Learn</button>
                        <button class="btn review-btn" onclick="configureStudy('review')">Review</button>
                        <button class="btn review-btn" id="deckDetailTestBtn">Practice Test</button>
                        <button class="btn btn-secondary" id="deckDetailSettingsBtn">Settings</button>
                        <button class="btn btn-secondary" id="deckDetailEditBtn">Edit</button>
                        <button class="btn btn-danger" id="deckDetailDeleteBtn">Delete</button>
                    </div>
                </div>
                <h3 class="section-title">Cards in this deck</h3>
                <div class="deck-cards-list" id="deckCardsList"></div>
            </div>
            <div class="create-section">
                <div class="section-title">Start a new deck</div>
                <div class="create-options">
                    <div class="create-card" onclick="showEditor()">
                        <span class="create-icon"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L10.582 16.07a4.5 4.5 0 0 1-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 0 1 1.13-1.897l8.932-8.931Zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0 1 15.75 21H5.25A2.25 2.25 0 0 1 3 18.75V8.25A2.25 2.25 0 0 1 5.25 6H10" /></svg></span>
                        <div class="create-title">Create Manually</div>
                        <div class="create-desc">Build your own deck card-by-card</div>
                    </div>
                    <div class="create-card" onclick="showImportModal()">
                         <span class="create-icon"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 16.5V9.75m0 0 3 3m-3-3-3 3M6.75 19.5a4.5 4.5 0 0 1-1.41-8.775 5.25 5.25 0 0 1 10.233-2.33 3 3 0 0 1 3.758 3.848A3.752 3.752 0 0 1 18 19.5H6.75Z" /></svg></span>
                         <div class="create-title">Import Deck</div>
                         <div class="create-desc">Import from JSON, CSV, or pasted text</div>
                     </div>
                </div>
            </div>
             <div class="dashboard-footer">
                <button class="btn btn-secondary" onclick="showAnalyticsModal()">Show Analytics</button>
                <button class="btn btn-secondary" onclick="showInternalAnalytics()" style="margin-left: 10px;">Internal Dashboard</button>
            </div>
        </div>
    </div> 

<div id="internalAnalyticsView" class="container view-container">
<div class="section-title" style="padding-top: 20px;">Internal Analytics Dashboard</div>
<div class="settings-container">

    <div class="settings-section">
        <h2>Interaction Metrics Distributions</h2>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 25px;">
            <div>
                <h4>Recall Latency (ms)</h4>
                <canvas id="latencyHistogram"></canvas>
            </div>
            <div>
                <h4>Answer Fluency (chars/sec)</h4>
                <canvas id="fluencyHistogram"></canvas>
            </div>
            <div>
                <h4>Corrections per Answer</h4>
                <canvas id="correctionsHistogram"></canvas>
            </div>
        </div>
    </div>

    <div class="settings-section">
        <h2>Latency vs. Correctness</h2>
        <canvas id="latencyScatterPlot" style="max-height: 400px;"></canvas>
    </div>

    <div class="settings-section">
        <h2>Interactions Per Day</h2>
        <canvas id="interactionsTimeSeries" style="max-height: 400px;"></canvas>
    </div>

    <div class="settings-section">
        <h2>Common Error Analysis</h2>
        <div class="form-row">
            <div class="form-group">
                <label for="errorDeckSelect">Select Deck</label>
                <select id="errorDeckSelect"></select>
            </div>
            <div class="form-group">
                <label for="errorCardSelect">Select Card</label>
                <select id="errorCardSelect"></select>
            </div>
        </div>
        <div id="errorAnalysisResult" style="margin-top: 20px;">
            <p>Please select a card to see a breakdown of common incorrect answers.</p>
        </div>
    </div>

</div>
</div>
    
    <div id="editorView" class="container view-container">
        <div class="editor-container" style="margin-top:20px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px; padding-bottom: 20px; border-bottom: 2px solid var(--border-color);">
                <h2 style="font-size: 1.8rem; font-weight: 700;">Create / Edit Deck</h2>
                <button class="btn btn-success" onclick="editorSaveDeck()">Save Deck</button>
            </div>
            <div class="form-section">
                <div class="form-row">
                    <div class="form-group">
                        <label for="deckTitle">Title</label>
                        <input type="text" id="deckTitle" placeholder="Enter deck title">
                    </div>
                     <div class="form-group">
                        <label for="deckCategory">Category</label>
                        <select id="deckCategory" class="form-group"></select>
                    </div>
                </div>
                <div class="form-group">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <label for="deckNotes" style="margin-bottom: 0;">Notes (optional, shown before studying)</label>
                        <button class="btn btn-secondary" style="padding: 5px 10px; font-size: 12px;" onclick="triggerNotesImageUpload(this)">Add Image</button>
                        <input type="file" class="image-upload-input" accept="image/*" style="display:none;" onchange="handleNotesImageUpload(this)">
                    </div>
                    <textarea id="deckNotes" placeholder="Add any notes, summaries, or instructions for this deck..."></textarea>
                </div>
            </div>
            <div class="flashcards-section">
                <div id="flashcardsContainer"></div>
                <button class="add-question-btn" onclick="editorAddNewCard()">+ Add Question</button>
                <div class="actions-section">
                    <button class="btn btn-success" onclick="editorSaveDeck()">Save Deck</button>
                </div>
            </div>
        </div>
    </div>
    
    <div id="settingsView" class="container view-container">
        <div class="settings-container" style="margin-top:20px;">
            <div class="settings-section">
                <h2>Profile</h2>
                <div class="form-group">
                <label for="usernameInput">Your Name</label>
                <input type="text" id="usernameInput" placeholder="Enter your name">
            </div>
            <button class="btn" onclick="saveUsername()">Save Name</button>
        </div>
        <div class="settings-section">
            <h2>Appearance</h2>
            <div class="dark-mode-toggle">
                <label for="darkModeToggle">Dark Mode</label>
                <label class="switch">
                    <input type="checkbox" id="darkModeToggle">
                    <span class="slider"></span>
                </label>
            </div>
        </div>
         <div class="settings-section">
            <h2>Study Settings</h2>
            <div class="checkbox-group">
                <input type="checkbox" id="enableInStudyEditing">
                <label for="enableInStudyEditing">Enable card editing during study sessions</label>
            </div>
            <button class="btn" onclick="saveStudySettings()">Save Study Settings</button>
            
        </div>
        <div class="settings-section">
            <h2>Danger Zone</h2>
            <p style="color: var(--secondary-text); margin-bottom: 15px;">These actions are permanent and cannot be undone.</p>
            <button class="btn btn-danger" onclick="clearAllDecks()">Clear All Decks</button>
        </div>
    </div>
</div>

<div id="studyMode" class="container view-container">
    <div class="study-container">
        <div class="study-header">
            <div class="study-header-content">
                <div class="study-title" id="studyTitle">Learning Mode</div>
                <div class="study-subtitle" id="studySubtitle">Deck Name</div>
            </div>
            <div class="study-header-actions">
                 <button id="accentToggleBtn" class="header-btn hidden" title="Toggle Accents">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" width="20" height="20"><path stroke-linecap="round" stroke-linejoin="round" d="M12 21a9.004 9.004 0 0 0 8.716-6.747M12 21a9.004 9.004 0 0 1-8.716-6.747M12 21c1.356 0 2.673-.174 3.946-.512M12 21c-1.273 0-2.59-.174-3.872-.512M21 12a9 9 0 0 0-9-9c-1.356 0-2.673.174-3.946.512M3 12a9 9 0 0 1 9-9c1.273 0 2.59.174 3.872.512M12 3v18" /></svg>
                </button>
                <button id="editStudyCardBtn" class="header-btn hidden" title="Edit Card">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" width="20" height="20">
                        <path stroke-linecap="round" stroke-linejoin="round" d="m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L10.582 16.07a4.5 4.5 0 0 1-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 0 1 1.13-1.897l8.932-8.931Zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0 1 15.75 21H5.25A2.25 2.25 0 0 1 3 18.75V8.25A2.25 2.25 0 0 1 5.25 6H10" />
                    </svg>
                </button>
                <button id="switchStudyModeBtn" class="header-btn hidden" title="Switch Study Mode">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" width="20" height="20">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M16.862 4.487l1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L6.832 19.82a4.5 4.5 0 0 1-1.897 1.13l-2.685.8.8-2.685a4.5 4.5 0 0 1 1.13-1.897L16.863 4.487zm0 0L19.5 7.125" />
                    </svg>
                </button>
                <button id="instructionsBtn" class="header-btn" title="Instructions">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" width="20" height="20"><path stroke-linecap="round" stroke-linejoin="round" d="M9.879 7.519c1.171-1.025 3.071-1.025 4.242 0 1.172 1.025 1.172 2.687 0 3.712-.203.179-.43.326-.67.442-.745.361-1.45.999-1.45 1.827v.75M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 5.25h.008v.008H12v-.008Z" /></svg>
                </button>
            </div>
        </div>
        <div id="progressView" class="hidden sub-view">
            <div class="progress-dashboard">
                <div id="deckNotesDisplay" class="hidden"></div>
                <div class="progress-title" id="progressTitle">Learning Progress</div>
                <div class="round-info" id="roundInfo">Round 1 - 0 of 0 cards</div>
                <div class="buckets-grid" id="bucketsContainer"></div>
                <div class="progress-bar-container"><div class="progress-fill" id="progressBarFill" style="width: 0%"></div></div>
                <div class="stats" id="statsContainer"></div>
                <div style="text-align: center; margin-top: 25px;">
                    <button class="btn" id="continueBtn">Continue Round</button>
                    <button class="btn btn-secondary" onclick="endSession()" style="margin-left: 10px;">End Session</button>
                    <button class="btn btn-danger" id="resetBtn" onclick="resetProgress()" style="margin-left: 10px;">Reset Progress</button>
                </div>
            </div>
        </div>
        <div id="cardView" class="hidden sub-view">
            <div class="round-info" id="cardRoundInfo">Round 1 - Card 1 of 5</div>
            <div class="flashcard">
                <div class="flashcard-inner">
                    <div class="flashcard-front">
                        <div id="cardBucketInfo">New</div>
                        <div id="cardQuestionContent">
                            <div class="question" id="cardQuestion"></div>
                        </div>
                    </div>
                    <div class="flashcard-back">
                        <div id="cardAnswerContent" class="hidden">
                            <div class="answer" id="cardAnswer"></div>
                        </div>
                    </div>
                </div>
            </div>
            <div style="text-align: center; margin-top: 20px;">
                <textarea id="writeAnswerInput" class="form-group textarea hidden" placeholder="Type your answer here..."></textarea>
                <div id="accentButtonsContainer" class="accent-buttons hidden"></div>
                <div id="userAnswerDisplay" class="answer hidden" style="border: 2px solid var(--border-color); margin-bottom: 10px;"></div>
            </div>
            <div class="answer-buttons" id="simpleAnswerButtons">
                <button class="btn btn-show" id="showAnswerBtn" onclick="showAnswer()">Show Answer</button>
                <button class="btn btn-secondary hidden" id="showQuestionBtn" onclick="showQuestion()">Show Question</button>
                <button class="btn btn-show hidden" id="checkAnswerBtn" onclick="autoCheckAnswer()">Check Answer</button>
                <button class="btn btn-incorrect hidden" id="incorrectBtn" onclick="markIncorrect()">Incorrect</button>
                <button class="btn btn-correct hidden" id="correctBtn" onclick="markCorrect()">Correct</button>
            </div>
        </div>
        <div id="completeView" class="hidden sub-view">
            <div class="progress-dashboard">
                <div class="progress-title">Complete!</div>
                <p style="text-align: center; font-size: 1.2rem; margin: 25px 0; color: var(--secondary-text);">Congratulations! You've mastered all your flashcards.</p>
                <div class="stats" id="finalStats"></div>
                <div style="text-align: center; margin-top: 25px;">
                    <button class="btn" onclick="restartStudy()">Study Again</button>
                    <button class="btn btn-secondary" onclick="endSession()" style="margin-left: 10px;">End Session</button>
                </div>
            </div>
        </div>
    </div>
</div>

<div id="practiceTestModal" class="modal">
    <div class="modal-content" style="max-width: 500px;">
        <span class="close" onclick="closePracticeTestModal()">&times;</span>
        <h2>Practice Test</h2>
        <div class="form-group">
            <label for="testType">Test Type</label>
            <select id="testType">
                <option value="flashcard">Flashcards</option>
                <option value="multiple_choice">Multiple Choice</option>
                <option value="type">Type Answer</option>
                <option value="mixed">Mixed Types</option>
            </select>
        </div>
        <div class="form-group">
            <label for="numQuestions">Number of Questions</label>
            <input type="number" id="numQuestions" min="1" max="100" value="10">
        </div>
        <div class="modal-actions">
            <button class="btn btn-secondary" onclick="closePracticeTestModal()">Cancel</button>
            <button class="btn btn-success" onclick="startPracticeTest()">Start Test</button>
        </div>
    </div>
</div>

<div id="practiceTestView" class="container view-container">
    <div class="study-container">
        <div class="study-header">
            <div class="study-header-content">
                <div class="study-title" id="testTitle">Practice Test</div>
                <div class="study-subtitle" id="testSubtitle">Deck Name</div>
            </div>
            <div class="study-header-actions">
                <button id="testAccentToggleBtn" class="header-btn hidden" title="Toggle Accents">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" width="20" height="20"><path stroke-linecap="round" stroke-linejoin="round" d="M12 21a9.004 9.004 0 0 0 8.716-6.747M12 21a9.004 9.004 0 0 1-8.716-6.747M12 21c1.356 0 2.673-.174 3.946-.512M12 21c-1.273 0-2.59-.174-3.872-.512M21 12a9 9 0 0 0-9-9c-1.356 0-2.673.174-3.946.512M3 12a9 9 0 0 1 9-9c1.273 0 2.59.174 3.872.512M12 3v18" /></svg>
                </button>
                <button id="testInstructionsBtn" class="header-btn" title="Instructions">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" width="20" height="20"><path stroke-linecap="round" stroke-linejoin="round" d="M9.879 7.519c1.171-1.025 3.071-1.025 4.242 0 1.172 1.025 1.172 2.687 0 3.712-.203.179-.43.326-.67.442-.745.361-1.45.999-1.45 1.827v.75M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 5.25h.008v.008H12v-.008Z" /></svg>
                </button>
            </div>
        </div>
        <div id="testProgressView" class="hidden sub-view">
            <div class="progress-dashboard">
                <div class="progress-title">Test Progress</div>
                <div class="round-info" id="testInfo">0 of 0 questions</div>
                <div class="progress-bar-container"><div class="progress-fill" id="testProgressBar" style="width: 0%"></div></div>
                <div class="stats">
                    <div class="stat"><div class="stat-value" id="testCorrectCount">0</div><div class="stat-label">Correct</div></div>
                    <div class="stat"><div class="stat-value" id="testIncorrectCount">0</div><div class="stat-label">Incorrect</div></div>
                </div>
                <div style="text-align: center; margin-top: 25px;">
                    <button class="btn" onclick="startTest()">Start Test</button>
                </div>
            </div>
        </div>
        <div id="testCardView" class="hidden sub-view">
            <div class="round-info" id="testCardInfo">Question 1 of 10</div>
            <div class="flashcard">
                <div class="flashcard-inner">
                    <div class="flashcard-front">
                        <div class="question" id="testQuestion"></div>
                    </div><br><br><br><br>
                    <br>
                    <div class="flashcard-back">
                        <div id="testAnswerContent" class="hidden">
                            <div class="answer" id="testAnswer"></div>
                        </div>
                    </div>
                    <br><br><br>
                </div>
            </div>
            <div id="testOptions" class="hidden"></div>
            <div style="text-align: center; margin-top: 30px;">
                <textarea id="testAnswerInput" class="form-group textarea hidden" placeholder="Type your answer here..."></textarea>
                <div id="testAccentButtonsContainer" class="accent-buttons hidden"></div>
            </div>
            <div class="answer-buttons">
                <button class="btn btn-show" id="testShowAnswerBtn" onclick="showTestAnswer()">Show Answer</button>
                <button class="btn btn-show hidden" id="testCheckAnswerBtn" onclick="checkTestAnswer()">Check Answer</button>
                <button class="btn btn-incorrect hidden" id="testIncorrectBtn" onclick="markTestIncorrect()">Incorrect</button>
                <button class="btn btn-correct hidden" id="testCorrectBtn" onclick="markTestCorrect()">Correct</button>
                <button class="btn btn-success hidden" id="testNextBtn" onclick="nextTestQuestion()">Next</button>
            </div>
        </div>
        <div id="testCompleteView" class="hidden sub-view">
            <div class="progress-dashboard">
                <div class="progress-title">Test Complete!</div>
                <p style="text-align: center; font-size: 1.2rem; margin: 25px 0; color: var(--secondary-text);">
                    You scored <span id="testScore">0</span>% (<span id="testCorrectFinal">0</span> out of <span id="testTotalFinal">0</span>)
                </p>
                <div class="stats">
                    <div class="stat"><div class="stat-value" id="testTime">0s</div><div class="stat-label">Time Taken</div></div>
                    <div class="stat"><div class="stat-value" id="testAccuracy">0%</div><div class="stat-label">Accuracy</div></div>
                </div>
                <div style="text-align: center; margin-top: 25px;">
                    <button class="btn" onclick="restartTest()">Retake Test</button>
                    <button class="btn btn-secondary" onclick="endTest()" style="margin-left: 10px;">End Test</button>
                </div>
            </div>
        </div>
    </div>
</div>

<div id="importModal" class="modal">
    <div class="modal-content" style="max-width: 700px;">
        <span class="close" onclick="closeImportModal()">&times;</span>
        <h2>Import Deck</h2>
        <div class="import-tabs">
            <div id="importTabPaste" class="import-tab active" onclick="switchImportTab('paste')">Paste Text</div>
            <div id="importTabFile" class="import-tab" onclick="switchImportTab('file')">Import File</div>
        </div>
        <div id="importContentPaste">
            <div class="form-group">
                <label for="importPastedText">Paste your content here</label>
                <textarea id="importPastedText" style="min-height: 200px;" placeholder="Question 1<Tab>Answer 1&#x0a;Question 2<Tab>Answer 2"></textarea>
            </div>
            <p style="font-size: 1.1rem; color: var(--secondary-text); text-align: left; margin-top: -15px; margin-bottom: 20px;">Separate terms and definitions with a Tab, and separate cards with a new line.</p>
        </div>
        <div id="importContentFile" class="hidden">
            <div class="form-group">
                <label for="importFileInput" class="custom-file-upload">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" width="20" height="20" style="vertical-align: middle; margin-right: 8px;"><path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5m-13.5-9L12 3m0 0 4.5 4.5M12 3v13.5" /></svg>
                    Choose File
                </label>
                <input type="file" id="importFileInput" accept=".json,.csv,.txt">
                <div id="fileNameDisplay">No file chosen</div>
                <p style="font-size: 1.1rem; color: var(--secondary-text); text-align: left; margin-top: 10px;">Supports .json (exported from here), .csv, and .txt files.</p>
            </div>
        </div>
        <div class="form-group">
            <label for="importDeckName">New Deck Name</label>
            <input type="text" id="importDeckName" placeholder="e.g., Biology Chapter 5">
        </div>
        <div class="modal-actions">
            <button class="btn btn-success" onclick="importData()">Import and Create Deck</button>
        </div>
    </div>
</div>

<div id="confirmActionModal" class="modal">
    <div class="modal-content text-center">
        <h2 id="confirmActionTitle">Confirm Action</h2>
        <p id="confirmActionText"></p>
        <div class="modal-actions">
            <button id="confirmActionCancelBtn" class="btn btn-secondary" onclick="cancelAction()">Cancel</button>
            <button id="confirmActionConfirmBtn" class="btn btn-danger">Confirm</button>
        </div>
    </div>
</div>

<div id="editCardModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="closeEditCardModal()">&times;</span>
        <h2>Edit Flashcard</h2>
        <div class="form-group">
            <label for="editCardQuestion">Question</label>
            <textarea id="editCardQuestion" class="question-input"></textarea>
        </div>
        <div class="form-group">
            <label for="editCardAnswer">Answer</label>
            <textarea id="editCardAnswer" class="solution-input"></textarea>
        </div>
        <div class="modal-actions" style="margin-top: 15px;">
            <button class="btn btn-secondary" onclick="closeEditCardModal()">Cancel</button>
            <button class="btn btn-success" onclick="saveEditedCard()">Save Changes</button>
        </div>
    </div>
</div>

<div id="nameModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="closeNameModal()">&times;</span>
        <h2>Welcome to StudyStack Revise!</h2>
        <p>What should we call you?</p>
        <form id="nameForm">
            <div class="form-group">
                <input type="text" id="nameInput" placeholder="Enter your name" required>
            </div>
            <div class="modal-actions">
                <button type="submit" class="btn">Get Started</button>
            </div>
        </form>
    </div>
</div>

<div id="addCategoryModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="closeAddCategoryModal()">&times;</span>
        <h2>Add New Category</h2>
        <div class="form-group">
            <label for="newCategoryInput">Category Name</label>
            <input type="text" id="newCategoryInput" placeholder="e.g., Biology">
        </div>
        <div class="modal-actions">
            <button class="btn" onclick="saveNewCategory()">Add Category</button>
        </div>
    </div>
</div>

<div id="deckSettingsModal" class="modal">
    <div class="modal-content" style="max-width: 600px;">
        <span class="close" onclick="closeDeckSettingsModal()">&times;</span>
        <h2>Deck Settings</h2>
        <div id="deckSettingsForm">
             <div class="settings-section">
                <h4>Learn Mode Options</h4>
                <div class="form-group">
                    <fieldset class="settings-option-group">
                        <legend>Default Study Method</legend>
                        
                        <div class="radio-option-row" onclick="document.getElementById('deckSettingsStudyModeFlashcard').checked = true;">
                            <input type="radio" id="deckSettingsStudyModeFlashcard" name="deckSettingsStudyMode" value="flashcard" checked>
                            <label for="deckSettingsStudyModeFlashcard">Flashcard Mode</label>
                        </div>
                
                        <div class="radio-option-row" onclick="document.getElementById('deckSettingsStudyModeWrite').checked = true;">
                            <input type="radio" id="deckSettingsStudyModeWrite" name="deckSettingsStudyMode" value="write">
                            <label for="deckSettingsStudyModeWrite">Type Mode</label>
                        </div>
                
                    </fieldset>
                </div>
                <div class="form-group">
                    <label for="deckSettingsCardsPerRound">Cards per Round</label>
                    <select id="deckSettingsCardsPerRound">
                        <option value="5">5</option>
                        <option value="10">10</option>
                        <option value="15">15</option>
                        <option value="20">20</option>
                        <option value="all">All</option>
                    </select>
                </div>
                <div class="form-group">
                     <label for="bucketCount">Number of Learning Buckets</label>
                     <select id="bucketCount">
                         <option value="3">3 Buckets</option>
                         <option value="4">4 Buckets</option>
                         <option value="5">5 Buckets</option>
                     </select>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="retypeIncorrectToggle">
                    <label for="retypeIncorrectToggle">Require retyping incorrect answers</label>
                </div>
            </div>
            <div class="settings-section">
                <h4>Auto-marking (Type Mode)</h4>
                <h5>AI Auto-Marking (Hides manual buttons)</h5><br>
                <div class="checkbox-group">
                    <input type="checkbox" id="forgivingAutomarkingToggle">
                    <label for="forgivingAutomarkingToggle">Enable AI Auto-marking</label>
                </div>
                <h5>Auto-detection</h5><br>
                 <div class="checkbox-group">
                    <input type="checkbox" id="caseSensitiveToggle">
                    <label for="caseSensitiveToggle">Case-Sensitive Matching</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="punctuationToggle">
                    <label for="punctuationToggle">Consider Punctuation</label>
                </div>
            </div>
            <div class="settings-section">
                <h4>Review Mode</h4>
                <div class="form-group">
                     <label for="reviewOrder">Card Order</label>
                     <select id="reviewOrder">
                         <option value="random">Random</option>
                         <option value="alphabetical">Alphabetical</option>
                     </select>
                </div>
            </div>

            <div class="modal-actions" style="margin-top: 20px;">
                <button class="btn btn-secondary" onclick="closeDeckSettingsModal()">Cancel</button>
                <button class="btn btn-success" onclick="saveDeckSettings()">Save Settings</button>
            </div>
        </div>
    </div>
</div>


<div id="instructionsModal" class="modal">
    <div class="modal-content">
         <span class="close" onclick="this.parentElement.parentElement.classList.remove('show')">&times;</span>
         <h2>Keyboard Shortcuts</h2>
         <p style="text-align: left; margin-top: 20px; line-height: 1.8;">
            <b>During Simple Flashcard Mode:</b><br>
            - <b>Space / Enter</b>: Show Answer<br>
            - <b>→ / 2</b>: Mark as Correct<br>
            - <b>← / 1</b>: Mark as Incorrect<br><br>
            <b>During Type Mode:</b><br>
            - <b>Enter / ↑</b>: Check Answer<br>
            - <b>→ / 2</b>: Mark as Correct (after checking)<br>
            - <b>← / 1</b>: Mark as Incorrect (after checking)<br><br>
            <b>On Progress Screen:</b><br>
            - <b>Enter</b>: Start Next Round
         </p>
    </div>
</div>

<div id="analyticsModal" class="modal">
    <div class="modal-content" style="max-width: 700px;">
        <span class="close" onclick="this.parentElement.classList.remove('show')">&times;</span>
        <h2>Analytics</h2>
        <div class="stats" style="grid-template-columns: repeat(2, 1fr); margin-bottom: 30px;">
            <div class="stat">
                <div class="stat-value" id="analyticsStreak">0 days</div>
                <div class="stat-label">Current Streak</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="analyticsTotalTime">0m</div>
                <div class="stat-label">Total Study Time</div>
            </div>
        </div>
        <h4>Session History</h4>
        <div id="analyticsSessionList" style="max-height: 300px; overflow-y: auto; margin-top: 15px;">
            <p>No study sessions recorded yet.</p>
        </div>
    </div>
</div>

<script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js';
    
    let db;
    let decks = {};
    let categories = ["Science", "Maths", "Language",];
    let globalSettings = {};
    let analyticsData = {
        lastUsed: null,
        streak: 0,
        totalStudyTime: 0, 
        sessions: []
    };

    let currentDeckId = null;
    let currentMode = null;
    let confirmCallback = null;
    let cardToEdit = { deckId: null, cardIndex: null, from: null };
    let studyState = {
        buckets: [],
        currentRound: 1,
        currentCardIndex: 0, 
        roundCards: [], 
        settings: {},
        lastRoundIncorrect: [],
        isRetypingIncorrect: false,
        startTime: null,
        activeLearningPool: [],
        knowledgeStates: new Map()
    };
    const DEFAULT_DECK_SETTINGS = { learnMode: 'flashcard', reviewOrder: 'random', cardsPerRound: 10, maxBuckets: 4, caseSensitive: false, punctuation: false, retypeIncorrect: true, feedbackStyle: 'simple', forgivingAutomarking: false };
    let editorCardCounter = 0;
    let currentViewingDeckId = null;
    let activeView = 'dashboard';
    let viewHistory = [];

    let practiceTestState = {
        deckId: null,
        cards: [],
        currentCardIndex: 0,
        correctCount: 0,
        incorrectCount: 0,
        startTime: null,
        testType: 'flashcard',
        numQuestions: 10
    };

    window.onload = function() {
        initDB().then(() => {
            loadSavedData();
            setupEventListeners();
            showView('dashboard', true);
        }).catch(error => {
            console.error("Failed to initialize the database:", error);
            showToast("Could not start the application. Database initialization failed.", "error");
        });
    };
    
    function initDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open('StudyStackDB', 4); 

            request.onerror = event => reject("Error opening DB: " + event.target.errorCode);
            
            request.onsuccess = event => {
                db = event.target.result;
                resolve();
            };

            request.onupgradeneeded = event => {
                db = event.target.result;
                const transaction = event.target.transaction;

                if (!db.objectStoreNames.contains('decks')) {
                    db.createObjectStore('decks', { keyPath: 'id' });
                }
                if (!db.objectStoreNames.contains('appData')) {
                    db.createObjectStore('appData', { keyPath: 'key' });
                }
                if (!db.objectStoreNames.contains('concepts')) {
                    db.createObjectStore('concepts', { keyPath: 'conceptID' });
                }
                if (!db.objectStoreNames.contains('userKnowledgeState')) {
                    db.createObjectStore('userKnowledgeState', { keyPath: ['userID', 'cardID'] });
                }
                
                if (!db.objectStoreNames.contains('interactionLogs')) {
                    const logStore = db.createObjectStore('interactionLogs', { keyPath: 'id', autoIncrement: true });
                    logStore.createIndex('by_cardID', 'cardID', { unique: false });
                    logStore.createIndex('by_timestamp', 'timestamp', { unique: false });
                    console.log("Created 'interactionLogs' object store.");
                }

                if (event.oldVersion < 3) {
                    console.log("Starting database migration for Milestone 1.1...");
                    const deckStore = transaction.objectStore('decks');
                    const conceptStore = transaction.objectStore('concepts');
                    const stateStore = transaction.objectStore('userKnowledgeState');

                    deckStore.getAll().onsuccess = (e) => {
                        const allDecks = e.target.result;
                        if (!allDecks || allDecks.length === 0) return;

                        allDecks.forEach(deck => {
                            let deckNeedsUpdate = false;
                            deck.cards.forEach(card => {
                                if (card.conceptID) return;
                                deckNeedsUpdate = true;
                                const newConceptID = `concept-${Date.now()}-${Math.random().toString(36).substr(2, 9)}`;
                                conceptStore.put({ conceptID: newConceptID, createdAt: new Date().toISOString() });
                                card.conceptID = newConceptID;
                                card.cardArchetype = 'Paired Association';
                                stateStore.put({
                                    userID: 'default_user', cardID: card.id, masteryScore: 0.5, stability: 1.0,
                                    lastReviewed: card.sm2Data ? card.sm2Data.dueDate : new Date().toISOString(), recallHistory: []
                                });
                            });
                            if (deckNeedsUpdate) deckStore.put(deck);
                        });
                        console.log("Migration for Milestone 1.1 complete.");
                    };
                }
            };
        });
    }
    
    let currentInteractionLog = {};

    
    function startInteractionLog(cardID) {
        currentInteractionLog = {
            cardID: cardID,
            questionLoadTime: performance.now(),
            firstKeyPressTime: null,
            backspaceCount: 0,
            deleteCount: 0,
            attemptCount: (studyState.isRetypingIncorrect ? 2 : 1) 
        };
    }

    
    function handleInteractionLogging(e) {
        
        if (currentInteractionLog.firstKeyPressTime === null && e.key.length === 1) {
            currentInteractionLog.firstKeyPressTime = performance.now();
        }

        
        if (e.key === 'Backspace') {
            currentInteractionLog.backspaceCount++;
        } else if (e.key === 'Delete') {
            currentInteractionLog.deleteCount++;
        }
    }
    
    async function logInteraction(logData) {
    if (!db) {
        console.error("Database not available for logging interaction.");
        return;
    }

    try {
        const transaction = db.transaction(['interactionLogs'], 'readwrite');
        const store = transaction.objectStore('interactionLogs');
        
        const logEntry = {
            userID: 'default_user', 
            cardID: logData.cardID,
            timestamp: new Date().toISOString(),
            wasCorrect: logData.wasCorrect,
            latency: logData.recallLatency,
            fluency: logData.answerFluency,
            corrections: logData.totalCorrections,
            attempts: logData.attemptCount,
            userAnswer: logData.userAnswer,
            synced: false 
        };
        
        store.add(logEntry);

        transaction.onerror = (event) => {
            console.error("Error saving interaction log to IndexedDB:", event.target.error);
        };
    } catch (error) {
        console.error("Failed to initiate IndexedDB transaction for logging:", error);
    }
}

        let chartInstances = {};

        async function showInternalAnalytics() {
            showView('internalAnalyticsView');
            
            try {
                const transaction = db.transaction(['interactionLogs'], 'readonly');
                const store = transaction.objectStore('interactionLogs');
                const allLogs = await new Promise((resolve, reject) => {
                    const request = store.getAll();
                    request.onsuccess = () => resolve(request.result);
                    request.onerror = () => reject(request.error);
                });

                if (!allLogs || allLogs.length === 0) {
                    console.warn("No interaction logs found to generate analytics.");
                    
                    return;
                }

                renderHistograms(allLogs);
                renderLatencyScatterPlot(allLogs);
                renderInteractionsTimeSeries(allLogs);
                setupErrorAnalysis(allLogs);

            } catch (error) {
                console.error("Failed to fetch interaction logs for analytics:", error);
            }
        }

        function renderHistograms(logs) {
            const latencies = logs.map(log => log.latency).filter(l => l !== null);
            const fluencies = logs.map(log => log.fluency).filter(f => f > 0);
            const corrections = logs.map(log => log.corrections);

            createBarChart('latencyHistogram', 'Recall Latency', latencies, 'rgba(102, 126, 234, 0.6)');
            createBarChart('fluencyHistogram', 'Answer Fluency', fluencies, 'rgba(56, 178, 172, 0.6)');
            createBarChart('correctionsHistogram', 'Corrections Count', corrections, 'rgba(229, 62, 62, 0.6)');
        }

        function createBarChart(canvasId, label, data, color) {
            if (chartInstances[canvasId]) chartInstances[canvasId].destroy();
            
            const ctx = document.getElementById(canvasId).getContext('2d');
            
            const valueCounts = data.reduce((acc, value) => {
                acc[value] = (acc[value] || 0) + 1;
                return acc;
            }, {});
            const labels = Object.keys(valueCounts).sort((a, b) => a - b);
            const chartData = labels.map(key => valueCounts[key]);

            chartInstances[canvasId] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: `Frequency of ${label}`,
                        data: chartData,
                        backgroundColor: color,
                        borderColor: color.replace('0.6', '1'),
                        borderWidth: 1
                    }]
                },
                options: { scales: { y: { beginAtZero: true } } }
            });
        }

        function renderLatencyScatterPlot(logs) {
            const canvasId = 'latencyScatterPlot';
            if (chartInstances[canvasId]) chartInstances[canvasId].destroy();

            const data = logs.filter(log => log.latency !== null).map(log => ({
                x: log.latency,
                y: log.wasCorrect ? 1 + (Math.random() * 0.1 - 0.05) : 0 + (Math.random() * 0.1 - 0.05) 
            }));

            const ctx = document.getElementById(canvasId).getContext('2d');
            chartInstances[canvasId] = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'User Interaction',
                        data: data,
                        backgroundColor: (context) => context.raw.y > 0.5 ? 'rgba(56, 178, 172, 0.7)' : 'rgba(229, 62, 62, 0.7)',
                    }]
                },
                options: {
                    scales: {
                        x: { title: { display: true, text: 'Recall Latency (ms)' } },
                        y: { 
                            title: { display: true, text: 'Outcome' },
                            ticks: {
                                callback: (value) => value === 1 ? 'Correct' : (value === 0 ? 'Incorrect' : '')
                            },
                            min: -0.2, max: 1.2
                        }
                    }
                }
            });
        }

        
        function renderInteractionsTimeSeries(logs) {
            const canvasId = 'interactionsTimeSeries';
            if (chartInstances[canvasId]) chartInstances[canvasId].destroy();

            const interactionsByDay = logs.reduce((acc, log) => {
                const day = new Date(log.timestamp).toISOString().split('T')[0];
                acc[day] = (acc[day] || 0) + 1;
                return acc;
            }, {});

            const sortedDays = Object.keys(interactionsByDay).sort();
            const chartLabels = sortedDays;
            const chartData = sortedDays.map(day => interactionsByDay[day]);

            const ctx = document.getElementById(canvasId).getContext('2d');
            chartInstances[canvasId] = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: chartLabels,
                    datasets: [{
                        label: 'Number of Interactions',
                        data: chartData,
                        fill: false,
                        borderColor: 'rgba(102, 126, 234, 1)',
                        tension: 0.1
                    }]
                }
            });
        }

        
        function setupErrorAnalysis(logs) {
            const deckSelect = document.getElementById('errorDeckSelect');
            const cardSelect = document.getElementById('errorCardSelect');

            deckSelect.innerHTML = '<option value="">-- Select a Deck --</option>';
            Object.values(decks).forEach(deck => {
                const option = document.createElement('option');
                option.value = deck.id;
                option.textContent = deck.name;
                deckSelect.appendChild(option);
            });

            deckSelect.onchange = () => {
                const deckId = deckSelect.value;
                cardSelect.innerHTML = '<option value="">-- Select a Card --</option>';
                if (deckId && decks[deckId]) {
                    decks[deckId].cards.forEach(card => {
                        const option = document.createElement('option');
                        option.value = card.id;
                        option.textContent = card.question.substring(0, 50) + '...'; 
                        cardSelect.appendChild(option);
                    });
                }
                generateErrorAnalysisReport(logs, null); 
            };

            cardSelect.onchange = () => {
                generateErrorAnalysisReport(logs, cardSelect.value);
            };
        }

        
        function generateErrorAnalysisReport(logs, cardId) {
            const resultContainer = document.getElementById('errorAnalysisResult');
            if (!cardId) {
                resultContainer.innerHTML = '<p>Please select a card to see a breakdown of common incorrect answers.</p>';
                return;
            }

            const incorrectAnswers = logs
                .filter(log => log.cardID == cardId && !log.wasCorrect)
                .map(log => log.userAnswer.trim().toLowerCase());

            if (incorrectAnswers.length === 0) {
                resultContainer.innerHTML = '<p>No incorrect answers have been logged for this card yet.</p>';
                return;
            }

            const answerCounts = incorrectAnswers.reduce((acc, answer) => {
                acc[answer] = (acc[answer] || 0) + 1;
                return acc;
            }, {});

            const sortedAnswers = Object.entries(answerCounts).sort(([, a], [, b]) => b - a);

            let tableHTML = `
                <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr>
                            <th style="text-align: left; padding: 8px; border-bottom: 1px solid var(--border-color);">Incorrect Answer</th>
                            <th style="text-align: right; padding: 8px; border-bottom: 1px solid var(--border-color);">Frequency</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            sortedAnswers.forEach(([answer, count]) => {
                tableHTML += `
                    <tr>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);">${answer}</td>
                        <td style="text-align: right; padding: 8px; border-bottom: 1px solid var(--border-color);">${count}</td>
                    </tr>
                `;
            });
            tableHTML += '</tbody></table>';

            resultContainer.innerHTML = tableHTML;
        }
    
    async function saveDataToDB(storeName, data) {
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            const request = store.put(data);
            request.onsuccess = () => resolve();
            request.onerror = event => reject("Error saving data: " + event.target.error);
        });
    }

    async function getDataFromDB(storeName, key) {
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.get(key);
            request.onsuccess = event => resolve(event.target.result);
            request.onerror = event => reject("Error getting data: " + event.target.error);
        });
    }

    async function getAllDataFromDB(storeName) {
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.getAll();
            request.onsuccess = event => resolve(event.target.result);
            request.onerror = event => reject("Error getting all data: " + event.target.error);
        });
    }
    
    async function deleteDataFromDB(storeName, key) {
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            const request = store.delete(key);
            request.onsuccess = () => resolve();
            request.onerror = (event) => reject("Error deleting data: " + event.target.error);
        });
    }
    
    async function clearStoreInDB(storeName) {
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            const request = store.clear();
            request.onsuccess = () => resolve();
            request.onerror = event => reject("Error clearing store: " + event.target.error);
        });
    }


    function setupEventListeners() {
        setupSearch();
        setupKeyboardControls();
        
        document.getElementById('deckDetailTestBtn').addEventListener('click', () => openPracticeTestModal(currentViewingDeckId));
        document.getElementById('deckDetailEditBtn').addEventListener('click', () => editDeck(currentViewingDeckId));
        document.getElementById('deckDetailDeleteBtn').addEventListener('click', () => deleteDeck(currentViewingDeckId));
        document.getElementById('deckDetailSettingsBtn').addEventListener('click', () => openDeckSettingsModal(currentViewingDeckId));
        document.getElementById('headerBackBtn').addEventListener('click', goBack);
        document.getElementById('nameForm').addEventListener('submit', saveName);
        document.getElementById('darkModeToggle').addEventListener('change', toggleDarkMode);
        document.getElementById('continueBtn').addEventListener('click', continueStudy);
        document.getElementById('instructionsBtn').addEventListener('click', () => document.getElementById('instructionsModal').classList.add('show'));
        document.getElementById('accentToggleBtn').addEventListener('click', toggleAccentButtons);
        document.getElementById('testAccentToggleBtn').addEventListener('click', toggleTestAccentButtons);
        document.getElementById('switchStudyModeBtn').addEventListener('click', toggleStudyMode);
        document.getElementById('editStudyCardBtn').addEventListener('click', editCurrentStudyCard);
        document.getElementById('writeAnswerInput').addEventListener('keydown', (e) => {
            if ((e.key === 'Enter' && !e.shiftKey) || e.key === 'ArrowUp') {
                e.preventDefault();
                e.stopPropagation();
                const writeInput = document.getElementById('writeAnswerInput');
                const checkAnswerBtnVisible = !document.getElementById('checkAnswerBtn').classList.contains('hidden');
                if (!checkAnswerBtnVisible || writeInput.disabled) return;
                if (writeInput.value.trim() === '') {
                    showToast('Please enter an answer', 'error');
                    return;
                }
                autoCheckAnswer();
            }
        });
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                const visibleModal = document.querySelector('.modal.show');
                if (visibleModal) {
                    visibleModal.classList.remove('show');
                }
            }
        });
        document.getElementById('flashcardsContainer').addEventListener('keydown', function(event) {
            if (event.key === 'Tab' && !event.shiftKey) {
                const activeElement = document.activeElement;
                if (activeElement.classList.contains('solution-input')) {
                    const cardRow = activeElement.closest('.flashcard-editor-row');
                    if (cardRow === this.lastElementChild) {
                        event.preventDefault();
                        editorAddNewCard(); 
                    }
                }
            }
        });
        document.addEventListener('keydown', function(event) {
            const practiceTestView = document.getElementById('practiceTestView');
            if (practiceTestView.classList.contains('hidden')) {
                return;
            }

            if (event.key === 'Enter') {
                const nextBtn = document.getElementById('testNextBtn');
                const checkBtn = document.getElementById('testCheckAnswerBtn');
                const showAnswerBtn = document.getElementById('testShowAnswerBtn');
                if (!nextBtn.classList.contains('hidden')) {
                    event.preventDefault();
                    nextBtn.click();
                }
                else if (!checkBtn.classList.contains('hidden')) {
                    if(event.target === document.getElementById('testAnswerInput')){
                        event.preventDefault();
                    }
                    checkBtn.click();
                }
                else if (!showAnswerBtn.classList.contains('hidden')) {
                    event.preventDefault();
                    showAnswerBtn.click();
                }
            }
        });
        document.getElementById('testInstructionsBtn').addEventListener('click', () => {
            showToast("Practice test instructions would appear here", "info");
        });

        ['deckCategory'].forEach(id => {
            document.getElementById(id).addEventListener('change', handleCategoryChange);
        });

        document.getElementById('importFileInput').addEventListener('change', function() {
            const fileNameDisplay = document.getElementById('fileNameDisplay');
            if (this.files.length > 0) {
                fileNameDisplay.textContent = this.files[0].name;
            } else {
                fileNameDisplay.textContent = 'No file chosen';
            }
        });
        document.getElementById('writeAnswerInput').addEventListener('keydown', handleInteractionLogging);
    }
    
    function showToast(message, type = 'success', duration = 3000) {
        const container = document.getElementById('toast-container');
        const toast = document.createElement('div');
        toast.className = `toast ${type}`;
        toast.textContent = message;
        container.appendChild(toast);
        setTimeout(() => toast.classList.add('show'), 10);
        setTimeout(() => {
            toast.classList.remove('show');
            toast.addEventListener('transitionend', () => toast.remove());
        }, duration);
    }

    function showView(viewId, isInitial = false) {
        if (activeView === viewId && !isInitial) return;
        if (activeView === 'editorView' && !isEditorClean()) {
            showConfirmModal(
                'You have unsaved changes. Are you sure you want to leave?',
                () => transitionView(viewId, isInitial)
            );
            return;
        }
        transitionView(viewId, isInitial);
    }
    
    function transitionView(viewId, isInitial = false) {
         if (!isInitial && activeView !== viewId && viewId !=='dashboard') {
            if(viewHistory[viewHistory.length-1] !== activeView) {
                 viewHistory.push(activeView);
            }
        }
        
        const currentView = document.getElementById(activeView);
        const nextView = document.getElementById(viewId);
        
        const isDashboard = viewId === 'dashboard' && document.getElementById('deckDetailView').classList.contains('hidden');
        document.querySelector('.search-bar').style.display = (viewId === 'dashboard') ? 'flex' : 'none';
        document.getElementById('headerSettingsBtn').style.display = (viewId === 'dashboard') ? 'flex' : 'none';
        document.getElementById('headerBackBtn').classList.toggle('hidden', viewHistory.length === 0 || viewId === 'dashboard');

        if (isInitial) {
            if(currentView) currentView.classList.remove('fade-in', 'fade-out', 'animating');
            nextView.classList.add('fade-in', 'animating');
            activeView = viewId;
            return;
        }

        if (currentView) {
            currentView.classList.add('fade-out', 'animating');
            currentView.classList.remove('fade-in');
            
            setTimeout(() => {
                currentView.style.display = 'none';
                currentView.classList.remove('fade-out', 'animating');
                nextView.style.display = 'block';
                nextView.classList.add('fade-in', 'animating');
                activeView = viewId;
                window.scrollTo(0, 0);
            }, 400);
        }
    }
    
    function transitionSubView(currentElem, nextElem) {
        if (currentElem && !currentElem.classList.contains('hidden')) {
            currentElem.classList.add('sub-view-fade-out', 'animating');
            setTimeout(() => {
                currentElem.classList.add('hidden');
                currentElem.classList.remove('sub-view-fade-out', 'animating');
                if (nextElem) {
                    nextElem.classList.remove('hidden');
                    nextElem.classList.add('sub-view-fade-in', 'animating');
                }
            }, 400);
        } else if (nextElem) {
            nextElem.classList.remove('hidden');
            nextElem.classList.add('sub-view-fade-in', 'animating');
        }
    }

    function goBack() {
        if (activeView === 'editorView' && !isEditorClean()) {
            showConfirmModal(
                'You have unsaved changes. Are you sure you want to leave?',
                () => continueGoBack()
            );
        } else {
            continueGoBack();
        }
    }

    function continueGoBack() {
         const previousView = viewHistory.pop();
        if (previousView) {
            transitionView(previousView);
        } else {
             backToDashboard(true);
        }
    }
    
    function showEditor() { showView('editorView'); editorInitialize(); }
    async function showSettings() {
        const settings = await getDataFromDB('appData', 'userSettings');
         document.getElementById('usernameInput').value = settings?.username || '';
         document.getElementById('enableInStudyEditing').checked = settings?.enableInStudyEditing || false;
         document.getElementById('newCardsPerDay').value = settings?.newCardsPerDay || 20;
         const feedbackStyle = settings?.spacedLearningFeedbackStyle || 'simple';
         document.querySelector(`input[name="spacedFeedbackStyle"][value="${feedbackStyle}"]`).checked = true;
         showView('settingsView');
    }

    async function backToDashboard(isFromLogo = false) {
        const performBack = async () => {
            if (currentDeckId && currentMode) await endSession();
            
            showView('dashboard');
            currentDeckId = null;
            currentMode = null;
            document.getElementById('deckDetailView').classList.add('hidden');
            document.getElementById('decksSection').classList.remove('hidden');
            document.querySelector('.create-section').classList.remove('hidden');
            currentViewingDeckId = null;
            updateDashboard();
            if(isFromLogo) viewHistory = [];
            document.getElementById('headerBackBtn').classList.add('hidden');
        };
        
        if (activeView === 'editorView' && !isEditorClean()) {
            showConfirmModal(
                'You have unsaved changes. Are you sure you want to leave?',
                () => { transitionView('dashboard'); performBack(); }
            );
        } else {
            performBack();
        }
    }
    
    async function loadSavedData() {
        const settings = await getDataFromDB('appData', 'userSettings');
        globalSettings = settings || {};
        globalSettings.newCardsPerDay = globalSettings.newCardsPerDay || 20;

        if (globalSettings.username) {
            document.getElementById('welcomeMessage').textContent = `Welcome back, ${globalSettings.username}!`;
            checkName();
        } else {
            document.getElementById('nameModal').classList.add('show');
        }
        
        const savedCategories = await getDataFromDB('appData', 'categories');
        if(savedCategories) categories = savedCategories.data;
        populateCategoryDropdowns();
        
        const savedDecks = await getAllDataFromDB('decks');
        decks = {};
        const sm2 = new SM2Algorithm();
        savedDecks.forEach(deck => {
            deck.cards.forEach(card => {
                if (!card.sm2Data) {
                    card.sm2Data = sm2.calculateNextReview(card)(3); 
                }
            });
            decks[deck.id] = deck;
        });
        
        const savedAnalytics = await getDataFromDB('appData', 'analytics');
        if (savedAnalytics) analyticsData = savedAnalytics;
        updateStreak();

        if (globalSettings.darkMode) {
            document.body.classList.add('dark-mode');
            document.getElementById('darkModeToggle').checked = true;
        }
        updateDashboard();
    }

    function formatDate(isoString) {
        if (!isoString) return '';
        const date = new Date(isoString);
        return date.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
    }
    
    async function exportDeck(deckId, event) {
        event.stopPropagation();
        let deck = decks[deckId];
        if (!deck) return;
        showToast('Preparing export...', 'info', 2000);
        
        let deckToExport = JSON.parse(JSON.stringify(deck));
        const compressionPromises = [];

        for (const card of deckToExport.cards) {
            if (card.questionImage && card.questionImage.startsWith('data:image')) {
                compressionPromises.push(compressImage(card.questionImage).then(compressed => card.questionImage = compressed));
            }
            if (card.answerImage && card.answerImage.startsWith('data:image')) {
                compressionPromises.push(compressImage(card.answerImage).then(compressed => card.answerImage = compressed));
            }
        }

        await Promise.all(compressionPromises);

        const dataStr = JSON.stringify(deckToExport, null, 2); 
        const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
        const exportFileDefaultName = `${deck.name.replace(/ /g, '_')}_export.json`;
        const linkElement = document.createElement('a');
        linkElement.setAttribute('href', dataUri);
        linkElement.setAttribute('download', exportFileDefaultName);
        linkElement.click();
        showToast('Export started successfully!');
    }

    function updateDashboard() {
        const decksContainer = document.getElementById('decksContainer');
        const deckCount = Object.keys(decks).length;
        const subtitle = document.getElementById('subtitle');
        subtitle.textContent = deckCount === 0 ? "Create your first deck to get started!" : `Your saved decks:`;
        
        if (deckCount === 0) {
            decksContainer.innerHTML = `<div class="no-decks">
                <div class="no-decks-icon"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6.042A8.967 8.967 0 0 0 6 3.75c-1.052 0-2.062.18-3 .512v14.25A8.987 8.987 0 0 1 6 18c2.305 0 4.408.867 6 2.292m0-14.25a8.966 8.966 0 0 1 6-2.292c1.052 0 2.062.18 3 .512v14.25A8.987 8.987 0 0 0 18 18a8.967 8.967 0 0 0-6 2.292m0-14.25v14.25" /></svg></div>
                <div>No flashcard decks yet.<br>Create your first deck to get started!</div>
            </div>`;
            return;
        }

        decksContainer.innerHTML = '';
        const groupedDecks = {};
        for (const deck of Object.values(decks)) {
            const category = deck.category || 'Other';
            if (!groupedDecks[category]) groupedDecks[category] = [];
            groupedDecks[category].push(deck);
        }

        const sortedCategories = Object.keys(groupedDecks).sort((a,b) => categories.indexOf(a) - categories.indexOf(b));

        for (const category of sortedCategories) {
            const categoryFolder = document.createElement('div');
            categoryFolder.className = 'category-folder';
            categoryFolder.innerHTML = `<h3 class="category-title">${category}</h3><div class="decks-grid"></div>`;
            const decksGrid = categoryFolder.querySelector('.decks-grid');

            const sortedDecks = groupedDecks[category].sort((a,b) => new Date(b.created) - new Date(a.created));

            decksGrid.innerHTML = sortedDecks.map(deck => {
                if (!deck.learnState || !deck.settings || !deck.learnState.buckets) {
                    deck.settings = {...DEFAULT_DECK_SETTINGS, ...(deck.settings || {})};
                    const allCards = deck.cards;
                    deck.learnState = { 
                        buckets: [[...allCards]],
                        currentRound: 1, 
                        maxBuckets: deck.settings.maxBuckets
                    };
                }
                 while (deck.learnState.buckets.length < deck.settings.maxBuckets) deck.learnState.buckets.push([]);
                 while (deck.learnState.buckets.length > deck.settings.maxBuckets) {
                    const extraCards = deck.learnState.buckets.pop();
                    if (deck.learnState.buckets.length > 0) deck.learnState.buckets[deck.learnState.buckets.length - 1].push(...extraCards);
                }
                deck.learnState.maxBuckets = deck.settings.maxBuckets;
                
                const totalCards = deck.cards.length;
                const maxBuckets = deck.settings.maxBuckets;
                let currentProgressPoints = 0;
                deck.learnState.buckets.forEach((bucket, i) => {
                    currentProgressPoints += bucket.length * i;
                });
                const maxProgressPoints = totalCards > 0 ? totalCards * (maxBuckets - 1) : 0;
                const progressPercent = maxProgressPoints > 0 ? (currentProgressPoints / maxProgressPoints) * 100 : 0;
                
                return `<div class="deck-card" data-category="${category}" data-deck-id="${deck.id}">
                    <div class="deck-card-main-clickable" onclick="showDeckDetail('${deck.id}', this.parentElement)">
                         <div class="deck-header">
                            <div class="deck-category">${category}</div>
                            <div class="deck-name">${deck.name}</div>
                            <div class="deck-info"><span>${totalCards} cards</span></div>
                        </div>
                        <div class="deck-progress-container">
                             <div class="deck-progress-label"><span>Progress</span><span>${Math.round(progressPercent)}%</span></div>
                             <div class="deck-progress-bar-outer"><div class="deck-progress-bar-inner" style="width: ${progressPercent}%;"></div></div>
                        </div>
                        <div class="deck-date">Created: ${formatDate(deck.created)}</div>
                    </div>
                     <div class="deck-actions">
                        <button class="action-btn learn-btn" onclick="event.stopPropagation(); configureStudy('learn', '${deck.id}')">Learn</button>
                        <button class="action-btn review-btn" onclick="event.stopPropagation(); configureStudy('review', '${deck.id}')">Review</button>
                        <button class="action-btn export-btn" title="Export Deck" onclick="exportDeck('${deck.id}', event)">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" width="18" height="18"><path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5M16.5 12 12 16.5m0 0L7.5 12m4.5 4.5V3" /></svg>
                        </button>
                    </div>
                </div>`;
            }).join('');
            decksContainer.appendChild(categoryFolder);
        }
    }

    function showDeckDetail(deckId, cardElement) {
        const deck = decks[deckId];
        if (!deck) return;
        if (cardElement) {
            cardElement.classList.add('deck-clicked');
            cardElement.addEventListener('animationend', () => cardElement.classList.remove('deck-clicked'), { once: true });
        }
        
        currentViewingDeckId = deckId;
        showView('dashboard');
        
        document.getElementById('deckDetailTitle').textContent = deck.name;
        const categoryElement = document.getElementById('deckDetailCategory');
        const category = deck.category || "Other";
        categoryElement.textContent = category;
        categoryElement.className = `deck-detail-category ${category}`;
        
        const cardsList = document.getElementById('deckCardsList');
        cardsList.innerHTML = '';
        
        if (deck.cards.length === 0) {
            cardsList.innerHTML = '<p style="text-align: center; color: var(--secondary-text);">No cards in this deck yet.</p>';
        } else {
            deck.cards.forEach((card, index) => {
                const cardItem = document.createElement('div');
                cardItem.className = 'deck-card-item';
                const newBadge = card.isNew ? '<span class="new-badge">New</span>' : '';
                const questionImageHTML = card.questionImage ? `<img src="${card.questionImage}" class="card-image">` : '';
                const answerImageHTML = card.answerImage ? `<img src="${card.answerImage}" class="card-image">` : '';
                cardItem.innerHTML = `<div class="deck-card-content">
                        <div class="deck-card-question">${index + 1}. ${card.question} ${newBadge}</div>
                        ${questionImageHTML}
                        <div class="deck-card-answer">${card.answer}</div>
                        ${answerImageHTML}
                    </div>
                    <div class="deck-card-actions">
                        <button class="deck-card-action-btn edit" title="Edit Card" onclick="editCard('${deckId}', ${index}, 'detail')"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" width="16" height="16"><path stroke-linecap="round" stroke-linejoin="round" d="m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L10.582 16.07a4.5 4.5 0 0 1-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 0 1 1.13-1.897l8.932-8.931Zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0 1 15.75 21H5.25A2.25 2.25 0 0 1 3 18.75V8.25A2.25 2.25 0 0 1 5.25 6H10" /></svg></button>
                        <button class="deck-card-action-btn delete" title="Delete Card" onclick="deleteCardFromDetail('${deckId}', ${index})"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" width="16" height="16"><path stroke-linecap="round" stroke-linejoin="round" d="m14.74 9-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 0 1-2.244 2.077H8.084a2.25 2.25 0 0 1-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 0 0-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 0 1 3.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 0 0-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 0 0-7.5 0" /></svg></button>
                    </div>`;
                cardsList.appendChild(cardItem);
            });
        }
        
        document.getElementById('decksSection').classList.add('hidden');
        document.querySelector('.create-section').classList.add('hidden');
        document.getElementById('deckDetailView').classList.remove('hidden');
        
        document.getElementById('headerBackBtn').classList.remove('hidden');
    }

    function editCard(deckId, cardIndex, from) {
        const deck = decks[deckId];
        if (!deck || !deck.cards[cardIndex]) return;
        cardToEdit = { deckId, cardIndex, from };
        const card = deck.cards[cardIndex];
        document.getElementById('editCardQuestion').value = card.question;
        document.getElementById('editCardAnswer').value = card.answer;
        document.getElementById('editCardModal').classList.add('show');
    }
    
    function editCurrentStudyCard() {
        const card = studyState.roundCards[studyState.currentCardIndex];
        const deck = decks[currentDeckId];
        const cardIndexInDeck = deck.cards.findIndex(c => c.id === card.id);
        if (cardIndexInDeck > -1) {
            editCard(currentDeckId, cardIndexInDeck, 'study');
        }
    }

    function closeEditCardModal() {
        document.getElementById('editCardModal').classList.remove('show');
        cardToEdit = { deckId: null, cardIndex: null, from: null };
    }

    async function saveEditedCard() {
        const { deckId, cardIndex, from } = cardToEdit;
        if (deckId === null || cardIndex === null) return;
        
        const deck = decks[deckId];
        const newQuestion = document.getElementById('editCardQuestion').value.trim();
        const newAnswer = document.getElementById('editCardAnswer').value.trim();
        
        if (newQuestion && newAnswer) {
            const originalCard = deck.cards[cardIndex];
            originalCard.question = newQuestion;
            originalCard.answer = newAnswer;
            
            if (from === 'study') {
                const updateCardInArray = (arr) => {
                    const idx = arr.findIndex(c => c.id === originalCard.id);
                    if (idx > -1) arr[idx] = { ...arr[idx], question: newQuestion, answer: newAnswer };
                };
                
                if (currentMode === 'learn' || currentMode === 'spaced') {
                    studyState.buckets.forEach(bucket => updateCardInArray(bucket));
                } else if (currentMode === 'review') {
                    updateCardInArray(studyState.stillLearning);
                    updateCardInArray(studyState.correct);
                }
                updateCardInArray(studyState.roundCards);
                showNextCard(); 
            }
            
            await saveDataToDB('decks', deck);
            if (from === 'detail' && currentViewingDeckId === deckId) showDeckDetail(deckId);
            
            closeEditCardModal();
        } else {
            showToast("Question and Answer cannot be empty.", 'error');
        }
    }

    async function deleteCardFromDetail(deckId, cardIndex) {
        const deck = decks[deckId];
        if (!deck || !deck.cards[cardIndex]) return;
        
        showConfirmModal('Are you sure you want to delete this card?', async () => {
            deck.cards.splice(cardIndex, 1);
            await saveDataToDB('decks', deck);
            showDeckDetail(deckId);
            updateDashboard();
            showToast('Card deleted.');
        });
    }

    function setupSearch() {
        document.getElementById('searchInput').addEventListener('input', function() {
            const query = this.value.toLowerCase().trim();
            document.querySelectorAll('.deck-card').forEach(cardElement => {
                const deckId = cardElement.dataset.deckId;
                if (!deckId || !decks[deckId]) return;
                const deck = decks[deckId];
                let isMatch = deck.name.toLowerCase().includes(query) || (deck.category && deck.category.toLowerCase().includes(query));
                cardElement.style.display = isMatch ? 'flex' : 'none';
            });
            document.querySelectorAll('.category-folder').forEach(folder => {
                const visibleCards = folder.querySelectorAll('.deck-card[style*="display: flex"], .deck-card:not([style])');
                folder.style.display = visibleCards.length > 0 ? 'block' : 'none';
            });
        });
    }
    
    async function createNewDeck(name, category, cards, notes = '') {
        const deckId = Date.now().toString();
        const settings = { ...DEFAULT_DECK_SETTINGS };
        const sm2 = new SM2Algorithm();
        const processedCards = cards.map(c => ({
            ...c,
            sm2Data: sm2.calculateNextReview(c)(3)
        }));

        const newDeck = {
            id: deckId, name, category, cards: processedCards, notes,
            created: new Date().toISOString(),
            settings: settings,
            learnState: {
                buckets: [[...processedCards], ...Array.from({length: settings.maxBuckets - 1}, () => [])],
                currentRound: 1, maxBuckets: settings.maxBuckets
            },
            reviewState: { stillLearning: [...processedCards], correct: [], currentRound: 1, lastRoundIncorrect: [] }
        };
        decks[deckId] = newDeck;
        await saveDataToDB('decks', newDeck);
        return deckId;
    }

    function editDeck(deckId) {
        const deck = decks[deckId];
        if (!deck) return;
        showView('editorView');
        document.getElementById('deckTitle').value = deck.name;
        document.getElementById('deckCategory').value = deck.category;
        document.getElementById('deckNotes').value = deck.notes || '';
        const container = document.getElementById('flashcardsContainer');
        container.innerHTML = '';
        editorCardCounter = 0;
        deck.cards.forEach(card => editorAddNewCard(card));
        currentDeckId = deckId;
    }

    function deleteDeck(deckId) {
        const deckName = decks[deckId]?.name || 'this deck';
        showConfirmModal(`Are you sure you want to permanently delete the deck "${deckName}"? This action cannot be undone.`, async () => {
            delete decks[deckId];
            await deleteDataFromDB('decks', deckId);
            if (currentViewingDeckId === deckId) {
                backToDashboard();
            } else {
                updateDashboard();
            }
            showToast(`Deck "${deckName}" deleted.`);
        });
    }

    function editorInitialize() {
        document.getElementById('deckTitle').value = '';
        populateCategoryDropdowns();
        document.getElementById('deckCategory').value = 'Other';
        document.getElementById('deckNotes').value = '';
        const container = document.getElementById('flashcardsContainer');
        container.innerHTML = '';
        editorCardCounter = 0;
        editorAddNewCard();
        editorAddNewCard();
        document.getElementById('deckTitle').focus();
        currentDeckId = null;
    }

    function isEditorClean() {
        const title = document.getElementById('deckTitle').value.trim();
        if (title) return false;
        const cardItems = document.querySelectorAll('#editorView .flashcard-item');
        for (const item of cardItems) {
            const q = item.querySelector('.question-input').value.trim();
            const a = item.querySelector('.solution-input').value.trim();
            const qImg = item.querySelector('.question-image-input').value.trim();
            const aImg = item.querySelector('.answer-image-input').value.trim();
            if (q || a || qImg || aImg) return false;
        }
        return true;
    }

    function editorAddNewCard(card = {}) {
    const { question = '', answer = '', questionImage = '', answerImage = '' } = card;
    editorCardCounter++;
    const container = document.getElementById('flashcardsContainer');

    const newRow = document.createElement('div');
    newRow.className = 'flashcard-editor-row';
    newRow.setAttribute('data-card-id', editorCardCounter); 

    const questionImagePreview = questionImage ? `<img src="${questionImage}">` : '';
    const answerImagePreview = answerImage ? `<img src="${answerImage}">` : '';

    newRow.innerHTML = `
        <div class="flashcard-item">
            <div class="flashcard-number">${document.querySelectorAll('.flashcard-editor-row').length + 1}.</div>
            
            <textarea class="question-input" placeholder="Question">${question}</textarea>
            <div class="image-controls">
                <button class="btn btn-secondary" style="padding: 5px 10px; font-size: 12px;" onclick="triggerImageUpload(this)">Upload Image</button>
            </div>
            <div class="question-image-preview image-preview">${questionImagePreview}</div>
            <input type="file" class="image-upload-input" accept="image/*" style="display:none;" onchange="handleImageFile(this)">
            <input type="hidden" class="question-image-input" value="${questionImage}">
            
            <textarea class="solution-input" placeholder="Answer" style="margin-top:20px;">${answer}</textarea>
            <div class="image-controls">
                <button class="btn btn-secondary" style="padding: 5px 10px; font-size: 12px;" onclick="triggerImageUpload(this)">Upload Image</button>
            </div>
            <div class="answer-image-preview image-preview">${answerImagePreview}</div>
            <input type="file" class="image-upload-input" accept="image/*" style="display:none;" onchange="handleImageFile(this)">
            <input type="hidden" class="answer-image-input" value="${answerImage}">
        </div>
        <button class="remove-card-btn" onclick="editorRemoveCard(${editorCardCounter})"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" style="width: 20px; height: 20px;"><path stroke-linecap="round" stroke-linejoin="round" d="m14.74 9-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 0 1-2.244 2.077H8.084a2.25 2.25 0 0 1-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 0 0-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 0 1 3.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 0 0-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 0 0-7.5 0" /></svg></button>
    `;
    
    container.appendChild(newRow);
    
    newRow.querySelectorAll('textarea').forEach(textarea => {
        textarea.addEventListener('paste', handleImagePaste);
    });

    if (!question && !answer) newRow.querySelector('.question-input').focus();
}
    
    function triggerImageUpload(button) {
        button.closest('.image-controls').nextElementSibling.nextElementSibling.click();
    }

    function handleImageFile(input) {
        const file = input.files[0];
        if (file && file.type.startsWith('image/')) {
            const reader = new FileReader();
            reader.onload = e => {
                const dataUrl = e.target.result;
                const preview = input.previousElementSibling;
                const dataInput = input.nextElementSibling;
                preview.innerHTML = `<img src="${dataUrl}">`;
                dataInput.value = dataUrl;
            };
            reader.readAsDataURL(file);
        }
    }

    function handleImagePaste(event) {
        const items = (event.clipboardData || window.clipboardData).items;
        for (let i = 0; i < items.length; i++) {
            if (items[i].type.indexOf('image') !== -1) {
                event.preventDefault();
                const blob = items[i].getAsFile();
                const reader = new FileReader();
                reader.onload = (e) => {
                    const dataUrl = e.target.result;
                    const textarea = event.target;
                    const preview = textarea.nextElementSibling.nextElementSibling;
                    const dataInput = preview.nextElementSibling.nextElementSibling;
                    preview.innerHTML = `<img src="${dataUrl}">`;
                    dataInput.value = dataUrl;
                };
                reader.readAsDataURL(blob);
                break;
            }
        }
    }
    
    function triggerNotesImageUpload(button) {
        button.nextElementSibling.click();
    }

    function handleNotesImageUpload(input) {
        const file = input.files[0];
        if (file && file.type.startsWith('image/')) {
            const reader = new FileReader();
            reader.onload = e => {
                const dataUrl = e.target.result;
                const notesTextarea = document.getElementById('deckNotes');
                const imgTag = `<img src="${dataUrl}" style="max-width: 100%; border-radius: 8px;">`;
                notesTextarea.value += (notesTextarea.value ? '\n\n' : '') + imgTag;
            };
            reader.readAsDataURL(file);
        }
    }

    function editorRemoveCard(cardId) {
        const cardRow = document.querySelector(`#editorView [data-card-id="${cardId}"]`);
        if (cardRow) {
            cardRow.remove();
            editorRenumberCards();
        }
    }

    function editorRenumberCards() {
        const cardRows = document.querySelectorAll('#editorView .flashcard-editor-row');
        cardRows.forEach((row, index) => {
            const cardItem = row.querySelector('.flashcard-item');
            if (cardItem) {
                cardItem.querySelector('.flashcard-number').textContent = `${index + 1}.`;
            }
        });
    }

    async function editorSaveDeck() {
        const saveBtn = document.querySelector('.editor-container .actions-section .btn-success');
        const originalText = saveBtn.innerHTML;
        saveBtn.innerHTML = '<span class="spinner" style="border-width:2px; width:16px; height:16px;"></span> Saving...';
        saveBtn.disabled = true;
        const name = document.getElementById('deckTitle').value.trim();
        const category = document.getElementById('deckCategory').value;
        const notes = document.getElementById('deckNotes').value.trim();
        if (!name) { showToast('Please enter a title for your deck.', 'error'); return; }
        
        const cards = Array.from(document.querySelectorAll('#editorView .flashcard-item')).map(el => ({
            id: Date.now() + Math.random(),
            question: el.querySelector('.question-input').value.trim(),
            answer: el.querySelector('.solution-input').value.trim(),
            questionImage: el.querySelector('.question-image-input').value.trim(),
            answerImage: el.querySelector('.answer-image-input').value.trim(),
            isNew: true
        })).filter(c => c.question || c.questionImage);

        if (cards.length === 0) { showToast('Please add at least one complete flashcard.', 'error'); return; }
        
        if (currentDeckId) {
            const deck = decks[currentDeckId];
            deck.name = name;
            deck.category = category;
            deck.cards = cards;
            deck.notes = notes;
            deck.learnState = {
                buckets: [[...cards], ...Array.from({length: deck.settings.maxBuckets - 1}, () => [])],
                currentRound: 1, maxBuckets: deck.settings.maxBuckets
            };
            deck.reviewState = { stillLearning: [...cards], correct: [], currentRound: 1, lastRoundIncorrect: [] };
            await saveDataToDB('decks', deck);
        } else {
            await createNewDeck(name, category, cards, notes);
        }
        document.getElementById('deckTitle').value = '';
        document.getElementById('flashcardsContainer').innerHTML = '';
        backToDashboard();
    }
    
    async function checkName() {
        if (!globalSettings.username) {
            document.getElementById('nameModal').classList.add('show');
        } else {
            document.getElementById('welcomeMessage').textContent = `Welcome back, ${globalSettings.username}!`;
        }
    }

    async function saveName(e) {
        e.preventDefault();
        const nameInput = document.getElementById('nameInput');
        const username = nameInput.value.trim();
        document.getElementById('newCategoryInput').focus();
        if (username) {
            globalSettings.username = username;
            await saveDataToDB('appData', { key: 'userSettings', ...globalSettings });
            document.getElementById('welcomeMessage').textContent = `Welcome, ${username}!`;
            closeNameModal();
        }
    }
    
    async function saveUsername() {
        const username = document.getElementById('usernameInput').value.trim();
        if (username) {
            globalSettings.username = username;
            await saveDataToDB('appData', { key: 'userSettings', ...globalSettings });
            document.getElementById('welcomeMessage').textContent = `Welcome back, ${username}!`;
            showToast('Name saved!');
        } else showToast('Name cannot be empty.', 'error');
    }
    
    async function saveStudySettings() {
        globalSettings.enableInStudyEditing = document.getElementById('enableInStudyEditing').checked;
        globalSettings.newCardsPerDay = parseInt(document.getElementById('newCardsPerDay').value) || 20;
        globalSettings.spacedLearningFeedbackStyle = document.querySelector('input[name="spacedFeedbackStyle"]:checked').value;
        await saveDataToDB('appData', { key: 'userSettings', ...globalSettings });
        showToast('Settings saved!');
    }

    function closeNameModal() { document.getElementById('nameModal').classList.remove('show'); }
    
    async function toggleDarkMode() {
        document.body.classList.toggle('dark-mode');
        globalSettings.darkMode = document.body.classList.contains('dark-mode');
        await saveDataToDB('appData', { key: 'userSettings', ...globalSettings });
        }
        
        async function clearAllDecks() {
            showConfirmModal('Are you sure you want to delete all decks? This is irreversible.', async () => {
                decks = {};
                await clearStoreInDB('decks');
                updateDashboard();
                backToDashboard();
            });
        }

        function populateCategoryDropdowns() {
            const dropdowns = [document.getElementById('deckCategory')];
            dropdowns.forEach(dropdown => {
                const currentValue = dropdown.value;
                dropdown.innerHTML = '';
                categories.forEach(cat => dropdown.innerHTML += `<option value="${cat}">${cat}</option>`);
                dropdown.innerHTML += `<option value="add_new_category" style="font-style: italic;">+ Add New Category...</option>`;
                dropdown.value = currentValue;
            });
        }
        
        function handleCategoryChange(event) {
            if (event.target.value === 'add_new_category') openAddCategoryModal();
        }

        function openAddCategoryModal() { 
            document.getElementById('addCategoryModal').classList.add('show'); 
            document.getElementById('newCategoryInput').focus();
        }
        function closeAddCategoryModal() { 
            populateCategoryDropdowns();
            document.getElementById('addCategoryModal').classList.remove('show'); 
        }

        async function saveNewCategory() {
            const newCatInput = document.getElementById('newCategoryInput');
            let newCat = newCatInput.value.trim();
            if (newCat) {
                newCat = newCat.charAt(0).toUpperCase() + newCat.slice(1);
                if (!categories.includes(newCat)) {
                    categories.push(newCat);
                    await saveDataToDB('appData', { key: 'categories', data: categories });
                    populateCategoryDropdowns();
                    document.getElementById('deckCategory').value = newCat;
                }
                newCatInput.value = '';
                closeAddCategoryModal();
            } else showToast('Category name cannot be empty.', 'error');
        }
        
        function configureStudy(mode, deckId) {
            currentDeckId = deckId || currentViewingDeckId;
            if (!currentDeckId) return;

            if (mode === 'learn') {
                startLearnMode(currentDeckId);
            } else if (mode === 'review') {
                startReviewMode(currentDeckId);
            }
        }

        async function startLearnMode(deckId) {
            document.getElementById('progressView').classList.add('hidden');
            document.getElementById('cardView').classList.add('hidden');
            document.getElementById('completeView').classList.add('hidden');
            currentMode = 'learn';
            currentDeckId = deckId;
            const deck = decks[deckId];
            deck.settings = {...DEFAULT_DECK_SETTINGS, ...(deck.settings || {})};
            
            if (deck.learnState.maxBuckets !== deck.settings.maxBuckets) {
                const allCards = deck.learnState.buckets.flat();
                deck.learnState.buckets = [[...allCards]];
                while (deck.learnState.buckets.length < deck.settings.maxBuckets) deck.learnState.buckets.push([]);
                deck.learnState.maxBuckets = deck.settings.maxBuckets;
                deck.learnState.currentRound = 1;
                await saveDataToDB('decks', deck);
            }
            studyState.settings = deck.settings;
            studyState.buckets = JSON.parse(JSON.stringify(deck.learnState.buckets || []));
            studyState.currentRound = deck.learnState.currentRound || 1;
            studyState.startTime = new Date();
            showView('studyMode');
            document.getElementById('studyTitle').textContent = 'Learning Mode';
            document.getElementById('studySubtitle').textContent = deck.name;
            showProgress();
        }

        async function startReviewMode(deckId) {
            document.getElementById('progressView').classList.add('hidden');
            document.getElementById('cardView').classList.add('hidden');
            document.getElementById('completeView').classList.add('hidden');
            currentMode = 'review';
            currentDeckId = deckId;
            const deck = decks[deckId];
            deck.settings = {...DEFAULT_DECK_SETTINGS, ...(deck.settings || {})};
            await saveDataToDB('decks', deck);

            studyState.settings = deck.settings;
            studyState.stillLearning = [...(deck.reviewState?.stillLearning || deck.cards)];
            studyState.correct = [...(deck.reviewState?.correct || [])];
            studyState.currentRound = deck.reviewState?.currentRound || 1;
            studyState.lastRoundIncorrect = [...(deck.reviewState?.lastRoundIncorrect || [])];
            studyState.startTime = new Date();
            showView('studyMode');
            document.getElementById('studyTitle').textContent = 'Review Mode';
            document.getElementById('studySubtitle').textContent = deck.name;
            if (studyState.stillLearning.length === 0) showComplete();
            else showProgress();
        }


        async function saveStudyProgress() {
            if (!currentDeckId) return;
            const deck = decks[currentDeckId];
            if (!deck) return;
            if (currentMode === 'learn') {
                deck.learnState = { buckets: studyState.buckets, currentRound: studyState.currentRound, maxBuckets: studyState.settings.maxBuckets };
            } else if (currentMode === 'review') {
                deck.reviewState = { stillLearning: studyState.stillLearning, correct: studyState.correct, currentRound: studyState.currentRound, lastRoundIncorrect: studyState.lastRoundIncorrect };
            }
            await saveDataToDB('decks', deck);
            updateDashboard();
        }
        
        function showProgress() {
            const cardView = document.getElementById('cardView');
            const progressView = document.getElementById('progressView');
            transitionSubView(cardView, progressView);
            document.getElementById('switchStudyModeBtn').classList.add('hidden');

            const continueBtn = document.getElementById('continueBtn');
            if(studyState.currentRound === 1) {
                continueBtn.textContent = 'Start Round';
                continueBtn.classList.add('btn-prominent');
            } else {
                continueBtn.textContent = 'Continue Round';
                continueBtn.classList.remove('btn-prominent');
            }
            if(currentMode === 'learn') updateLearnProgress();
            else if (currentMode === 'review') updateReviewProgress();
        }
        
        function getBucketName(index, totalBuckets) {
            const names = {
                3: ["New", "Reviewing", "Mastered"],
                4: ["New", "Learning", "Reviewing", "Mastered"],
                5: ["New", "Learning", "Reviewing", "Mastered", "Legendary"]
            };
            return (names[totalBuckets] && names[totalBuckets][index]) || `Bucket ${index + 1}`;
        }

        function updateLearnProgress() {
            const deck = decks[currentDeckId];
            const maxBuckets = studyState.settings.maxBuckets;
            const mastered = studyState.buckets[maxBuckets - 1]?.length || 0;
            const total = deck.cards.length;
            
            const notesContainer = document.getElementById('deckNotesDisplay');
            if (deck.notes && studyState.currentRound === 1) {
                notesContainer.innerHTML = `<h3>Notes:</h3><div>${deck.notes}</div>`;
                notesContainer.classList.remove('hidden');
            } else {
                notesContainer.classList.add('hidden');
            }

            if (mastered === total && total > 0) { 
                document.getElementById('progressTitle').textContent = 'Deck Mastered!';
                const continueBtn = document.getElementById('continueBtn');
                continueBtn.textContent = 'Finish';
                continueBtn.classList.remove('btn-prominent')
                continueBtn.classList.add('btn-success');
                continueBtn.onclick = showComplete;
                return;
             }
            document.getElementById('progressTitle').textContent = 'Learning Progress';
            document.getElementById('roundInfo').textContent = `Round ${studyState.currentRound}`;
            document.getElementById('bucketsContainer').innerHTML = Array.from({length: maxBuckets}, (_, i) => `<div class="bucket"><div class="bucket-number">${getBucketName(i, maxBuckets)}</div><div class="bucket-count">${studyState.buckets[i]?.length || 0}</div></div>`).join('');
            
            let currentProgressPoints = 0;
            studyState.buckets.forEach((bucket, i) => {
                currentProgressPoints += bucket.length * i;
            });
            const maxProgressPoints = total > 0 ? total * (maxBuckets - 1) : 0;
            const progress = maxProgressPoints > 0 ? (currentProgressPoints / maxProgressPoints) * 100 : 0;

            document.getElementById('progressBarFill').style.width = `${progress}%`;
            document.getElementById('statsContainer').innerHTML = `<div class="stat"><div class="stat-value">${mastered}</div><div class="stat-label">Mastered</div></div><div class="stat"><div class="stat-value">${total - mastered}</div><div class="stat-label">Remaining</div></div>`;
        }

        function updateReviewProgress() {
            const deck = decks[currentDeckId];
            const mastered = studyState.correct.length, remaining = studyState.stillLearning.length, total = deck.cards.length;

            const notesContainer = document.getElementById('deckNotesDisplay');
            if (deck.notes && studyState.currentRound === 1) {
                notesContainer.innerHTML = `<h3>Notes for this deck:</h3><div>${deck.notes}</div>`;
                notesContainer.classList.remove('hidden');
            } else {
                notesContainer.classList.add('hidden');
            }

            if (remaining === 0 && total > 0) {
                document.getElementById('progressTitle').textContent = 'Deck Mastered!';
                const continueBtn = document.getElementById('continueBtn');
                continueBtn.textContent = 'Finish';
                continueBtn.classList.remove('btn-prominent');
                continueBtn.classList.add('btn-success');
                continueBtn.onclick = showComplete;
                return;
            }
            document.getElementById('progressTitle').textContent = 'Review Progress';
            document.getElementById('roundInfo').textContent = `Round ${studyState.currentRound}`;
            document.getElementById('bucketsContainer').innerHTML = `<div class="bucket"><div class="bucket-number">Still Learning</div><div class="bucket-count">${remaining}</div></div><div class="bucket"><div class="bucket-number">Correct</div><div class="bucket-count">${mastered}</div></div>`;
            const progress = total > 0 ? (mastered / total) * 100 : 0;
            document.getElementById('progressBarFill').style.width = `${progress}%`;
            document.getElementById('statsContainer').innerHTML = `<div class="stat"><div class='stat-value'>${mastered}</div><div class='stat-label'>Total Mastered</div></div><div class='stat'><div class='stat-value'>${remaining}</div><div class='stat-label'>Remaining</div></div>`;
        }

        function continueStudy() {
            if (currentMode === 'learn') {
                const cardsPerRound = studyState.settings.cardsPerRound === 'all' ? 999 : parseInt(studyState.settings.cardsPerRound);
                const availableCards = studyState.buckets.slice(0, -1).flat();
                
                const newCards = availableCards.filter(c => c.sm2Data.repetition === 0);
                const reviewCards = availableCards.filter(c => c.sm2Data.repetition > 0)
                                                 .sort((a, b) => new Date(a.sm2Data.dueDate) - new Date(b.sm2Data.dueDate));
                
                const newCardsCount = Math.min(newCards.length, Math.floor(cardsPerRound / 2));
                const reviewCardsCount = cardsPerRound - newCardsCount;

                const roundNewCards = shuffleArray(newCards).slice(0, newCardsCount);
                const roundReviewCards = reviewCards.slice(0, reviewCardsCount);
                
                studyState.roundCards = shuffleArray([...roundNewCards, ...roundReviewCards]);

            } else if (currentMode === 'review') {
                let prioritized = [];
                let others = [];

                if (studyState.lastRoundIncorrect && studyState.lastRoundIncorrect.length > 0) {
                    const incorrectIds = new Set(studyState.lastRoundIncorrect.map(c => c.id));
                    studyState.stillLearning.forEach(card => {
                        if (incorrectIds.has(card.id)) prioritized.push(card);
                        else others.push(card);
                    });
                } else {
                    others = [...studyState.stillLearning];
                }
                studyState.lastRoundIncorrect = []; 

                let sortedCards;
                if (studyState.settings.reviewOrder === 'alphabetical') {
                    prioritized.sort((a, b) => a.question.localeCompare(b.question));
                    others.sort((a, b) => a.question.localeCompare(b.question));
                    sortedCards = prioritized.concat(others);
                } else { 
                    sortedCards = shuffleArray(prioritized).concat(shuffleArray(others));
                }
                studyState.roundCards = sortedCards;
            } 

            studyState.currentCardIndex = 0;
            if(studyState.roundCards.length > 0) {
                transitionSubView(document.getElementById('progressView'), document.getElementById('cardView'));
                showNextCard();
            }
            else { showProgress(); showToast("No cards available to study in this round."); }
        }

        function showNextCard() {
            if (studyState.currentCardIndex >= studyState.roundCards.length) {
                studyState.currentRound++;
                saveStudyProgress();
                showProgress();
                return;
            }
            window.scrollTo(0, 0);
            const card = studyState.roundCards[studyState.currentCardIndex];
            const flashcardElem = document.querySelector('#cardView .flashcard');
            flashcardElem.classList.remove('is-flipped');
            
            document.getElementById('cardRoundInfo').textContent = `Round ${studyState.currentRound} - Card ${studyState.currentCardIndex + 1} of ${studyState.roundCards.length}`;
            
            document.getElementById('cardQuestion').innerHTML = card.question;
            const questionContent = document.getElementById('cardQuestionContent');
            const existingQImg = questionContent.querySelector('.card-image');
            if(existingQImg) existingQImg.remove();
            if(card.questionImage) questionContent.innerHTML += `<img src="${card.questionImage}" class="card-image" style="margin: 15px auto 0 auto; display: block;">`;

            document.getElementById('cardAnswer').innerHTML = card.answer;
            const answerContent = document.getElementById('cardAnswerContent');
             const existingAImg = answerContent.querySelector('#cardAnswer .card-image');
            if(existingAImg) existingAImg.remove();
            if(card.answerImage) document.getElementById('cardAnswer').innerHTML += `<img src="${card.answerImage}" class="card-image" style="margin: 15px auto 0 auto; display: block;">`;
            
            document.getElementById('cardAnswerContent').classList.add('hidden');
            document.getElementById('simpleAnswerButtons').classList.remove('hidden');
            document.getElementById('advancedAnswerButtons').classList.add('hidden');
            document.getElementById('correctBtn').classList.add('hidden');
            document.getElementById('incorrectBtn').classList.add('hidden');
            document.getElementById('showQuestionBtn').classList.add('hidden');
            document.getElementById('userAnswerDisplay').classList.add('hidden');
            
            const writeInput = document.getElementById('writeAnswerInput');
            writeInput.classList.remove('correct', 'incorrect');
            const accentToggleBtn = document.getElementById('accentToggleBtn');
            const switchStudyModeBtn = document.getElementById('switchStudyModeBtn');
            const editStudyCardBtn = document.getElementById('editStudyCardBtn');

            const isWriteMode = (currentMode === 'learn' && studyState.settings.learnMode === 'write') || (currentMode === 'review' && studyState.settings.reviewMode === 'write');

            if (isWriteMode) {
                startInteractionLog(card.id);

                document.getElementById('showAnswerBtn').classList.add('hidden');
                document.getElementById('checkAnswerBtn').classList.remove('hidden');
                writeInput.value = '';
                writeInput.classList.remove('hidden');
                writeInput.disabled = false;
                setTimeout(() => writeInput.focus(), 100);
                accentToggleBtn.classList.remove('hidden');
                updateAccentButtonsVisibility();
            } else {
                document.getElementById('showAnswerBtn').classList.remove('hidden');
                document.getElementById('checkAnswerBtn').classList.add('hidden');
                writeInput.classList.add('hidden');
                accentToggleBtn.classList.add('hidden');
                document.getElementById('accentButtonsContainer').classList.add('hidden');
            }

            switchStudyModeBtn.classList.toggle('hidden', currentMode !== 'learn');
            editStudyCardBtn.classList.toggle('hidden', !globalSettings.enableInStudyEditing);

            const bucketInfo = document.getElementById('cardBucketInfo');
            if (currentMode === 'learn') {
                let bucketName = 'Unknown';
                for (let i = 0; i < studyState.buckets.length; i++) {
                    if (studyState.buckets[i].some(c => c.id === card.id)) {
                        bucketName = getBucketName(i, studyState.settings.maxBuckets);
                        break;
                    }
                }
                const bucketInfo = document.getElementById('cardBucketInfo');
                bucketInfo.textContent = bucketName;
                bucketInfo.style.display = 'block';
            } else {
                document.getElementById('cardBucketInfo').style.display = 'none';
            }
        }

        function showAnswer() {
            document.querySelector('#cardView .flashcard').classList.add('is-flipped');
            document.getElementById('cardAnswerContent').classList.remove('hidden');
            document.getElementById('showAnswerBtn').classList.add('hidden');
            document.getElementById('checkAnswerBtn').classList.add('hidden');
            
            const isForgivingMode = studyState.settings.forgivingAutomarking && 
                                    (studyState.settings.learnMode === 'write' || studyState.settings.reviewMode === 'write');

            if (!isForgivingMode) {
                    document.getElementById('correctBtn').classList.remove('hidden');
                    document.getElementById('incorrectBtn').classList.remove('hidden');
            }
            
            document.getElementById('showQuestionBtn').classList.remove('hidden');
        }
        
        function showQuestion() {
            document.querySelector('#cardView .flashcard').classList.remove('is-flipped');
            document.getElementById('showQuestionBtn').classList.add('hidden');
            document.getElementById('showAnswerBtn').classList.remove('hidden');
            document.getElementById('correctBtn').classList.add('hidden');
            document.getElementById('incorrectBtn').classList.add('hidden');
            document.getElementById('advancedAnswerButtons').classList.add('hidden');
        }

        function autoCheckAnswer() {
            const userInput = document.getElementById('writeAnswerInput');
            const card = studyState.roundCards[studyState.currentCardIndex];
            if (!card || userInput.value.trim() === '') return;

            const submissionTime = performance.now();
            
            const recallLatency = currentInteractionLog.firstKeyPressTime 
                ? Math.round(currentInteractionLog.firstKeyPressTime - currentInteractionLog.questionLoadTime) 
                : null; 
            let answerFluency = 0;
            if (currentInteractionLog.firstKeyPressTime) {
                const typingDuration = submissionTime - currentInteractionLog.firstKeyPressTime;
                if (typingDuration > 0) {
                    const charCount = userInput.value.trim().length;
                    answerFluency = parseFloat((charCount / (charCount / (typingDuration / 1000))).toFixed(2));
                }
            }
            
            let isCorrect;
            const userAnswer = userInput.value.trim();
            const correctAnswer = card.answer.trim();

            const isForgivingMode = studyState.settings.forgivingAutomarking;

            if (isForgivingMode) {
                const distance = levenshteinDistance(userAnswer, correctAnswer);
                const tolerance = Math.max(1, Math.floor(correctAnswer.length * 0.1));
                isCorrect = distance <= tolerance;
            } else {
                let processedUserAnswer = userAnswer;
                let processedCorrectAnswer = correctAnswer;
                if (!studyState.settings.caseSensitive) {
                    processedUserAnswer = processedUserAnswer.toLowerCase();
                    processedCorrectAnswer = processedCorrectAnswer.toLowerCase();
                }
                if (!studyState.settings.punctuation) {
                    const punc = /[.,/#!$%^&*;:{}=\-_`~()]/g;
                    processedUserAnswer = processedUserAnswer.replace(punc, "");
                    processedCorrectAnswer = processedCorrectAnswer.replace(punc, "");
                }
                isCorrect = processedUserAnswer === processedCorrectAnswer;
            }

            if (!studyState.isRetypingIncorrect) {
                 const finalLog = {
                    cardID: currentInteractionLog.cardID,
                    wasCorrect: isCorrect,
                    recallLatency: recallLatency,
                    answerFluency: answerFluency,
                    totalCorrections: currentInteractionLog.backspaceCount + currentInteractionLog.deleteCount,
                    attemptCount: currentInteractionLog.attemptCount,
                    userAnswer: userAnswer
                };
                logInteraction(finalLog);
            }
            if (studyState.isRetypingIncorrect) {
                if (isCorrect) {
                    studyState.isRetypingIncorrect = false;
                    
                    userInput.classList.add('correct');
                    userInput.disabled = true;

                    setTimeout(() => {
                        moveCard(card, false); 
                    }, 400); 
                    
                    return; 
                } else {
                    showToast("That's not quite right. Please type the answer exactly as shown.", "error");
                    userInput.value = ''; 
                    userInput.focus();
                    return; 
                }
            }

            userInput.classList.toggle('correct', isCorrect);
            userInput.classList.toggle('incorrect', !isCorrect);
            userInput.disabled = true;

            showAnswer();

            if (isForgivingMode) {
                setTimeout(() => {
                    if (isCorrect) {
                        markCorrect(true);
                    } else {
                        markIncorrect(true);
                    }
                }, 1800);
            }
        }

        async function moveCard(card, correct) {
            const cardInDeck = decks[currentDeckId].cards.find(c => c.id === card.id);
            if(cardInDeck) cardInDeck.isNew = false;
            
            const sm2 = new SM2Algorithm();
            const quality = correct ? 4 : 1; 
            cardInDeck.sm2Data = sm2.calculateNextReview(cardInDeck)(quality);

            if (currentMode === 'learn') {
                for (let i = 0; i < studyState.settings.maxBuckets; i++) {
                    const index = studyState.buckets[i]?.findIndex(c => c.id === card.id);
                    if (index > -1) {
                        studyState.buckets[i].splice(index, 1);
                        let targetBucket;
                        if (correct) {
                            targetBucket = Math.min(i + 1, studyState.settings.maxBuckets - 1);
                        } else {
                            if (studyState.settings.maxBuckets > 3 && i > 0) {
                                targetBucket = 1; 
                            } else {
                                targetBucket = 0;
                            }
                        }
                        studyState.buckets[targetBucket].push(card);
                        break;
                    }
                }
            } else if (currentMode === 'review') {
                if (correct) {
                    const index = studyState.stillLearning.findIndex(c => c.id === card.id);
                    if (index > -1) {
                        studyState.stillLearning.splice(index, 1);
                        studyState.correct.push(card);
                    }
                } else {
                     if (!studyState.lastRoundIncorrect.some(c => c.id === card.id)) {
                        studyState.lastRoundIncorrect.push(card);
                    }
                }
            }
            await saveDataToDB('decks', decks[currentDeckId]);
            studyState.currentCardIndex++;
            showNextCard();
        }

        function markCorrect(isAutomated = false) {
            if (!isAutomated && !isActionAllowed()) return;

            const btn = document.getElementById('correctBtn');
            btn.classList.add('feedback-correct');
            setTimeout(() => {
                btn.classList.remove('feedback-correct');
                if (currentMode === 'spaced') {
                    markSpaced(4);
                } else {
                    moveCard(studyState.roundCards[studyState.currentCardIndex], true);
                }
            }, 200);
        }
        function markIncorrect(isAutomated = false) {
            if (!isAutomated && !isActionAllowed() && document.getElementById('writeAnswerInput').value.trim() !== '') return;

            const isWriteMode = (currentMode === 'learn' && studyState.settings.learnMode === 'write') || (currentMode === 'review' && studyState.settings.reviewMode === 'write');

            if (!isAutomated && isWriteMode && studyState.settings.retypeIncorrect) {
                studyState.isRetypingIncorrect = true;
                const writeInput = document.getElementById('writeAnswerInput');
                writeInput.value = '';
                writeInput.disabled = false;
                writeInput.focus();
                document.getElementById('correctBtn').classList.add('hidden');
                document.getElementById('incorrectBtn').classList.add('hidden');
                document.getElementById('checkAnswerBtn').classList.remove('hidden');
                showToast("Type the correct answer to continue.", "error");
                return;
            }

            const btn = document.getElementById('incorrectBtn');
            btn.classList.add('feedback-incorrect');
            setTimeout(() => {
                btn.classList.remove('feedback-incorrect');
                if (currentMode === 'spaced') {
                    markSpaced(1);
                } else {
                    moveCard(studyState.roundCards[studyState.currentCardIndex], false);
                }
            }, 200);
        }
        
        function populateAccentButtons() {
            const accents = ['à', 'â', 'é', 'è', 'ê', 'ë', 'î', 'ï', 'ô', 'ù', 'û', 'ü', 'ç', 'ñ', 'ß', 'ä', 'ö'];
            const container = document.getElementById('accentButtonsContainer');
            container.innerHTML = accents.map(char => `<button onclick="insertAccent('${char}', 'writeAnswerInput')">${char}</button>`).join('');
        }

        function insertAccent(char, targetId) {
            const textarea = document.getElementById(targetId);
            if (!textarea) return; 
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            textarea.value = textarea.value.substring(0, start) + char + textarea.value.substring(end);
            textarea.selectionStart = textarea.selectionEnd = start + 1;
            textarea.focus();
        }

        async function toggleAccentButtons() {
            globalSettings.showAccents = !globalSettings.showAccents;
            await saveDataToDB('appData', { key: 'userSettings', ...globalSettings });
            updateAccentButtonsVisibility();
        }

        function updateAccentButtonsVisibility() {
            const container = document.getElementById('accentButtonsContainer');
            if (globalSettings.showAccents) {
                populateAccentButtons();
                container.classList.remove('hidden');
            } else {
                container.classList.add('hidden');
            }
        }

        function populateTestAccentButtons() {
            const accents = ['à', 'â', 'é', 'è', 'ê', 'ë', 'î', 'ï', 'ô', 'ù', 'û', 'ü', 'ç', 'ñ', 'ß', 'ä', 'ö'];
            const container = document.getElementById('testAccentButtonsContainer');
            container.innerHTML = accents.map(char => `<button onclick="insertAccent('${char}', 'testAnswerInput')">${char}</button>`).join('');
        }

        async function toggleTestAccentButtons() {
            globalSettings.showAccents = !globalSettings.showAccents;
            await saveDataToDB('appData', { key: 'userSettings', ...globalSettings });
            updateTestAccentButtonsVisibility();
        }

        function updateTestAccentButtonsVisibility() {
            const container = document.getElementById('testAccentButtonsContainer');
            if (globalSettings.showAccents) {
                populateTestAccentButtons();
                container.classList.remove('hidden');
            } else {
                container.classList.add('hidden');
            }
        }

        function showComplete() {
            const currentSubView = document.querySelector('#studyMode .sub-view:not(.hidden)');
            const completeView = document.getElementById('completeView');
            transitionSubView(currentSubView, completeView);
            document.getElementById('finalStats').innerHTML = `<div class="stat"><div class="stat-value">${studyState.currentRound}</div><div class="stat-label">Total Rounds</div></div><div class="stat"><div class="stat-value">${decks[currentDeckId].cards.length}</div><div class="stat-label">Cards Mastered</div></div>`;
        }

        async function endSession() {
            if (studyState.startTime) {
                const duration = Math.round((new Date() - studyState.startTime) / 1000);
                analyticsData.totalStudyTime += duration;
                analyticsData.sessions.unshift({
                    date: new Date().toISOString(),
                    deckName: decks[currentDeckId].name,
                    mode: currentMode,
                    duration: duration
                });
                if (analyticsData.sessions.length > 50) analyticsData.sessions.pop();
                await saveDataToDB('appData', { key: 'analytics', ...analyticsData });
            }
            saveStudyProgress();
            backToDashboard();
        }

        function resetProgress() {
            showConfirmModal('Are you sure you want to reset your progress for this deck?', () => restartStudy());
        }
        
        async function restartStudy() {
            const deck = decks[currentDeckId];
            if (currentMode === 'learn') {
                deck.learnState.buckets = [[...deck.cards]];
                while(deck.learnState.buckets.length < deck.settings.maxBuckets) deck.learnState.buckets.push([]);
                deck.learnState.currentRound = 1;
                await saveDataToDB('decks', deck);
                startLearnMode(currentDeckId);
            } else if (currentMode === 'review') {
                deck.reviewState = { stillLearning: [...deck.cards], correct: [], currentRound: 1, lastRoundIncorrect: [] };
                await saveDataToDB('decks', deck);
                startReviewMode(currentDeckId);
            } else if (currentMode === 'spaced') {
                const sm2 = new SM2Algorithm();
                deck.cards.forEach(card => card.sm2Data = sm2.calculateNextReview({})(3));
                await saveDataToDB('decks', deck);
                configureStudy('spaced', currentDeckId);
            }
        }
        
        function isActionAllowed() {
            if (activeView !== 'studyMode' || document.getElementById('cardView').classList.contains('hidden')) {
                return false;
            }
            const correctBtnHidden = document.getElementById('correctBtn').classList.contains('hidden');
            const advancedBtnsHidden = document.getElementById('advancedAnswerButtons').classList.contains('hidden');
            return !correctBtnHidden || !advancedBtnsHidden;
        }

        function setupKeyboardControls() {
            document.addEventListener('keydown', (e) => {
                if (document.querySelector('.modal.show')) return; 

                if (activeView === 'studyMode' && !document.getElementById('progressView').classList.contains('hidden')) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        document.getElementById('continueBtn').click(); 
                    }
                    return;
                }

                if (activeView !== 'studyMode' || document.getElementById('cardView').classList.contains('hidden')) return;

                const advancedButtons = document.getElementById('advancedAnswerButtons');
                const simpleCorrectBtn = document.getElementById('correctBtn');
                const showAnswerBtn = document.getElementById('showAnswerBtn');

                if (!advancedButtons.classList.contains('hidden')) {
                    e.preventDefault(); 
                    switch (e.key) {
                        case '1': markSpaced(1); break; 
                        case '2': markSpaced(2); break; 
                        case '3': markSpaced(3); break; 
                        case '4': markSpaced(4); break; 
                    }
                    return; 
                }

                if (!simpleCorrectBtn.classList.contains('hidden')) {
                    e.preventDefault();
                    if (e.key === 'ArrowLeft' || e.key === '1') {
                        markIncorrect();
                    } else if (e.key === 'ArrowRight' || e.key === '2') {
                        markCorrect();
                    }
                    return; 
                }

                if (!showAnswerBtn.classList.contains('hidden')) {
                    if (document.activeElement.tagName === 'TEXTAREA') return; 
                    if (e.key === ' ' || e.key === 'Enter') {
                        e.preventDefault();
                        showAnswer();
                    }
                }
            });
        }

    async function toggleStudyMode() {
        if (currentMode !== 'learn') return;
        const deck = decks[currentDeckId];
        if (!deck) return;

        studyState.settings.learnMode = studyState.settings.learnMode === 'write' ? 'flashcard' : 'write';
        deck.settings.learnMode = studyState.settings.learnMode;
        
        await saveDataToDB('decks', deck);
        showToast(`Switched to ${studyState.settings.learnMode} mode.`);
        
        showNextCard();
    }
        
    function shuffleArray(array) {
        const newArray = [...array];
        for (let i = newArray.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [newArray[i], newArray[j]] = [newArray[j], newArray[i]]; }
            return newArray;
        }

        function openDeckSettingsModal(deckId) {
            const deck = decks[deckId];
            if (!deck) return;
            const settings = {...DEFAULT_DECK_SETTINGS, ...(deck.settings || {})};
            document.getElementById('caseSensitiveToggle').checked = settings.caseSensitive;
            document.getElementById('punctuationToggle').checked = settings.punctuation;
            document.getElementById('retypeIncorrectToggle').checked = settings.retypeIncorrect;
            document.getElementById('reviewOrder').value = settings.reviewOrder;
            document.getElementById('bucketCount').value = settings.maxBuckets;
            document.querySelector(`input[name="deckSettingsStudyMode"][value="${settings.learnMode}"]`).checked = true;
            document.getElementById('deckSettingsCardsPerRound').value = settings.cardsPerRound;
            document.getElementById('deckSettingsModal').classList.add('show');
            document.getElementById('forgivingAutomarkingToggle').checked = settings.forgivingAutomarking;
            setupRadioCardSelection('deckSettingsStudyMode');
        }

        function closeDeckSettingsModal() { document.getElementById('deckSettingsModal').classList.remove('show'); }

        async function saveDeckSettings() {
            const deck = decks[currentViewingDeckId];
            if (!deck) return;
            const newBucketCount = parseInt(document.getElementById('bucketCount').value);

            if (deck.settings.maxBuckets !== newBucketCount) {
                showConfirmModal("Changing the number of buckets will reset this deck's learning progress. Are you sure?", async () => {
                    deck.settings.maxBuckets = newBucketCount;
                    deck.learnState = {
                        buckets: [[...deck.cards]],
                        currentRound: 1, 
                        maxBuckets: newBucketCount
                    };
                    while(deck.learnState.buckets.length < newBucketCount) deck.learnState.buckets.push([]);
                    await completeSaveDeckSettings(deck);
                });
            } else {
                 await completeSaveDeckSettings(deck);
            }
        }
        
        async function completeSaveDeckSettings(deck) {
            deck.settings.caseSensitive = document.getElementById('caseSensitiveToggle').checked;
            deck.settings.punctuation = document.getElementById('punctuationToggle').checked;
            deck.settings.retypeIncorrect = document.getElementById('retypeIncorrectToggle').checked;
            deck.settings.reviewOrder = document.getElementById('reviewOrder').value;
            deck.settings.learnMode = document.querySelector('input[name="deckSettingsStudyMode"]:checked').value;
            deck.settings.cardsPerRound = document.getElementById('deckSettingsCardsPerRound').value;
            deck.settings.forgivingAutomarking = document.getElementById('forgivingAutomarkingToggle').checked;
            await saveDataToDB('decks', deck);
            updateDashboard();
            closeDeckSettingsModal();
            showToast('Settings saved!');
        }

        function showImportModal() { document.getElementById('importModal').classList.add('show'); }
        function closeImportModal() { document.getElementById('importModal').classList.remove('show'); }
        function switchImportTab(tabName) {
            document.getElementById('importContentPaste').classList.toggle('hidden', tabName !== 'paste');
            document.getElementById('importContentFile').classList.toggle('hidden', tabName !== 'file');
            document.getElementById('importTabPaste').classList.toggle('active', tabName === 'paste');
            document.getElementById('importTabFile').classList.toggle('active', tabName === 'file');
        }
        function importData() {
            const name = document.getElementById('importDeckName').value.trim();
            if(!name) { showToast('Please provide a name for the new deck.', 'error'); return; }

            const fileInput = document.getElementById('importFileInput');
            const pastedText = document.getElementById('importPastedText').value;

            if (fileInput.files.length > 0) {
                const file = fileInput.files[0];
                const reader = new FileReader();
                reader.onload = async function(e) {
                    try {
                        if (file.name.endsWith('.json')) {
                            const importedDeck = JSON.parse(e.target.result);
                            if (!importedDeck.name || !Array.isArray(importedDeck.cards)) throw new Error('Invalid JSON format.');
                            
                            const deckId = Date.now().toString();
                            const newDeck = { ...importedDeck, id: deckId, name: name, created: new Date().toISOString() };
                            
                            const oldIdToNewCardMap = new Map();
                            newDeck.cards = newDeck.cards.map(oldCard => {
                                const newCard = { ...oldCard, id: Date.now() + Math.random() };
                                oldIdToNewCardMap.set(oldCard.id, newCard);
                                return newCard;
                            });

                            if (newDeck.learnState && newDeck.learnState.buckets) {
                                newDeck.learnState.buckets = newDeck.learnState.buckets.map(bucket => 
                                    bucket.map(c => oldIdToNewCardMap.get(c.id)).filter(Boolean)
                                );
                            }
                            if (newDeck.reviewState) {
                                if (newDeck.reviewState.stillLearning) newDeck.reviewState.stillLearning = newDeck.reviewState.stillLearning.map(c => oldIdToNewCardMap.get(c.id)).filter(Boolean);
                                if (newDeck.reviewState.correct) newDeck.reviewState.correct = newDeck.reviewState.correct.map(c => oldIdToNewCardMap.get(c.id)).filter(Boolean);
                                if (newDeck.reviewState.lastRoundIncorrect) newDeck.reviewState.lastRoundIncorrect = newDeck.reviewState.lastRoundIncorrect.map(c => oldIdToNewCardMap.get(c.id)).filter(Boolean);
                            }

                            decks[deckId] = newDeck;
                            await saveDataToDB('decks', newDeck);
                            showToast(`Deck "${name}" imported successfully with ${newDeck.cards.length} cards!`);
                        } else if (file.name.endsWith('.csv') || file.name.endsWith('.txt')) {
                            const cards = parseTextData(e.target.result, file.name.endsWith('.csv') ? ',' : '\t');
                             if (cards.length > 0) {
                                await createNewDeck(name, importedDeck.category || 'Other', cards);
                                showToast(`Deck "${name}" imported successfully with ${cards.length} cards!`);
                            } else { throw new Error('No valid cards found in file.'); }
                        }
                        closeImportModal();
                        updateDashboard();
                    } catch (error) { showToast(`Error importing file: ${error.message}`, 'error'); }
                };
                reader.readAsText(file);
            } else if (pastedText.trim()) {
                 try {
                    const cards = parseTextData(pastedText.trim(), '\t');
                    if (cards.length > 0) {
                        createNewDeck(name, 'Other', cards);
                        showToast(`Deck "${name}" created successfully with ${cards.length} cards!`);
                        closeImportModal();
                        updateDashboard();
                    } else { throw new Error('No valid cards found in text.'); }
                 } catch (error) { showToast(`Error parsing text: ${error.message}`, 'error'); }
            } else {
                showToast('Please select a file or paste text to import.', 'error');
            }
        }
        function parseTextData(text, separator) {
            return text.split('\n').map(line => {
                const parts = line.split(separator);
                if (parts.length >= 2 && parts[0].trim() && parts[1].trim()) {
                    return { id: Date.now() + Math.random(), question: parts[0].trim(), answer: parts[1].trim(), isNew: true };
                }
                return null;
            }).filter(Boolean);
        }

        async function compressImage(dataUrl, maxSizeMB = 1) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);

                    let quality = 0.9;
                    let compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
                    
                    while (compressedDataUrl.length > maxSizeMB * 1024 * 1024 && quality > 0.1) {
                        quality -= 0.1;
                        compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
                    }
                    resolve(compressedDataUrl);
                };
                img.onerror = () => resolve(dataUrl); 
                img.src = dataUrl;
            });
        }

        function showConfirmModal(text, onConfirm, title = "Confirm Action") {
            const modal = document.getElementById('confirmActionModal');
            document.getElementById('confirmActionTitle').textContent = title;
            document.getElementById('confirmActionText').textContent = text;
            
            const confirmBtn = document.getElementById('confirmActionConfirmBtn');
            const newConfirmBtn = confirmBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);

            newConfirmBtn.addEventListener('click', () => {
                onConfirm();
                cancelAction();
            });
            
            modal.classList.add('show');
        }

        function cancelAction() {
            document.getElementById('confirmActionModal').classList.remove('show');
        }

        function openPracticeTestModal(deckId) {
            practiceTestState.deckId = deckId;
            document.getElementById('numQuestions').max = decks[deckId].cards.length;
            document.getElementById('numQuestions').value = Math.min(10, decks[deckId].cards.length);
            document.getElementById('practiceTestModal').classList.add('show');
        }

        function closePracticeTestModal() {
            document.getElementById('practiceTestModal').classList.remove('show');
        }

        function startPracticeTest() {
            const deckId = practiceTestState.deckId;
            const deck = decks[deckId];
            const testType = document.getElementById('testType').value;
            const numQuestions = parseInt(document.getElementById('numQuestions').value);
            
            if (numQuestions > deck.cards.length) {
                showToast("Not enough cards in deck", "error");
                return;
            }
            
            practiceTestState.cards = shuffleArray([...deck.cards]).slice(0, numQuestions);
            practiceTestState.testType = testType;
            practiceTestState.numQuestions = numQuestions;
            practiceTestState.currentCardIndex = 0;
            practiceTestState.correctCount = 0;
            practiceTestState.incorrectCount = 0;
            practiceTestState.startTime = new Date();
            
            closePracticeTestModal();
            
            showView('practiceTestView');
            document.getElementById('testSubtitle').textContent = deck.name;
            
            updateTestProgress();
            document.getElementById('testProgressView').classList.remove('hidden');
            document.getElementById('testCardView').classList.add('hidden');
            document.getElementById('testCompleteView').classList.add('hidden');
        }

        function updateTestProgress() {
            const total = practiceTestState.numQuestions;
            const current = practiceTestState.currentCardIndex;
            const correct = practiceTestState.correctCount;
            const incorrect = practiceTestState.incorrectCount;
            
            document.getElementById('testInfo').textContent = `${current} of ${total} questions`;
            document.getElementById('testProgressBar').style.width = total > 0 ? `${(current / total) * 100}%` : '0%';
            document.getElementById('testCorrectCount').textContent = correct;
            document.getElementById('testIncorrectCount').textContent = incorrect;
        }

        function startTest() {
            transitionSubView(
                document.getElementById('testProgressView'), 
                document.getElementById('testCardView')
            );
            showNextTestQuestion();
        }

        function showNextTestQuestion() {
            if (practiceTestState.currentCardIndex >= practiceTestState.cards.length) {
                finishTest();
                return;
            }

            const card = practiceTestState.cards[practiceTestState.currentCardIndex];
            const testType = practiceTestState.testType;
            let currentTestType = testType;
            if (testType === 'mixed') {
                currentTestType = Math.random() > 0.5 ? 'multiple_choice' : 'type';
            }

            document.querySelector('#testCardView .flashcard').classList.remove('is-flipped');
            document.getElementById('testQuestion').innerHTML = card.question;
            document.getElementById('testAnswer').innerHTML = card.answer;
            document.getElementById('testAnswerContent').classList.add('hidden');
            document.getElementById('testOptions').classList.add('hidden');
            document.getElementById('testAnswerInput').classList.add('hidden');
            document.getElementById('testShowAnswerBtn').classList.add('hidden');
            document.getElementById('testCheckAnswerBtn').classList.add('hidden');
            document.getElementById('testCorrectBtn').classList.add('hidden');
            document.getElementById('testIncorrectBtn').classList.add('hidden');
            document.getElementById('testNextBtn').classList.add('hidden');
            document.getElementById('testAccentToggleBtn').classList.add('hidden'); 
            testAnswerInput.classList.remove('correct', 'incorrect');
            document.getElementById('testCardInfo').textContent =
                `Question ${practiceTestState.currentCardIndex + 1} of ${practiceTestState.numQuestions}`;

            if (currentTestType === 'multiple_choice') {
                const options = generateMultipleChoiceOptions(card, practiceTestState.cards);
                displayMultipleChoiceOptions(options);
            } else if (currentTestType === 'type') {
                document.getElementById('testAnswerInput').classList.remove('hidden');
                document.getElementById('testAnswerInput').value = '';
                document.getElementById('testAnswerInput').disabled = false;
                document.getElementById('testCheckAnswerBtn').classList.remove('hidden');
                document.getElementById('testAnswerInput').focus();

                document.getElementById('testAccentToggleBtn').classList.remove('hidden');
                updateTestAccentButtonsVisibility(); 

            } else {
                document.getElementById('testShowAnswerBtn').classList.remove('hidden');
            }
        }

        function generateMultipleChoiceOptions(correctCard, allCards) {
            const options = new Set([correctCard.answer]);
            const wrongAnswers = shuffleArray(allCards.filter(card => card.id !== correctCard.id));
            
            for (const wrongCard of wrongAnswers) {
                if (options.size < 4) {
                    options.add(wrongCard.answer);
                } else {
                    break;
                }
            }
            return shuffleArray(Array.from(options));
        }

        function displayMultipleChoiceOptions(options) {
            const optionsContainer = document.getElementById('testOptions');
            optionsContainer.innerHTML = '';
            optionsContainer.classList.remove('hidden');
            
            options.forEach((option) => {
                const button = document.createElement('button');
                button.className = 'btn btn-secondary';
                button.textContent = option;
                button.onclick = () => {
                    checkTestAnswer(option);
                    document.querySelectorAll('#testOptions button').forEach(btn => btn.disabled = true);
                };
                optionsContainer.appendChild(button);
            });
        }

        function checkTestAnswer(selectedOption = null) {
            const card = practiceTestState.cards[practiceTestState.currentCardIndex];
            const isMultipleChoice = selectedOption !== null;
            
            const userInput = isMultipleChoice ? selectedOption : document.getElementById('testAnswerInput').value.trim();
            const correctAnswer = card.answer.trim();
            
            const isCorrect = userInput.toLowerCase() === correctAnswer.toLowerCase();
            
            if (isMultipleChoice) {
                document.querySelectorAll('#testOptions button').forEach(btn => {
                    if (btn.textContent === selectedOption) {
                        btn.className = isCorrect ? 'btn btn-success' : 'btn btn-danger';
                    }
                    if (btn.textContent === correctAnswer && !isCorrect) {
                        btn.className = 'btn btn-success';
                    }
                });
            } else {
                document.getElementById('testAnswerInput').classList.toggle('correct', isCorrect);
                document.getElementById('testAnswerInput').classList.toggle('incorrect', !isCorrect);
                document.getElementById('testAnswerInput').disabled = true;
            }
            
            document.getElementById('testCheckAnswerBtn').classList.add('hidden');
            document.getElementById('testAnswerContent').classList.remove('hidden');
            document.querySelector('#testCardView .flashcard').classList.add('is-flipped');
            document.getElementById('testNextBtn').classList.remove('hidden');
            
            if (isCorrect) practiceTestState.correctCount++;
            else practiceTestState.incorrectCount++;
        }

        function showTestAnswer() {
            document.querySelector('#testCardView .flashcard').classList.add('is-flipped');
            document.getElementById('testAnswerContent').classList.remove('hidden');
            document.getElementById('testShowAnswerBtn').classList.add('hidden');
            document.getElementById('testCorrectBtn').classList.remove('hidden');
            document.getElementById('testIncorrectBtn').classList.remove('hidden');
        }

        function markTestCorrect() {
            practiceTestState.correctCount++;
            nextTestQuestion();
        }

        function markTestIncorrect() {
            practiceTestState.incorrectCount++;
            nextTestQuestion();
        }

        function nextTestQuestion() {
            practiceTestState.currentCardIndex++;
            updateTestProgress();
            showNextTestQuestion();
        }

        async function finishTest() {
            const endTime = new Date();
            const timeTaken = Math.round((endTime - practiceTestState.startTime) / 1000);
            const totalAnswered = practiceTestState.correctCount + practiceTestState.incorrectCount;
            const accuracy = totalAnswered > 0 ? Math.round((practiceTestState.correctCount / totalAnswered) * 100) : 0;
            const score = practiceTestState.numQuestions > 0 ? Math.round((practiceTestState.correctCount / practiceTestState.numQuestions) * 100) : 0;
            
            document.getElementById('testScore').textContent = score;
            document.getElementById('testCorrectFinal').textContent = practiceTestState.correctCount;
            document.getElementById('testTotalFinal').textContent = practiceTestState.numQuestions;
            document.getElementById('testTime').textContent = `${timeTaken}s`;
            document.getElementById('testAccuracy').textContent = `${accuracy}%`;
            
            analyticsData.totalStudyTime += timeTaken;
            analyticsData.sessions.unshift({
                date: new Date().toISOString(),
                deckName: decks[practiceTestState.deckId].name,
                mode: 'Practice Test',
                duration: timeTaken,
                accuracy: accuracy
            });
             if (analyticsData.sessions.length > 50) analyticsData.sessions.pop();
            await saveDataToDB('appData', { key: 'analytics', ...analyticsData });
            
            transitionSubView(
                document.getElementById('testCardView'), 
                document.getElementById('testCompleteView')
            );
        }

        function restartTest() {
            practiceTestState.currentCardIndex = 0;
            practiceTestState.correctCount = 0;
            practiceTestState.incorrectCount = 0;
            practiceTestState.startTime = new Date();
            
            transitionSubView(
                document.getElementById('testCompleteView'), 
                document.getElementById('testProgressView')
            );
        }

        function endTest() {
            showView('dashboard');
        }
        
        async function updateStreak() {
            const today = new Date().setHours(0, 0, 0, 0);
            const lastUsedDate = analyticsData.lastUsed ? new Date(analyticsData.lastUsed).setHours(0, 0, 0, 0) : null;

            if (lastUsedDate) {
                const yesterday = new Date(today);
                yesterday.setDate(yesterday.getDate() - 1);

                if (lastUsedDate === yesterday.getTime()) {
                    analyticsData.streak++;
                } else if (lastUsedDate < yesterday.getTime()) {
                    analyticsData.streak = 1;
                }
            } else {
                analyticsData.streak = 1;
            }

            analyticsData.lastUsed = new Date(today).toISOString();
            await saveDataToDB('appData', { key: 'analytics', ...analyticsData });
        }

        function showAnalyticsModal() {
            document.getElementById('analyticsStreak').textContent = `${analyticsData.streak} day${analyticsData.streak === 1 ? '' : 's'}`;
            const totalMinutes = Math.round(analyticsData.totalStudyTime / 60);
            document.getElementById('analyticsTotalTime').textContent = `${totalMinutes}m`;

            const sessionList = document.getElementById('analyticsSessionList');
            if (analyticsData.sessions.length > 0) {
                sessionList.innerHTML = analyticsData.sessions.map(s => {
                    const date = new Date(s.date).toLocaleString();
                    const duration = `${Math.round(s.duration / 60)}m`;
                    const accuracyText = s.accuracy !== undefined ? ` - ${s.accuracy}% acc` : '';
                    return `<div class="deck-card-item">${date}: Studied "${s.deckName}" (${s.mode}) for ${duration}${accuracyText}</div>`;
                }).join('');
            } else {
                sessionList.innerHTML = '<p style="color: var(--secondary-text); text-align: center;">No study sessions recorded yet.</p>';
            }

            document.getElementById('analyticsModal').classList.add('show');
        }

        window.onclick = function(event) {
            document.querySelectorAll('.modal').forEach(modal => { if (event.target === modal) modal.classList.remove('show'); });
        }
        function levenshteinDistance(s1, s2) {
            s1 = s1.toLowerCase();
            s2 = s2.toLowerCase();

            const costs = [];
            for (let i = 0; i <= s1.length; i++) {
                let lastValue = i;
                for (let j = 0; j <= s2.length; j++) {
                    if (i === 0) {
                        costs[j] = j;
                    } else {
                        if (j > 0) {
                            let newValue = costs[j - 1];
                            if (s1.charAt(i - 1) !== s2.charAt(j - 1)) {
                                newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;
                            }
                            costs[j - 1] = lastValue;
                            lastValue = newValue;
                        }
                    }
                }
                if (i > 0) costs[s2.length] = lastValue;
            }
            return costs[s2.length];
        }

        function setupRadioCardSelection(radioGroupName) {
            const radioInputs = document.querySelectorAll(`input[name="${radioGroupName}"]`);
            
            function updateSelection() {
                radioInputs.forEach(input => {
                    const parentCard = input.closest('.checkbox-group');
                    if (parentCard) {
                        parentCard.classList.toggle('is-selected', input.checked);
                    }
                });
            }

            radioInputs.forEach(input => {
                input.addEventListener('change', updateSelection);
                const parentCard = input.closest('.checkbox-group');
                if (parentCard) {
                    parentCard.addEventListener('click', () => {
                        if (!input.checked) {
                            input.checked = true;
                            input.dispatchEvent(new Event('change'));
                        }
                    });
                }
            });
            
            updateSelection();
        }

        function calculateIQS(logData, userBaseline = { latency: 1500, fluency: 10 }) {
            const v_latency = 1 - (Math.min(logData.recallLatency / userBaseline.latency, 2) / 2);

            const v_fluency = Math.min(logData.answerFluency / userBaseline.fluency, 1.5) / 1.5;

            const v_corrections = 1 / (1 + logData.totalCorrections);
            
            const v_attempts = 1 / logData.attemptCount;

            const W_latency = 0.30;
            const W_fluency = 0.20;
            const W_corrections = 0.25;
            const W_attempts = 0.25;

            const iqs = (W_latency * v_latency) + (W_fluency * v_fluency) + (W_corrections * v_corrections) + (W_attempts * v_attempts);

            return Math.max(0, Math.min(1, iqs));
        }

    //Hello!
    </script>
</body>
</html>
