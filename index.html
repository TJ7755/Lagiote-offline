<!--

-->

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Lagiote Revise</title>
    <script src="./assets/js/pdf.min.js"></script>
    <script src="./assets/js/mammoth.browser.min.js"></script>
    <script src="./assets/js/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@latest/Sortable.min.js"></script>
    <script type="module" src="https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.1"></script>
    <link href="./assets/css/style.css" rel="stylesheet">
    <link rel="icon" type="image/png" href="https://i.ibb.co/1fyDzymL/Study-Stack-Pro-Photoroom.png">
    <style>
        
        .stats-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.9rem;
        }
        .stats-table th, .stats-table td {
            text-align: left;
            padding: 10px 8px;
            border-bottom: 1px solid var(--border-color);
        }
        .stats-table th {
            font-weight: 600;
            color: var(--secondary-text);
        }
        .stats-table tbody tr:hover {
            background-color: var(--input-bg);
        }
        .stats-table td:first-child {
            max-width: 300px;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        :root {
            --bg-color: #f7fafc; --text-color: #333; --header-bg: white; --card-bg: white; --border-color: #e2e8f0; --border-dashed: #e2e8f0; --primary-color: #667eea; --primary-hover: #5a67d8; --secondary-text: #718096; --shadow-color: rgba(0,0,0,0.05); --input-bg: #f7fafc; --input-focus-bg: white; --button-secondary-bg: #e2e8f0; --button-secondary-text: #4a5568; --button-secondary-hover: #cbd5e0; --success-color: #38a169; --danger-color: #e53e3e;
        }
        .dark-mode {
            --bg-color: #1a202c; --text-color: #e2e8f0; --header-bg: #2d3748; --card-bg: #2d3748; --border-color: #4a5568; --border-dashed: #4a5568; --primary-color: #7f9cf5; --primary-hover: #667eea; --secondary-text: #a0aec0; --shadow-color: rgba(0,0,0,0.2); --input-bg: #2d3748; --input-focus-bg: #4a5568; --button-secondary-bg: #4a5568; --button-secondary-text: #e2e8f0; --button-secondary-hover: #718096; --success-color: #68d391; --danger-color: #fc8181;
        }
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif; background: var(--bg-color); min-height: 100vh; color: var(--text-color); transition: background-color 0.3s, color 0.3s; }
        .view-container { 
            display: none; 
            position: relative; 
            z-index: 1;
        }
        .view-container.animating { animation-duration: 0.4s; animation-timing-function: ease-in-out; animation-fill-mode: forwards; }
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes fadeOut { from { opacity: 1; transform: translateY(0); } to { opacity: 0; transform: translateY(-10px); } }
        .fade-in { display: block !important; animation-name: fadeIn; }
        .fade-out { animation-name: fadeOut; }
        .sub-view.animating { animation-duration: 0.4s; animation-timing-function: ease-in-out; animation-fill-mode: forwards; }
        .sub-view-fade-in { display: flex !important; flex-direction: column; animation-name: fadeIn; }
        .sub-view-fade-out { animation-name: fadeOut; }
        @keyframes deckClick { 0% { transform: scale(1); } 50% { transform: scale(0.97); } 100% { transform: scale(1); } }
        .deck-clicked { animation: deckClick 0.3s ease-in-out; }
        .container { max-width: 1200px; margin: 0 auto; padding: 20px; }
        .section-title { font-size: 1.4rem; font-weight: 600; color: var(--text-color); margin-bottom: 25px; }
        .hidden { display: none !important; }
        .app-header { background: var(--header-bg); padding: 15px 20px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: center; position: sticky; top: 0; z-index: 100; }
        .logo-section { display: flex; align-items: center; gap: 15px; }
        .header-btn { background: var(--button-secondary-bg); border: none; border-radius: 50%; width: 40px; height: 40px; cursor: pointer; display: flex; align-items: center; justify-content: center; color: var(--button-secondary-text); transition: all 0.2s; }
        .header-btn:hover { background: var(--button-secondary-hover); transform: scale(1.05); }
        .logo {width: 48px; height: 48px; border-radius: 10px; overflow: hidden; cursor: pointer; display: flex; align-items: center; justify-content: center; color: white;}
        .logo img {width: 100%; height: 100%; object-fit: contain}
        .welcome-text { display: flex; align-items: baseline; gap: 10px; }
        .welcome-text h1 { font-size: 1.8rem; font-weight: 700; color: var(--text-color); }
        .welcome-text p { color: var(--secondary-text); font-size: 1rem; }
        .header-actions { display: flex; align-items: center; gap: 15px; }
        .search-bar { position: relative; width: 350px; max-width: 100%; }
        .search-input { width: 100%; padding: 12px 20px 12px 45px; border: 2px solid var(--border-color); border-radius: 25px; font-size: 16px; background: var(--input-bg); color: var(--text-color); transition: all 0.3s; }
        .search-input:focus { outline: none; border-color: var(--primary-color); background: var(--input-focus-bg); box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1); }
        .search-icon { position: absolute; left: 15px; top: 50%; transform: translateY(-50%); color: var(--secondary-text); width: 20px; height: 20px; }
        .main-content { margin-bottom: 40px; padding-top: 30px; }
        .decks-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 25px; }
        .category-folder { margin-bottom: 40px; }
        .category-title { font-size: 1.5rem; font-weight: 600; margin-bottom: 20px; padding-bottom: 10px; border-bottom: 2px solid var(--border-color); }
        .deck-card { background: var(--card-bg); border-radius: 20px; padding: 25px; box-shadow: 0 8px 25px var(--shadow-color); transition: all 0.3s; position: relative; overflow: hidden; display: flex; flex-direction: column; border-top: 6px solid; }
        .deck-card-main-clickable { cursor: pointer; flex-grow: 1; display: flex; flex-direction: column; }
        .deck-card:hover { transform: translateY(-5px); box-shadow: 0 12px 35px var(--shadow-color); }
        .deck-card[data-category="Science"] { border-color: #4ecdc4; } .deck-card[data-category="Math"] { border-color: #667eea; } .deck-card[data-category="Language"] { border-color: #fab1a0; } .deck-card[data-category="History"] { border-color: #fd79a8; } .deck-card[data-category="Other"] { border-color: #a29bfe; }
        .deck-category { font-size: 0.8rem; font-weight: 600; padding: 4px 10px; border-radius: 20px; display: inline-block; margin-bottom: 10px; text-transform: uppercase; letter-spacing: 0.5px; }
        .deck-card[data-category="Science"] .deck-category, .deck-detail-category.Science { color: #317b75; background-color: #e6fffa; } .deck-card[data-category="Math"] .deck-category, .deck-detail-category.Math { color: #5a67d8; background-color: #ebf4ff; } .deck-card[data-category="Language"] .deck-category, .deck-detail-category.Language { color: #c53030; background-color: #fff5f5; } .deck-card[data-category="History"] .deck-category, .deck-detail-category.History { color: #b83280; background-color: #fff5f7; } .deck-card[data-category="Other"] .deck-category, .deck-detail-category.Other { color: #6c5ce7; background-color: #f3f2ff; }
        .dark-mode .deck-card[data-category="Science"] .deck-category, .dark-mode .deck-detail-category.Science { color: #81e6d9; background-color: #2c7a7b; } .dark-mode .deck-card[data-category="Math"] .deck-category, .dark-mode .deck-detail-category.Math { color: #9f7aea; background-color: #5a67d830; } .dark-mode .deck-card[data-category="Language"] .deck-category, .dark-mode .deck-detail-category.Language { color: #f6ad55; background-color: #c5303030; } .dark-mode .deck-card[data-category="History"] .deck-category, .dark-mode .deck-detail-category.History { color: #f687b3; background-color: #b8328030; } .dark-mode .deck-card[data-category="Other"] .deck-category, .dark-mode .deck-detail-category.Other { color: #a3bffa; background-color: #6c5ce730; }
        .deck-header { margin-bottom: 15px; flex-grow: 1; }
        .deck-name { font-size: 1.4rem; font-weight: 700; color: var(--text-color); margin-bottom: 5px; line-height: 1.3; }
        .deck-info { display: flex; align-items: center; gap: 15px; color: var(--secondary-text); font-size: 0.9rem; font-weight: 500; }
        .deck-date { font-size: 0.8rem; color: var(--secondary-text); margin-top: auto; padding-bottom: 15px; } 
        .deck-progress-container { margin-top: 10px; }
        .deck-progress-label { font-size: 0.8rem; color: var(--secondary-text); margin-bottom: 5px; display: flex; justify-content: space-between; }
        .deck-progress-bar-outer { width: 100%; height: 8px; background: var(--border-color); border-radius: 4px; overflow: hidden; }
        .deck-progress-bar-inner { height: 100%; border-radius: 4px; transition: width 0.5s ease-in-out; }
        .deck-card[data-category="Science"] .deck-progress-bar-inner { background-color: #4ecdc4; } .deck-card[data-category="Math"] .deck-progress-bar-inner { background-color: #667eea; } .deck-card[data-category="Language"] .deck-progress-bar-inner { background-color: #fab1a0; } .deck-card[data-category="History"] .deck-progress-bar-inner { background-color: #fd79a8; } .deck-card[data-category="Other"] .deck-progress-bar-inner { background-color: #a29bfe; }
        .deck-actions { display: grid; grid-template-columns: 1fr 1fr auto; gap: 12px; margin-top: 15px; align-items:center; }
        .action-btn { flex: 1; padding: 12px 10px; border: none; border-radius: 12px; font-weight: 600; font-size: 14px; cursor: pointer; transition: all 0.3s; font-family: 'Inter', sans-serif; display: inline-flex; align-items: center; justify-content: center; gap: 6px; height: 44px; grid-row: 1 / 2; }
        .export-btn { grid-row: 1 / 2; background: var(--button-secondary-bg); color: var(--button-secondary-text); border: 2px solid var(--border-color); padding: 0; flex: 0 0 auto; width: 44px; height: 44px; display: flex; align-items: center; grid-column: 3 / 4; justify-content: center;}
        .export-btn:hover { background: var(--button-secondary-hover); border-color: #cbd5e0; }
        .learn-btn { background: var(--primary-color); color: white; }
        .learn-btn:hover { background: var(--primary-hover); transform: translateY(-1px); }
        .review-btn { background: var(--button-secondary-bg); color: var(--button-secondary-text); border: 2px solid var(--border-color); }
        .review-btn:hover { background: var(--button-secondary-hover); border-color: #cbd5e0; }
        .spaced-btn { background: #38b2ac; color: white; grid-column: 1 / 3; }
        .spaced-btn:hover { background: #319795; transform: translateY(-1px); }
        .deck-detail-view { background: var(--card-bg); border-radius: 20px; padding: 30px; box-shadow: 0 8px 25px var(--shadow-color); margin-bottom: 30px; }
        .deck-detail-header { display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 25px; }
        .deck-detail-title { font-size: 1.8rem; font-weight: 700; color: var(--text-color); margin-bottom: 5px; }
        .deck-detail-category { display: inline-block; padding: 5px 12px; border-radius: 20px; font-size: 0.9rem; font-weight: 500; }
        .deck-detail-actions { display: flex; flex-wrap: wrap; gap: 10px; }
        .deck-cards-list { max-height: 400px; overflow-y: auto; border: 2px solid var(--border-color); border-radius: 15px; padding: 20px; }
        .deck-card-item { padding: 15px; border-bottom: 1px solid var(--border-color); display: flex; justify-content: space-between; align-items: flex-start; gap: 15px; }
        .deck-card-item:last-child { border-bottom: none; }
        .deck-card-content { flex: 1; }
        .deck-card-question { font-weight: 500; color: var(--text-color); margin-bottom: 5px; }
        .deck-card-answer { color: var(--secondary-text); font-size: 0.95rem; }
        .card-image { max-width: 200px; max-height: 150px; border-radius: 8px; margin-top: 8px; }
        .deck-card-meta { display: flex; align-items: center; gap: 10px; }
        .new-badge { font-size: 0.75rem; font-weight: 600; color: var(--primary-color); background-color: #ebf4ff; padding: 2px 8px; border-radius: 10px; margin-left: 8px; }
        .dark-mode .new-badge { color: #9f7aea; background-color: #5a67d830; }
        .deck-card-actions { display: flex; gap: 10px; }
        .deck-card-action-btn { background: none; border: none; cursor: pointer; padding: 5px; border-radius: 6px; color: var(--secondary-text); transition: all 0.3s; }
        .deck-card-action-btn:hover { background: var(--input-bg); color: var(--text-color); }
        .deck-card-action-btn.edit:hover { color: var(--primary-color); }
        .deck-card-action-btn.delete:hover { color: var(--danger-color); }
        .create-options { display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px; }
        .create-card { background: var(--card-bg); border: 3px dashed var(--border-dashed); border-radius: 20px; padding: 40px 30px; text-align: center; cursor: pointer; transition: all 0.3s; position: relative; overflow: hidden; }
        .create-card:hover { border-color: var(--primary-color); background: var(--input-focus-bg); }
        .create-icon { font-size: 2.5rem; margin: 0 auto 15px auto; display: block; width: 40px; height: 40px; color: var(--primary-color); }
        .create-title { font-size: 1.2rem; font-weight: 600; color: var(--text-color); margin-bottom: 8px; }
        .create-desc { color: var(--secondary-text); font-size: 0.95rem; line-height: 1.4; }
        .no-decks { text-align: center; color: var(--secondary-text); font-size: 1.1rem; padding: 60px 20px; background: var(--card-bg); border-radius: 20px; border: 2px dashed var(--border-dashed); }
        .no-decks-icon { font-size: 4rem; margin: 0 auto 20px auto; display: block; width: 64px; height: 64px; opacity: 0.5; color: var(--secondary-text); }
        .btn { background: var(--primary-color); color: white; border: none; padding: 12px 24px; border-radius: 10px; font-size: 16px; font-weight: 500; cursor: pointer; transition: all 0.3s; font-family: 'Inter', sans-serif; display: inline-flex; align-items: center; justify-content: center; gap: 8px; }
        .btn svg { width: 20px; height: 20px; }
        .btn:hover { background: var(--primary-hover); transform: translateY(-1px); }
        .btn:disabled { background: #cbd5e0; cursor: not-allowed; transform: none; }
        .btn-secondary { background: var(--button-secondary-bg); color: var(--button-secondary-text); }
        .btn-secondary:hover { background: var(--button-secondary-hover); }
        .btn-danger { background: var(--danger-color); }
        .btn-danger:hover { background: #c53030; }
        .btn-success { background: var(--success-color); }
        .btn-success:hover { background: #2f855a; }
        .btn-prominent { padding: 16px 32px; font-size: 18px; font-weight: 600; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3); }
        .form-group { margin-bottom: 25px; }
        .form-group label { display: block; margin-bottom: 8px; color: var(--secondary-text); font-weight: 500; }
        .form-group input, .form-group textarea, .form-group select { width: 100%; padding: 12px 15px; border: 2px solid var(--border-color); background-color: var(--input-bg); color: var(--text-color); border-radius: 10px; font-size: 16px; font-family: 'Inter', sans-serif; transition: border-color 0.3s, background-color 0.3s; }
        .form-group input:focus, .form-group textarea:focus, .form-group select:focus { outline: none; border-color: var(--primary-color); background-color: var(--input-focus-bg); }
        .form-group textarea { min-height: 120px; resize: vertical; }
        .back-btn { background: none; border: none; color: var(--primary-color); font-size: 16px; cursor: pointer; margin-bottom: 20px; display: flex; align-items: center; gap: 8px; font-weight: 500; }
        .back-btn:hover { color: var(--primary-hover); }
        .modal { display: none; position: fixed; z-index: 1000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5); backdrop-filter: blur(5px); align-items: center; justify-content: center; }
        .modal.show { display: flex; }
        .modal-content { background-color: var(--card-bg); padding: 40px; border-radius: 20px; width: 90%; max-width: 500px; max-height: 90vh; overflow-y: auto; position: relative; animation: modalSlideIn 0.3s ease-out; text-align: left; }
        .modal-content.text-center { text-align: center; }
        @keyframes modalSlideIn { from { opacity: 0; transform: translateY(-30px) scale(0.95); } to { opacity: 1; transform: translateY(0) scale(1); } }
        .close { position: absolute; right: 20px; top: 20px; font-size: 24px; font-weight: bold; cursor: pointer; color: var(--secondary-text); transition: color 0.3s; }
        .close:hover { color: var(--text-color); }
        .modal h2 { color: var(--text-color); margin-bottom: 15px; font-size: 1.8rem; font-weight: 700; text-align: center; }
        .modal p { color: var(--secondary-text); margin-bottom: 30px; line-height: 1.5; text-align: center; }
        .modal-actions { display: flex; gap: 15px; justify-content: center; }
        .settings-container { background: var(--card-bg); border-radius: 20px; padding: 40px; box-shadow: 0 8px 25px var(--shadow-color); }
        .settings-section { padding-bottom: 20px; margin-bottom: 20px; border-bottom: 2px solid var(--border-color); }
        .settings-section:last-child { border-bottom: none; margin-bottom: 0; padding-bottom: 0; }
        .settings-section h2, .settings-section h4 { font-size: 1.3rem; font-weight: 600; color: var(--text-color); margin-bottom: 20px; }
        .dark-mode-toggle { display: flex; align-items: center; justify-content: space-between; }
        .switch { position: relative; display: inline-block; width: 50px; height: 28px; }
        .switch input { opacity: 0; width: 0; height: 0; }
        .slider { position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0; background-color: #ccc; transition: .4s; border-radius: 34px; }
        .slider:before { position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px; background-color: white; transition: .4s; border-radius: 50%; }
        input:checked + .slider { background-color: var(--primary-color); }
        input:checked + .slider:before { transform: translateX(22px); }
        .study-container { max-width: 800px; margin: 0 auto; padding: 20px; position: relative; display: flex; flex-direction: column; min-height: calc(100vh - 100px); background-color: var(--bg-color);}
        .study-header { text-align: center; margin-bottom: 30px; display: flex; justify-content: center; align-items: center; position: relative; }
        .study-header-content { flex-grow: 1; }
        .study-header-actions { position: absolute; right: 0; top: 50%; transform: translateY(-50%); display: flex; gap: 10px; }
        .study-title { font-size: 2rem; font-weight: 700; color: var(--text-color); margin-bottom: 10px; }
        .study-subtitle { color: var(--secondary-text); font-size: 1.1rem; }
        .flashcard-inner {
            display: grid;
            width: 100%;
            height: 100%;
            transition: transform 0.6s;
            transform-style: preserve-3d;
        } 
       .flashcard.is-flipped .flashcard-inner { transform: rotateY(180deg); }
        .flashcard { width: 100%; max-width: 1500px; background: transparent; perspective: 1000px; margin-bottom: 0px; flex-grow: 0; display: flex; flex-direction: column; }
        .flashcard-front, .flashcard-back {
            grid-area: 1 / 1 / 1 / 1;
            padding: 40px;
            min-height: 250px;
            -webkit-backface-visibility: hidden;
            backface-visibility: hidden;
            background: var(--card-bg);
            border-radius: 20px;
            text-align: center;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            box-shadow: 0 10px 30px var(--shadow-color);
            overflow-y: auto;
        }
        .flashcard-back { transform: rotateY(180deg); }
        #cardBucketInfo { position: absolute; top: 15px; left: 20px; font-size: 0.9rem; font-weight: 500; color: var(--secondary-text); background-color: var(--input-bg); padding: 4px 10px; border-radius: 12px; z-index: 5; }
        .question { font-size: 1.5rem; font-weight: 600; color: var(--text-color); margin-bottom: 25px; line-height: 1.4; }
        .answer { font-size: 1.2rem; color: var(--text-color); background: var(--input-bg); padding: 20px; border-radius: 12px; margin-top: 20px; line-height: 1.5; }
        #writeAnswerInput { width: 100%; min-height: 100px; margin-top: 20px; font-family: 'Inter', sans-serif; font-size: 1.1rem; padding: 20px; border-radius: 12px; transition: all 0.3s; }
        #writeAnswerInput:focus { border-color: var(--primary-color); box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1); }
        #writeAnswerInput.correct { border-color: var(--success-color); background-color: #f0fff4; }
        .dark-mode #writeAnswerInput.correct { background-color: #2c7a7b; }
        #writeAnswerInput.incorrect { border-color: var(--danger-color); background-color: #fff5f5; }
        .dark-mode #writeAnswerInput.incorrect { background-color: #c5303030; }
        .accent-buttons { margin-top: 15px; display: flex; flex-wrap: wrap; gap: 8px; justify-content: center; }
        .accent-buttons button { background: var(--button-secondary-bg); border: 1px solid var(--border-color); color: var(--button-secondary-text); padding: 5px 12px; border-radius: 8px; cursor: pointer; font-size: 1rem; }
        .accent-buttons button:hover { background: var(--button-secondary-hover); }
        .answer-buttons { display: flex; justify-content: center; gap: 10px; margin-top: 20px; flex-wrap: wrap; }
        .btn-show { background: #38b2ac; padding: 15px 30px; font-size: 16px; }
        .btn-show:hover { background: #319795; }
        .btn-correct { background: var(--success-color); order: 2; }
        .btn-incorrect { background: var(--danger-color); order: 1; }
        .btn-correct:hover { background: #2f855a; }
        .btn-incorrect:hover { background: #c53030; }
        .advanced-answer-btn { flex: 1; min-width: 100px; padding: 12px 15px; font-size: 14px; }
        .btn-again { background: #e53e3e; } .btn-again:hover { background: #c53030; }
        .btn-hard { background: #dd6b20; } .btn-hard:hover { background: #c05621; }
        .btn-good { background: #3182ce; } .btn-good:hover { background: #2b6cb0; }
        .btn-easy { background: #38a169; } .btn-easy:hover { background: #2f855a; }
        .progress-dashboard { background: var(--card-bg); border-radius: 20px; padding: 30px; margin-bottom: 30px; box-shadow: 0 8px 25px var(--shadow-color); position: relative; }
        #deckNotesDisplay { background: var(--input-bg); border: 2px solid var(--border-color); padding: 20px; border-radius: 15px; margin-bottom: 25px; }
        #deckNotesDisplay h3 { margin-bottom: 10px; }
        #deckNotesDisplay img { max-width: 100%; height: auto; border-radius: 8px; margin-top: 10px; }
        .progress-title { font-size: 1.8rem; font-weight: 700; text-align: center; margin-bottom: 25px; color: var(--text-color); }
        .round-info { text-align: center; margin-bottom: 25px; padding: 15px; background: var(--input-bg); border-radius: 12px; color: var(--primary-color); font-weight: 500; }
        .buckets-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(120px, 1fr)); gap: 15px; margin-bottom: 25px; }
        .bucket { background: var(--input-bg); border-radius: 12px; padding: 20px; text-align: center; border: 2px solid var(--border-color); }
        .bucket-number { font-size: 1rem; font-weight: 600; color: var(--primary-color); margin-bottom: 5px; }
        .bucket-count { font-size: 1.8rem; font-weight: 700; color: var(--text-color); }
        .progress-bar-container { width: 100%; height: 10px; background: var(--border-color); border-radius: 5px; overflow: hidden; margin: 20px 0; }
        .progress-fill { height: 100%; background: linear-gradient(90deg, #38a169, #48bb78); transition: width 0.5s ease; }
        .stats { display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 20px; margin: 25px 0; }
        .stat { text-align: center; padding: 15px; background: var(--input-bg); border-radius: 12px; border: 2px solid var(--border-color); }
        .stat-value { font-size: 1.5rem; font-weight: 700; color: var(--primary-color); }
        .stat-label { font-size: 0.9rem; color: var(--secondary-text); margin-top: 5px; }
        #cardView { display: flex; flex-direction: column; flex-grow: 1; }
        .ai-generator-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 25px; }
        .ai-panel { background: var(--card-bg); border-radius: 20px; padding: 30px; box-shadow: 0 8px 25px var(--shadow-color); display: flex; flex-direction: column; }
        .ai-panel h2 { font-size: 1.3rem; font-weight: 600; color: var(--text-color); margin-bottom: 20px; }
        .ai-tabs, .import-tabs { display: flex; border-bottom: 2px solid var(--border-color); margin-bottom: 20px; }
        .ai-tab, .import-tab { padding: 10px 15px; cursor: pointer; font-weight: 500; color: var(--secondary-text); border-bottom: 3px solid transparent; margin-bottom: -2px; transition: all 0.3s; }
        .ai-tab.active, .import-tab.active { color: var(--primary-color); border-bottom-color: var(--primary-color); }
        .file-drop-zone { border: 3px dashed var(--border-dashed); border-radius: 15px; padding: 25px; text-align: center; cursor: pointer; transition: all 0.3s; }
        .file-drop-zone:hover, .file-drop-zone.dragover { border-color: var(--primary-color); background: var(--input-focus-bg); }
        .file-drop-zone p { color: var(--secondary-text); margin-bottom: 10px; }
        .processing-controls { margin-top: auto; background: var(--input-bg); border-radius: 15px; padding: 25px; border: 2px solid var(--border-color); }
        .processing-controls h3 { font-size: 1.2rem; font-weight: 600; color: var(--text-color); margin-bottom: 15px; }
        .document-list, .flashcard-list { flex-grow: 1; overflow-y: auto; max-height: 500px; padding-right: 10px; }
        .document-item { background: var(--input-bg); border: 2px solid var(--border-color); border-radius: 12px; padding: 15px; margin-bottom: 10px; display: flex; flex-direction: column; }
        .document-item-header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px; }
        .document-name { font-weight: 500; color: var(--text-color); white-space: nowrap; overflow: hidden; text-overflow: ellipsis; padding-right: 10px; display: flex; align-items: center; }
        .document-status-icon { width: 20px; height: 20px; margin-right: 8px; flex-shrink: 0; }
        .remove-doc-btn { background: none; border: none; cursor: pointer; color: var(--secondary-text); padding: 0; width: 20px; height: 20px; }
        .remove-doc-btn:hover { color: #e53e3e; }
        .document-info { font-size: 0.9rem; color: var(--secondary-text); }
        .generated-card { background: var(--input-bg); border: 2px solid var(--border-color); border-radius: 12px; padding: 15px; margin-bottom: 10px; position: relative; }
        .generated-card .question { font-size: 1rem; margin-bottom: 8px; font-weight: 500; padding-right: 60px; }
        .generated-card .answer { font-size: 0.95rem; background: none; padding: 0; margin: 0; padding-right: 60px; }
        .generated-card-actions { position: absolute; top: 15px; right: 15px; display: flex; gap: 8px; }
        .generated-card-action-btn { background: none; border: none; cursor: pointer; padding: 5px; border-radius: 6px; color: var(--secondary-text); transition: all 0.3s; width: 28px; height: 28px; display: flex; align-items: center; justify-content: center; }
        .generated-card-action-btn:hover { background: var(--border-color); }
        .generated-card-action-btn.edit:hover { color: var(--primary-color); }
        .generated-card-action-btn.delete:hover { color: #e53e3e; }
        .list-empty-state { display: flex; flex-direction: column; justify-content: center; align-items: center; height: 100%; text-align: center; color: var(--secondary-text); }
        .list-empty-state-icon { width: 48px; height: 48px; margin-bottom: 10px; opacity: 0.6; }
        .spinner { width: 20px; height: 20px; border: 3px solid var(--primary-color); border-bottom-color: transparent; border-radius: 50%; animation: spin 1s ease-in-out infinite; }
        @keyframes spin { to { transform: rotate(360deg); } }
        .editor-container { background: var(--card-bg); border-radius: 20px; padding: 40px; box-shadow: 0 8px 25px var(--shadow-color); }
        .editor-container .question-input,
        .editor-container .solution-input {
            font-family: 'Inter', sans-serif;
            border: 2px solid var(--border-color);
            border-radius: 12px;
            padding: 15px;
            font-size: 1rem;
            transition: all 0.3s ease;
            background-color: var(--input-bg);
            color: var(--text-color);
            width: 100%;
        }
        /* Styling for Practice Test Textbox */
        #testAnswerInput {
            width: 100%;
            min-height: 120px;
            margin-top: 20px;
            font-family: 'Inter', sans-serif;
            font-size: 1.1rem;
            padding: 20px;
            border-radius: 12px;
            border: 2px solid var(--border-color);
            background-color: var(--input-bg);
            color: var(--text-color);
            transition: all 0.3s ease;
        }

        #testAnswerInput:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
        }

        /* Add specific styling for correct/incorrect states if not already present */
        #testAnswerInput.correct {
            border-color: var(--success-color);
            background-color: #f0fff4; /* Light green background */
        }

        .dark-mode #testAnswerInput.correct {
            background-color: #2c7a7b;
        }

        #testAnswerInput.incorrect {
            border-color: var(--danger-color);
            background-color: #fff5f5; /* Light red background */
        }

        .dark-mode #testAnswerInput.incorrect {
            background-color: #c5303030;
        }

        .editor-container .question-input:focus,
        .editor-container .solution-input:focus {
            outline: none;
            border-color: var(--primary-color);
            background-color: var(--input-focus-bg);
            /* Adds a modern shadow effect on focus */
            box-shadow: 0 0 0 4px rgba(102, 126, 234, 0.1);
        }
        .form-section { margin-bottom: 40px; }
        .form-row { display: flex; gap: 20px; margin-bottom: 25px; }
        .form-group { flex: 1; }
        .form-group.full-width { flex: 1 1 100%; }
        .form-group label { font-size: 16px; }
        .form-group input, .form-group textarea { padding: 15px 15px !important; border-radius: 10px !important; font-size: 16px !important; margin-bottom: 10px; resize: vertical; font-family: 'Inter', sans-serif; font-weight: bold;}
        .flashcard-editor-row {
            display: flex;
            align-items: center; 
            gap: 15px; 
            margin-bottom: 25px; 
        }

        .flashcard-item {
            flex-grow: 1; 
            padding: 25px;
            border: 2px solid var(--border-color);
            border-radius: 15px;
            background-color: var(--input-bg);
            position: relative; 
        }
        .image-preview { min-height: 20px; margin-bottom: 10px; }
        .image-preview img { max-width: 150px; max-height: 150px; border-radius: 8px; margin-top: 10px; display: block; }
        .image-controls { display: flex; align-items: center; gap: 10px; margin-bottom: 10px; }
        .image-controls span { font-size: 0.9rem; color: var(--secondary-text); }
        .question-input { border-color: var(--border-color) !important; }
        .solution-input { border-color: var(--border-color) !important; margin-bottom: 0; }
        .remove-card-btn {
            position: static; 
            background: #fee2e2;
            border: 2px solid #fca5a5;
            color: #dc2626;
            cursor: pointer;
            padding: 8px;
            border-radius: 10px;
            transition: all 0.3s;
            width: 44px;
            height: 44px;
            display: flex;
            align-items: center;
            justify-content: center;
            flex-shrink: 0;
        }
        .remove-card-btn:hover { background: #fecaca; border-color: #f87171; color: #b91c1c; transform: scale(1.05); }
        .add-question-btn { width: 100%; padding: 20px; border: 3px dashed var(--border-dashed); border-radius: 15px; background: var(--card-bg); color: var(--secondary-text); font-size: 16px; font-weight: 500; cursor: pointer; transition: all 0.3s; margin-bottom: 30px; }
        .add-question-btn:hover { border-color: var(--primary-color); background: var(--input-focus-bg); color: var(--primary-color); }
        .actions-section { display: flex; justify-content: flex-end; padding-top: 20px; border-top: 2px solid var(--border-color); }
        .checkbox-group { display: flex; align-items: center; gap: 10px; margin-bottom: 15px; }
        .checkbox-group input[type="radio"], .checkbox-group input[type="checkbox"] { width: 18px; height: 18px; accent-color: var(--primary-color); }
        .checkbox-group label { margin: 0; font-weight: 500; color: var(--text-color); }
        .form-group-inline { display: flex; align-items: center; gap: 10px; }
        #toast-container { position: fixed; bottom: 20px; left: 50%; transform: translateX(-50%); z-index: 2000; display: flex; flex-direction: column; align-items: center; gap: 10px; }
        .toast { background-color: var(--header-bg); color: var(--text-color); padding: 12px 20px; border-radius: 25px; box-shadow: 0 4px 15px rgba(0,0,0,0.1); font-size: 15px; font-weight: 500; display: flex; align-items: center; gap: 10px; transition: all 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55); opacity: 0; transform: translateY(20px) scale(0.9); }
        .toast.show { opacity: 1; transform: translateY(0) scale(1); }
        .toast.success { background-color: var(--success-color); color: white; }
        .toast.error { background-color: var(--danger-color); color: white; }
        @keyframes button-feedback-correct { 0% { background-color: var(--success-color); } 50% { background-color: #2f855a; transform: scale(1.05); } 100% { background-color: var(--success-color); } }
        @keyframes button-feedback-incorrect { 0% { background-color: var(--danger-color); } 50% { background-color: #c53030; transform: scale(1.05); } 100% { background-color: var(--danger-color); } }
        .feedback-correct { animation: button-feedback-correct 0.4s ease-in-out; }
        .feedback-incorrect { animation: button-feedback-incorrect 0.4s ease-in-out; }
        .custom-file-upload { border: 2px solid var(--border-color); border-radius: 10px; display: inline-block; padding: 12px 20px; cursor: pointer; background-color: var(--button-secondary-bg); color: var(--button-secondary-text); font-weight: 500; transition: all 0.3s; }
        .custom-file-upload:hover { background-color: var(--button-secondary-hover); }
        #importFileInput { display: none; }
        #fileNameDisplay { margin-top: 10px; color: var(--secondary-text); font-style: italic; }
        #testCardView { display: flex; flex-direction: column; flex-grow: 1; }
        #testOptions { width: 100%; margin-top: 20px; display: flex; flex-direction: column; gap: 10px; }
        #testOptions .btn { width: 100%; margin: 0; padding: 15px; font-size: 1rem; }
        .dashboard-footer { text-align: center; margin-top: 40px; }

        @media (max-width: 1024px) { .ai-generator-grid { grid-template-columns: 1fr; } }
        @media (max-width: 768px) {
            .app-header { flex-direction: column; gap: 15px; padding: 15px; }
            .header-actions { width: 100%; justify-content: space-between; }
            .search-bar { order: 2; width: 100%; }
            .header-settings-btn { order: 3;}
            .welcome-text h1 { font-size: 1.5rem; text-align: center;}
            .welcome-text p { display: none; }
            .decks-grid { grid-template-columns: 1fr; }
            .create-options { grid-template-columns: 1fr; }
            .answer-buttons { flex-direction: column; align-items: center; }
            .action-btn { padding: 10px 16px; font-size: 13px; }
            .form-row { flex-direction: column; gap: 15px; }
            .editor-container, .settings-container { padding: 25px; }
            .deck-detail-header { flex-direction: column; gap: 15px; }
            .deck-detail-actions { width: 100%; justify-content: center; }
            .generated-card .question, .generated-card .answer { padding-right: 0; }
            .generated-card-actions { position: static; margin-top: 10px; justify-content: flex-end; }
            .flashcard-front, .flashcard-back { padding: 20px; }
        }

        .settings-option-group {
            border: 2px solid var(--border-color);
            border-radius: 12px;
            padding: 10px 15px 15px 15px; /* Top padding is smaller due to legend */
            margin-top: 10px;
        }

        .settings-option-group legend {
            font-weight: 600;
            color: var(--text-color);
            padding: 0 8px; /* Creates a clean break in the fieldset border */
            margin-left: 10px;
            font-size: 0.95rem;
        }

        .radio-option-row {
            display: flex;
            align-items: center;
            padding: 5px;
            border-radius: 8px;
            cursor: pointer;
            transition: background-color 0.2s ease;
            margin-top: 5px;
        }

        .radio-option-row:hover {
            background-color: var(--input-bg);
        }

        .radio-option-row input[type="radio"] {
            width: 18px;
            height: 18px;
            accent-color: var(--primary-color);
            cursor: pointer;
        }

        .radio-option-row label {
            margin: 0 0 0 12px; /* Reset margin and add left spacing */
            font-weight: 500;
            color: var(--text-color);
            cursor: pointer;
        }
        .drag-item { cursor: grab; background-color: var(--input-bg); margin-bottom: 10px; }
        .drag-item:active { cursor: grabbing; }
        .drag-ghost { opacity: 0.5; background: var(--primary-color); }
        .drag-chosen { background: #ebf4ff; }
        .dark-mode .drag-chosen { background: #5a67d830; }
        #dynamicToast {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%) translateY(20px) scale(0.9); 
            z-index: 2000;
            
            background-color: var(--header-bg);
            color: var(--text-color);
            padding: 12px 20px;
            border-radius: 25px;
            box-shadow: 0 4px 20px rgba(0,0,0,0.15);
            font-size: 15px;
            font-weight: 500;
            
            display: flex;
            align-items: center;
            gap: 10px;
            
            transition: all 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            opacity: 0;
            pointer-events: none; 
        }
        #dynamicToast.show {
            opacity: 1;
            transform: translateX(-50%) translateY(0) scale(1);
            pointer-events: auto; 
        }
        #dynamicToast.success { background-color: var(--success-color); color: white; }
        #dynamicToast.error { background-color: var(--danger-color); color: white; }
        #dynamicToast.info { background-color: var(--primary-color); color: white; }
        #aiTabCustomise { color: white;}
    </style>
</head>
<body>
    <div id="dynamicToast" class="toast"></div>

    <header class="app-header">
         <div class="logo-section">
            <button id="headerBackBtn" class="header-btn hidden" title="Go Back">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" width="20" height="20"><path stroke-linecap="round" stroke-linejoin="round" d="M15.75 19.5 8.25 12l7.5-7.5" /></svg>
            </button>
            <div class="logo" onclick="backToDashboard(true)">
                <img src='https://i.ibb.co/1fyDzymL/Study-Stack-Pro-Photoroom.png'>
            </div>
            <div class="welcome-text">
                <h1 id="welcomeMessage">Lagiote Revise</h1>
                <span style="font-size: 0.8rem; color: var(--secondary-text); align-self: flex-end; padding-bottom: 5px;">v1.10</span>
                <div id="onlineStatusIndicator" style="display: flex; align-items: center; gap: 6px; align-self: flex-end; padding-bottom: 5px; margin-left: 15px;">
                    <div id="onlineStatusDot" style="width: 10px; height: 10px; border-radius: 50%;"></div>
                    <span id="onlineStatusText" style="font-size: 0.8rem; font-weight: 500;"></span>
                </div>
            </div>
        </div>
        <div class="header-actions">
            <div class="search-bar">
                <span class="search-icon"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="m21 21-5.197-5.197m0 0A7.5 7.5 0 1 0 5.196 5.196a7.5 7.5 0 0 0 10.607 10.607Z" /></svg></span>
                <input type="text" class="search-input" placeholder="Search decks..." id="searchInput">
            </div>
            <button id="headerHomeBtn" class="header-btn hidden" title="Go to Dashboard" onclick="backToDashboard(true)">
                <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" width="20" height="20">
                    <path stroke-linecap="round" stroke-linejoin="round" d="M2.25 12l8.954-8.955a1.5 1.5 0 012.122 0l8.954 8.955M3 10.5v9A2.25 2.25 0 005.25 21h13.5A2.25 2.25 0 0021 18.75v-9" />
                </svg>
            </button>
            <button id="headerSettingsBtn" class="header-btn header-settings-btn" title="Settings" onclick="showSettings()">
                 <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" width="20" height="20"><path stroke-linecap="round" stroke-linejoin="round" d="M10.343 3.94c.09-.542.56-.94 1.11-.94h1.093c.55 0 1.02.398 1.11.94l.149.894c.07.424.384.764.78.93.398.164.855.142 1.205-.108l.737-.527a1.125 1.125 0 0 1 1.45.12l.773.774c.39.39.44 1.02.12 1.45l-.527.737c-.25.35-.272.806-.108 1.204.165.397.505.71.93.78l.893.15c.543.09.94.56.94 1.11v1.093c0 .55-.397 1.02-.94 1.11l-.893.149c-.425.07-.765.383-.93.78-.165.398-.143.854.108 1.204l.527.738c.32.43.27.96-.12 1.45l-.773.773a1.125 1.125 0 0 1-1.45.12l-.737-.527c-.35-.25-.806-.272-1.204-.108-.397.165-.71.505-.78.93l-.15.893c-.09.543-.56.94-1.11.94h-1.093c-.55 0-1.02-.398-1.11-.94l-.149-.894c-.07-.424-.384-.764-.78-.93-.398-.164-.855-.142-1.205.108l-.737.527a1.125 1.125 0 0 1-1.45-.12l-.773-.774a1.125 1.125 0 0 1-.12-1.45l.527-.737c.25-.35.272-.806.108-1.204-.165-.397-.505-.71-.93-.78l-.894-.15c-.542-.09-.94-.56-.94-1.11v-1.093c0-.55.398-1.02.94-1.11l.894-.149c.424-.07.765-.383.93-.78.165-.398.143-.854-.108-1.204l-.527-.738a1.125 1.125 0 0 1 .12-1.45l.773-.773a1.125 1.125 0 0 1 1.45-.12l.737.527c.35.25.806.272 1.204.108.397-.165.71.505.78-.93l.15-.893Z" /><path stroke-linecap="round" stroke-linejoin="round" d="M15 12a3 3 0 1 1-6 0 3 3 0 0 1 6 0Z" /></svg>
            </button>
        </div>
    </header>
    
    <div id="dashboard" class="container view-container">
        <div class="main-content">
            <div id="decksSection">
                <p id="subtitle" style="color: var(--secondary-text); font-size: 1.1rem; margin-bottom: 25px;"></p>
                <div id="decksContainer"></div><br><br>
            </div>
            <div id="deckDetailView" class="deck-detail-view hidden">
                <div class="deck-detail-header">
                    <div>
                        <span class="deck-detail-category" id="deckDetailCategory"></span>
                        <h2 class="deck-detail-title" id="deckDetailTitle"></h2>
                    </div>
                    <div id="deckDetailActions" class="deck-detail-actions">
                        <button class="btn learn-btn" onclick="configureStudy('learn')">Learn</button>
                        <!--<button class="btn spaced-btn" onclick="configureStudy('spaced')">Spaced Learning</button>-->
                        <button class="btn review-btn" onclick="configureStudy('review')">Review</button>
                        <button class="btn review-btn" id="deckDetailTestBtn">Practice Test</button>
                        <button class="btn btn-secondary" id="deckDetailSettingsBtn">Settings</button>
                        <button class="btn btn-secondary" id="deckDetailEditBtn">Edit</button>
                        <button class="btn btn-danger" id="deckDetailDeleteBtn">Delete</button>
                    </div>
                </div>
                <h3 class="section-title">Cards in this deck</h3>
                <div class="deck-cards-list" id="deckCardsList"></div>
            </div>
            <div class="create-section">
                <div class="section-title">Start a new deck</div>
                <div class="create-options">
                    <div class="create-card" onclick="showEditor()">
                        <span class="create-icon"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L10.582 16.07a4.5 4.5 0 0 1-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 0 1 1.13-1.897l8.932-8.931Zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0 1 15.75 21H5.25A2.25 2.25 0 0 1 3 18.75V8.25A2.25 2.25 0 0 1 5.25 6H10" /></svg></span>
                        <div class="create-title">Create Manually</div>
                        <div class="create-desc">Build your own deck card-by-card</div>
                    </div>
                    <div class="create-card" onclick="showImportModal()">
                         <span class="create-icon"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 16.5V9.75m0 0 3 3m-3-3-3 3M6.75 19.5a4.5 4.5 0 0 1-1.41-8.775 5.25 5.25 0 0 1 10.233-2.33 3 3 0 0 1 3.758 3.848A3.752 3.752 0 0 1 18 19.5H6.75Z" /></svg></span>
                         <div class="create-title">Import Deck</div>
                         <div class="create-desc">Import from JSON, CSV, or pasted text</div>
                    </div>
                    <div class="create-card" onclick="showAiGenerator()">
                        <span class="create-icon"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9.813 15.904 9 18.75l-.813-2.846a4.5 4.5 0 0 0-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 0 0 3.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 0 0 3.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 0 0-3.09 3.09ZM18.259 8.715 18 9.75l-.259-1.035a3.375 3.375 0 0 0-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 0 0 2.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 0 0 2.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 0 0-2.456 2.456Z" /></svg></span>
                        <div class="create-title">Create with AI</div>
                        <div class="create-desc">Generate a deck from a topic or text</div>
                    </div>
                </div>
            </div>
             <div class="dashboard-footer">
                <button class="btn btn-secondary" onclick="showInsightsView()">Memory Insights</button>
                <button class="btn btn-secondary" onclick="showAnalyticsModal()">Show Analytics</button>
                <button id="internalDashboardBtn" class="btn btn-secondary" onclick="showInternalAnalytics()" style="margin-left: 10px;">Internal Dashboard</button>
            </div>
        </div>
    </div> 
<div id="insightsView" class="container view-container">
    <div class="section-title" style="padding-top: 20px;">Memory Insights</div>
    <div class="settings-container">
        <div class="form-group">
            <label for="insightsDeckSelect">Select a deck to analyze</label>
            <select id="insightsDeckSelect"></select>
        </div>
        <div id="insightsContent" class="hidden" style="margin-top: 30px;">
            <div style="display: grid; grid-template-columns: 1fr 2fr; gap: 30px;">
                <div>
                    <h4>Mastery Breakdown</h4>
                    <canvas id="masteryBreakdownChart" style="margin-top: 15px;"></canvas>
                    <div id="masteryLegend" style="margin-top: 15px; font-size: 0.9rem;"></div>
                </div>
                <div>
                    <h4>Predicted Forgetting Curve</h4>
                    <canvas id="forgettingCurveChart" style="margin-top: 15px;"></canvas>
                    <p id="cardDetailForCurve" style="text-align: center; margin-top: 10px; color: var(--secondary-text);">Select a card from the list to see its curve.</p>
                </div>
            </div>
            <h4 style="margin-top: 40px;">Card-Specific Data</h4>
            <div class="deck-cards-list" id="insightsCardList" style="margin-top: 15px;"></div>
        </div>
        <div id="insightsPlaceholder">
            <p style="text-align: center; color: var(--secondary-text); padding: 40px 0;">Please select a deck to view its memory insights.</p>
        </div>
    </div>
</div>
<div id="internalAnalyticsView" class="container view-container">
<div class="section-title" style="padding-top: 20px;">Internal Analytics Dashboard</div>
<div class="settings-container">
     <div class="settings-section">
        <h2>Common Error Analysis</h2>
        <div class="form-row">
            <div class="form-group">
                <label for="errorDeckSelect">Select Deck</label>
                <select id="errorDeckSelect"></select>
            </div>
            <div class="form-group">
                <label for="errorCardSelect">Select Card</label>
                <select id="errorCardSelect"></select>
            </div>
        </div>
        <div id="errorAnalysisResult" style="margin-top: 20px;">
            <p>Please select a card to see a breakdown of common incorrect answers.</p>
        </div>
    </div>

    <div class="settings-section">
        <h2>Interaction Metrics Distributions</h2>
        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 25px;">
            <div>
                <h4>Recall Latency (ms)</h4>
                <canvas id="latencyHistogram"></canvas>
            </div>
            <div>
                <h4>Answer Fluency (chars/sec)</h4>
                <canvas id="fluencyHistogram"></canvas>
            </div>
            <div>
                <h4>Corrections per Answer</h4>
                <canvas id="correctionsHistogram"></canvas>
            </div>
        </div>
        <div class="settings-section">
            <h2>Deck Flashcard Statistics</h2>
            <div id="deckStatisticsResult" style="margin-top: 20px; max-height: 500px; overflow-y: auto;">
            <p>Please select a deck to see a breakdown of its flashcard statistics.</p>
        </div>
    </div>
    </div>

    <div class="settings-section">
        <h2>Latency vs. Correctness</h2>
        <canvas id="latencyScatterPlot" style="max-height: 400px;"></canvas>
    </div>

    <div class="settings-section">
        <h2>Interactions Per Day</h2>
        <canvas id="interactionsTimeSeries" style="max-height: 400px;"></canvas>
    </div>

</div>
</div>
    <div id="aiGenerator" class="container view-container">
        <div class="section-title" style="padding-top: 20px;">AI Flashcard Generator</div>
        <div class="ai-generator-grid">
            <div class="ai-panel">
                <div class="ai-tabs">
                    <div id="aiTabInput" class="ai-tab active" onclick="switchAiTab('input')">1. Add Content</div>
                    <div id="aiTabCustomise" class="ai-tab" onclick="switchAiTab('customise')">2. Customise</div>
                </div>
                <div id="aiContentInput">
                    <div class="form-group">
                        <label>Upload Files or Enter Text</label>
                        <div class="file-drop-zone" id="file-drop-zone">
                             <input id="file-input" type="file" multiple class="hidden"/>
                             <p>Drag & drop or click to select files (Text, Image, PDF, DocX)</p>
                             <button type="button" class="btn btn-secondary" id="select-file-btn">Select Files</button>
                        </div>
                    </div>
                     <div class="form-group">
                        <textarea id="ai-text-input" placeholder="Or paste your text here..." style="min-height: 150px;"></textarea>
                        <button id="add-text-btn" class="btn" style="width:100%; margin-top:10px;">Add Text as Document</button>
                    </div>
                </div>
                <div id="aiContentCustomise" class="hidden">
                    <div class="form-group">
                        <label for="aiGenerationSource">Generate cards from...</label>
                        <select id="aiGenerationSource">
                            <option value="mixture" selected>General (Topic + Text)</option>
                            <option value="text">Text Content Only</option>
                            <option value="topic">Topic / Filename Only</option>
                        </select>
                    </div>
                     <div class="form-group">
                        <label for="aiPromptSelection">AI Prompt</label>
                        <div class="form-group-inline">
                            <select id="aiPromptSelection" style="flex-grow:1;"></select>
                            <button id="editPromptBtn" class="btn btn-secondary hidden" style="padding: 12px 15px;">Edit</button>
                        </div>
                    </div>
                     <div class="form-group">
                        <label for="flashcard-count-setting">Max Flashcards per Document</label>
                        <select id="flashcard-count-setting"><option value="auto" selected>Auto (Recommended)</option><option value="10">10</option><option value="20">20</option><option value="30">30</option></select>
                    </div>
                     <div class="form-group">
                        <label for="language-setting">Language</label>
                        <select id="language-setting"><option value="auto" selected>Auto (Recommended)</option><option value="English">English</option><option value="Spanish">Spanish</option><option value="French">French</option><option value="German">German</option></select>
                    </div>
                </div>
                <div class="processing-controls">
                    <h3 id="doc-count-title">Process All</h3>
                    <div id="processing-status" class="hidden" style="margin-bottom: 15px;">
                        <div style="margin-bottom: 5px; font-size: 0.9rem; color: var(--secondary-text);">Processing <span id="progress-current">0</span> of <span id="progress-total">0</span>...</div>
                        <div class="progress-bar-container"><div class="progress-fill" id="progress-bar" style="width: 0%;"></div></div>
                    </div>
                    <button id="process-btn" class="btn" style="width: 100%;" disabled>
                        <span id="process-icon"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9.813 15.904 9 18.75l-.813-2.846a4.5 4.5 0 0 0-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 0 0 3.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 0 0 3.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 0 0-3.09 3.09ZM18.259 8.715 18 9.75l-.259-1.035a3.375 3.375 0 0 0-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 0 0 2.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 0 0 2.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 0 0-2.456 2.456Z" /></svg></span>
                        <span id="loader-icon" class="spinner hidden"></span>
                        <span id="process-text">Process All</span>
                    </button>
                </div>
            </div>
            <div class="ai-panel">
                <h2 id="doc-list-count">Documents (0)</h2>
                <div class="document-list" id="document-list">
                    <div id="empty-doc-list" class="list-empty-state">
                        <div class="list-empty-state-icon"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M19.5 14.25v-2.625a3.375 3.375 0 0 0-3.375-3.375h-1.5A1.125 1.125 0 0 1 13.5 7.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H8.25m2.25 0H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 0 0-9-9Z" /></svg></div>
                        <p>Your uploaded documents will appear here.</p>
                    </div>
                </div>
            </div>
            <div class="ai-panel">
                <h2 id="flashcard-count">Generated Flashcards (0)</h2>
                <div class="flashcard-list" id="flashcard-list">
                    <div id="empty-flashcard-list" class="list-empty-state">
                        <div class="list-empty-state-icon"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9.813 15.904 9 18.75l-.813-2.846a4.5 4.5 0 0 0-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 0 0 3.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 0 0 3.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 0 0-3.09 3.09ZM18.259 8.715 18 9.75l-.259-1.035a3.375 3.375 0 0 0-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 0 0 2.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 0 0 2.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 0 0-2.456 2.456Z" /></svg></div>
                        <p>Generated cards will appear here after processing.</p>
                    </div>
                </div>
                 <div id="flashcard-summary" class="processing-controls hidden" style="margin-top: 15px;">
                    <button id="save-deck-btn" class="btn btn-success" style="width: 100%;">Save as New Deck</button>
                </div>
            </div>
        </div>
    </div>

    <div id="editorView" class="container view-container">
        <div class="editor-container" style="margin-top:20px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 30px; padding-bottom: 20px; border-bottom: 2px solid var(--border-color);">
                <h2 style="font-size: 1.8rem; font-weight: 700;">Create / Edit Deck</h2>
                <button class="btn btn-success" onclick="editorSaveDeck()">Save Deck</button>
            </div>
            <div class="form-section">
                <div class="form-row">
                    <div class="form-group">
                        <label for="deckTitle">Title</label>
                        <input type="text" id="deckTitle" placeholder="Enter deck title">
                    </div>
                     <div class="form-group">
                        <label for="deckCategory">Category</label>
                        <select id="deckCategory" class="form-group"></select>
                    </div>
                    <div class="form-group">
                        <label for="deckTypeHint">Deck Type (AI Hint)</label>
                        <select id="deckTypeHint">
                            <option value="General">General / Q&A</option>
                            <option value="Vocabulary">Vocabulary</option>
                            <option value="Sequence">Sequence / Ordered List</option>
                        </select>
                    </div>
                </div>
                <div class="form-group">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                        <label for="deckNotes" style="margin-bottom: 0;">Notes (optional, shown before studying)</label>
                        <button class="btn btn-secondary" style="padding: 5px 10px; font-size: 12px;" onclick="triggerNotesImageUpload(this)">Add Image</button>
                        <input type="file" class="image-upload-input" accept="image/*" style="display:none;" onchange="handleNotesImageUpload(this)">
                    </div>
                    <textarea id="deckNotes" placeholder="Add any notes, summaries, or instructions for this deck..."></textarea>
                </div>
            </div>
            <div class="flashcards-section">
                <div id="flashcardsContainer"></div>
                <button class="add-question-btn" onclick="editorAddNewCard()">+ Add Question</button>
                <div class="actions-section">
                    <button class="btn btn-success" onclick="editorSaveDeck()">Save Deck</button>
                </div>
            </div>
        </div>
    </div>
    
    <div id="settingsView" class="container view-container">
        <div class="settings-container" style="margin-top:20px;">
            <div class="settings-section">
                <h2>Profile</h2>
                <div class="form-group">
                <label for="usernameInput">Your Name</label>
                <input type="text" id="usernameInput" placeholder="Enter your name">
            </div>
            <button class="btn" onclick="saveUsername()">Save Name</button>
        </div>
        <div class="settings-section">
            <h2>Appearance</h2>
            <div class="dark-mode-toggle">
                <label for="darkModeToggle">Dark Mode</label>
                <label class="switch">
                    <input type="checkbox" id="darkModeToggle">
                    <span class="slider"></span>
                </label>
            </div>
        </div>
         <div class="settings-section">
            <h2>Study Settings</h2>
            <div class="checkbox-group">
                <input type="checkbox" id="enableInStudyEditing">
                <label for="enableInStudyEditing">Enable card editing during study sessions</label>
            </div>
            <div class="checkbox-group">
                <input type="checkbox" id="enableToastsToggle">
                <label for="enableToastsToggle">Enable motivational messages</label>
            </div>
             <!--<div class="form-group">
                 <label for="newCardsPerDay">New Cards Per Day (Spaced Learning)</label>
                 <input type="number" id="newCardsPerDay" value="20" min="1">
             </div>
            <div class="form-group">
                <fieldset class="settings-option-group">
                    <legend>Spaced Learning Feedback Style</legend>
                    
                    <div class="radio-option-row" onclick="document.getElementById('feedbackStyleSimple').checked = true;">
                        <input type="radio" id="feedbackStyleSimple" name="spacedFeedbackStyle" value="simple" checked>
                        <label for="feedbackStyleSimple">Simple (Correct / Incorrect)</label>
                    </div>

                    <div class="radio-option-row" onclick="document.getElementById('feedbackStyleAdvanced').checked = true;">
                        <input type="radio" id="feedbackStyleAdvanced" name="spacedFeedbackStyle" value="advanced">
                        <label for="feedbackStyleAdvanced">Advanced (4 Buttons)</label>
                    </div>

                </fieldset>
            </div>-->
            <button class="btn" onclick="saveStudySettings()">Save Study Settings</button>
            
        </div>
        <div class="settings-section">
            <h2>Danger Zone</h2>
            <p style="color: var(--secondary-text); margin-bottom: 15px;">These actions are permanent and cannot be undone.</p>
            <button class="btn btn-danger" onclick="clearAllDecks()">Clear All Decks</button>
        </div>
    </div>
</div>

<div id="studyMode" class="container view-container">
    <div class="study-container">
        <div class="study-header">
            <div class="study-header-content">
                <div class="study-title" id="studyTitle">Learning Mode</div>
                <div class="study-subtitle" id="studySubtitle">Deck Name</div><br>
                <div id="focusMeter" style="display: inline-block; margin-left: 15px; vertical-align: middle;">
                    <span style="font-size: 0.9rem; color: var(--secondary-text); margin-right: 5px;">Focus:</span>
                    <div id="focusDot" style="display: inline-block; width: 12px; height: 12px; border-radius: 50%; background-color: #38a169; transition: background-color 0.3s;"></div>
                </div>
            </div>
            <div class="study-header-actions">
                 <button id="accentToggleBtn" class="header-btn hidden" title="Toggle Accents">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" width="20" height="20"><path stroke-linecap="round" stroke-linejoin="round" d="M12 21a9.004 9.004 0 0 0 8.716-6.747M12 21a9.004 9.004 0 0 1-8.716-6.747M12 21c1.356 0 2.673-.174 3.946-.512M12 21c-1.273 0-2.59-.174-3.872-.512M21 12a9 9 0 0 0-9-9c-1.356 0-2.673.174-3.946.512M3 12a9 9 0 0 1 9-9c1.273 0 2.59.174 3.872.512M12 3v18" /></svg>
                </button>
                <button id="editStudyCardBtn" class="header-btn hidden" title="Edit Card">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" width="20" height="20">
                        <path stroke-linecap="round" stroke-linejoin="round" d="m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L10.582 16.07a4.5 4.5 0 0 1-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 0 1 1.13-1.897l8.932-8.931Zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0 1 15.75 21H5.25A2.25 2.25 0 0 1 3 18.75V8.25A2.25 2.25 0 0 1 5.25 6H10" />
                    </svg>
                </button>
                <button id="switchStudyModeBtn" class="header-btn hidden" title="Switch Study Mode">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" width="20" height="20">
                        <path stroke-linecap="round" stroke-linejoin="round" d="M16.862 4.487l1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L6.832 19.82a4.5 4.5 0 0 1-1.897 1.13l-2.685.8.8-2.685a4.5 4.5 0 0 1 1.13-1.897L16.863 4.487zm0 0L19.5 7.125" />
                    </svg>
                </button>
                <button id="instructionsBtn" class="header-btn" title="Instructions">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" width="20" height="20"><path stroke-linecap="round" stroke-linejoin="round" d="M9.879 7.519c1.171-1.025 3.071-1.025 4.242 0 1.172 1.025 1.172 2.687 0 3.712-.203.179-.43.326-.67.442-.745.361-1.45.999-1.45 1.827v.75M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 5.25h.008v.008H12v-.008Z" /></svg>
                </button>
            </div>
        </div>
        <div id="progressView" class="hidden sub-view">
            <div class="progress-dashboard">
                <div id="deckNotesDisplay" class="hidden"></div>
                <div class="progress-title" id="progressTitle">Learning Progress</div>
                
                <div style="margin-bottom: 25px;">
                    <div class="deck-progress-label" style="margin-bottom: 10px;">
                        <span>Deck Mastery</span>
                        <span id="deckMasteryValue">0%</span>
                    </div>
                    <div class="progress-bar-container">
                        <div class="progress-fill" id="deckMasteryProgress" style="width: 0%"></div>
                    </div>
                </div>

                <div class="stats" id="statsContainer">
                    <div class="stat">
                        <div class="stat-value" id="masteredCardCount">0</div>
                        <div class="stat-label">Cards Mastered</div>
                    </div>
                    <div class="stat">
                        <div class="stat-value" id="learningCardCount">0</div>
                        <div class="stat-label">Cards Learning</div>
                    </div>
                </div>

                <div id="activeLearningPoolDisplay" style="margin-top: 30px;">
                    <h4 style="font-weight: 600; color: var(--text-color); margin-bottom: 15px; text-align: center;">This Round's Focus</h4>
                    <div id="activePoolList" class="deck-cards-list" style="max-height: 150px; padding: 10px 20px; border-style: dashed;">
                        <p style="text-align: center; color: var(--secondary-text);">Preparing your next round...</p>
                    </div>
                </div>

                <div style="text-align: center; margin-top: 30px;">
                    <button class="btn" id="continueBtn">Continue Round</button>
                    <button class="btn btn-secondary" onclick="endSession()" style="margin-left: 10px;">End Session</button>
                    <button class="btn btn-danger" id="resetBtn" onclick="resetProgress()" style="margin-left: 10px;">Reset Progress</button>
                </div>
            </div>
        </div>
        <div id="cardView" class="hidden sub-view">
            <div id="passiveReviewView" class="hidden" style="width: 100%;">
                <div class="flashcard-front" style="text-align: left;">
                    <h3 style="text-align: center; margin-bottom: 20px;">Let's learn these:</h3>
                    <ol id="passiveReviewList" style="padding-left: 40px; font-size: 1.2rem; line-height: 1.8;"></ol>
                </div>
                <div class="answer-buttons">
                    <button class="btn btn-success" onclick="moveToNextSequencePhase()">Got it, Start Practice</button>
                </div>
            </div>

            <div id="dragDropView" class="hidden" style="width: 100%;">
                <div class="flashcard-front">
                    <h3 style="margin-bottom: 20px;">Put these items in the correct order:</h3>
                    <div id="dragDropList" class="deck-cards-list" style="max-height: none; border-style: dashed;">
                    </div>
                </div>
                <div class="answer-buttons">
                    <button id="checkDragDropBtn" class="btn btn-show" onclick="checkDragDropOrder()">Check Order</button>
                </div>
            </div>
            <div class="round-info" id="cardRoundInfo">Round 1 - Card 1 of 5</div>
            <div id="flashcardViewContainer">
                <div class="flashcard">
                    <div class="flashcard-inner">
                        <div class="flashcard-front">
                            <div id="cardBucketInfo">New</div>
                            <div id="cardQuestionContent">
                                <div class="question" id="cardQuestion"></div>
                            </div>
                        </div>
                        <div class="flashcard-back">
                            <div id="cardAnswerContent" class="hidden">
                                <div class="answer" id="cardAnswer"></div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div id="mcqView" class="hidden" style="width: 100%;">
                <div class="flashcard-front" style="min-height: 150px; margin-bottom: 20px;">
                    <div class="question" id="mcqQuestion"></div>
                </div>
                <div id="mcqOptions" class="answer-buttons" style="flex-direction: column; gap: 15px; width: 100%;">
                </div>
            </div>

            <div style="text-align: center; margin-top: 20px;">
                <textarea id="writeAnswerInput" class="form-group textarea hidden" placeholder="Type your answer here..."></textarea>
                <div id="accentButtonsContainer" class="accent-buttons hidden"></div>
                <div id="feedbackMessage" style="text-align: center; margin-top: 10px; font-weight: 500; min-height: 20px;"></div>
            </div>

            <div class="answer-buttons" id="simpleAnswerButtons">
                <button class="btn btn-show" id="showAnswerBtn" onclick="showAnswer()">Show Answer</button>
                <button class="btn btn-secondary hidden" id="showQuestionBtn" onclick="showQuestion()">Show Question</button>
                <button class="btn btn-show hidden" id="checkAnswerBtn" onclick="autoCheckAnswer()">Check Answer</button>
                <button class="btn btn-secondary hidden" id="dontKnowBtn" onclick="dontKnowAnswer()">Don't Know</button>
                <button class="btn btn-incorrect hidden" id="incorrectBtn" onclick="markIncorrect()">Incorrect</button>
                <button class="btn btn-correct hidden" id="correctBtn" onclick="markCorrect()">Correct</button>
            </div>
             <div class="answer-buttons hidden" id="advancedAnswerButtons">
                <button class="btn btn-again advanced-answer-btn" onclick="markSpaced(1)">Again</button>
                <button class="btn btn-hard advanced-answer-btn" onclick="markSpaced(2)">Hard</button>
                <button class="btn btn-good advanced-answer-btn" onclick="markSpaced(3)">Good</button>
                <button class="btn btn-easy advanced-answer-btn" onclick="markSpaced(4)">Easy</button>
            </div>
        </div>
        <div id="completeView" class="hidden sub-view">
            <div class="progress-dashboard">
                <div class="progress-title">Complete!</div>
                <p style="text-align: center; font-size: 1.2rem; margin: 25px 0; color: var(--secondary-text);">Congratulations! You've mastered all your flashcards.</p>
                <div class="stats" id="finalStats"></div>
                <div style="text-align: center; margin-top: 25px;">
                    <button class="btn" onclick="restartStudy()">Study Again</button>
                    <button class="btn btn-secondary" onclick="endSession()" style="margin-left: 10px;">End Session</button>
                </div>
            </div>
        </div>
        <div id="preGenerationView" class="hidden sub-view">
            <div class="progress-dashboard" style="text-align: center;">
                <div class="progress-title">Preparing Smart Questions...</div>
                <div class="spinner" style="width: 40px; height: 40px; border-width: 4px; margin: 20px auto;"></div>
                <p style="color: var(--secondary-text); margin-bottom: 25px;">This may take a moment. Our AI is generating some questions for you...</p>
                
                <div class="progress-bar-container" style="max-width: 300px; margin: 0 auto;">
                    <div class="progress-fill" id="preGenerationProgress" style="width: 0%;"></div>
                </div>
                <p id="preGenerationProgressText" style="margin-top: 10px; font-weight: 500; color: var(--secondary-text);">0 / 0</p>
            </div>
        </div>
    </div>
</div>

<div id="practiceTestModal" class="modal">
    <div class="modal-content" style="max-width: 500px;">
        <span class="close" onclick="closePracticeTestModal()">&times;</span>
        <h2>Practice Test</h2>
        <div class="form-group">
            <label for="testType">Test Type</label>
            <select id="testType">
                <option value="flashcard">Flashcards</option>
                <option value="multiple_choice">Multiple Choice</option>
                <option value="type">Type Answer</option>
                <option value="mixed">Mixed Types</option>
            </select>
        </div>
        <div class="form-group">
            <label for="numQuestions">Number of Questions</label>
            <input type="number" id="numQuestions" min="1" max="100" value="10">
        </div>
        <div class="modal-actions">
            <button class="btn btn-secondary" onclick="closePracticeTestModal()">Cancel</button>
            <button class="btn btn-success" onclick="startPracticeTest()">Start Test</button>
        </div>
    </div>
</div>

<div id="practiceTestView" class="container view-container">
    <div class="study-container">
        <div class="study-header">
            <div class="study-header-content">
                <div class="study-title" id="testTitle">Practice Test</div>
                <div class="study-subtitle" id="testSubtitle">Deck Name</div>
            </div>
            <div class="study-header-actions">
                <button id="testAccentToggleBtn" class="header-btn hidden" title="Toggle Accents">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" width="20" height="20"><path stroke-linecap="round" stroke-linejoin="round" d="M12 21a9.004 9.004 0 0 0 8.716-6.747M12 21a9.004 9.004 0 0 1-8.716-6.747M12 21c1.356 0 2.673-.174 3.946-.512M12 21c-1.273 0-2.59-.174-3.872-.512M21 12a9 9 0 0 0-9-9c-1.356 0-2.673.174-3.946-.512M3 12a9 9 0 0 1 9-9c1.273 0 2.59.174 3.872.512M12 3v18" /></svg>
                </button>
                <button id="testInstructionsBtn" class="header-btn" title="Instructions">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" width="20" height="20"><path stroke-linecap="round" stroke-linejoin="round" d="M9.879 7.519c1.171-1.025 3.071-1.025 4.242 0 1.172 1.025 1.172 2.687 0 3.712-.203.179-.43.326-.67.442-.745.361-1.45.999-1.45 1.827v.75M21 12a9 9 0 1 1-18 0 9 9 0 0 1 18 0Zm-9 5.25h.008v.008H12v-.008Z" /></svg>
                </button>
            </div>
        </div>
        <div id="testProgressView" class="hidden sub-view">
            <div class="progress-dashboard">
                <div class="progress-title">Test Progress</div>
                <div class="round-info" id="testInfo">0 of 0 questions</div>
                <div class="progress-bar-container"><div class="progress-fill" id="testProgressBar" style="width: 0%"></div></div>
                <div class="stats">
                    <div class="stat"><div class="stat-value" id="testCorrectCount">0</div><div class="stat-label">Correct</div></div>
                    <div class="stat"><div class="stat-value" id="testIncorrectCount">0</div><div class="stat-label">Incorrect</div></div>
                </div>
                <div style="text-align: center; margin-top: 25px;">
                    <button class="btn" onclick="startTest()">Start Test</button>
                </div>
            </div>
        </div>
        <div id="testCardView" class="hidden sub-view">
            <div class="round-info" id="testCardInfo">Question 1 of 10</div>
            <div class="flashcard">
                <div class="flashcard-inner">
                    <div class="flashcard-front">
                        <div class="question" id="testQuestion"></div>
                    </div><br><br><br><br>
                    <br>
                    <div class="flashcard-back">
                        <div id="testAnswerContent" class="hidden">
                            <div class="answer" id="testAnswer"></div>
                        </div>
                    </div>
                    <br><br><br>
                </div>
            </div>
            <div id="testOptions" class="hidden"></div>
            <div style="text-align: center; margin-top: 30px;">
                <textarea id="testAnswerInput" class="form-group textarea hidden" placeholder="Type your answer here..."></textarea>
                <div id="testAccentButtonsContainer" class="accent-buttons hidden"></div>
            </div>
            <div class="answer-buttons">
                <button class="btn btn-show" id="testShowAnswerBtn" onclick="showTestAnswer()">Show Answer</button>
                <button class="btn btn-show hidden" id="testCheckAnswerBtn" onclick="checkTestAnswer()">Check Answer</button>
                <button class="btn btn-incorrect hidden" id="testIncorrectBtn" onclick="markTestIncorrect()">Incorrect</button>
                <button class="btn btn-correct hidden" id="testCorrectBtn" onclick="markTestCorrect()">Correct</button>
                <button class="btn btn-success hidden" id="testNextBtn" onclick="nextTestQuestion()">Next</button>
            </div>
        </div>
        <div id="testCompleteView" class="hidden sub-view">
            <div class="progress-dashboard">
                <div class="progress-title">Test Complete!</div>
                <p style="text-align: center; font-size: 1.2rem; margin: 25px 0; color: var(--secondary-text);">
                    You scored <span id="testScore">0</span>% (<span id="testCorrectFinal">0</span> out of <span id="testTotalFinal">0</span>)
                </p>
                <div class="stats">
                    <div class="stat"><div class="stat-value" id="testTime">0s</div><div class="stat-label">Time Taken</div></div>
                    <div class="stat"><div class="stat-value" id="testAccuracy">0%</div><div class="stat-label">Accuracy</div></div>
                </div>
                <div style="text-align: center; margin-top: 25px;">
                    <button class="btn" onclick="restartTest()">Retake Test</button>
                    <button class="btn btn-secondary" onclick="endTest()" style="margin-left: 10px;">End Test</button>
                </div>
            </div>
        </div>
    </div>
</div>

<div id="importModal" class="modal">
    <div class="modal-content" style="max-width: 700px;">
        <span class="close" onclick="closeImportModal()">&times;</span>
        <h2>Import Deck</h2>
        <div class="import-tabs">
            <div id="importTabPaste" class="import-tab active" onclick="switchImportTab('paste')">Paste Text</div>
            <div id="importTabFile" class="import-tab" onclick="switchImportTab('file')">Import File</div>
        </div>
        <div id="importContentPaste">
            <div class="form-group">
                <label for="importPastedText">Paste your content here</label>
                <textarea id="importPastedText" style="min-height: 200px;" placeholder="Question 1<Tab>Answer 1&#x0a;Question 2<Tab>Answer 2"></textarea>
            </div>
            <p style="font-size: 0.9rem; color: var(--secondary-text); text-align: left; margin-top: -15px; margin-bottom: 20px;">Separate terms and definitions with a Tab, and separate cards with a new line.</p>
        </div>
        <div id="importContentFile" class="hidden">
            <div class="form-group">
                <label for="importFileInput" class="custom-file-upload">
                    <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" width="20" height="20" style="vertical-align: middle; margin-right: 8px;"><path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5m-13.5-9L12 3m0 0 4.5 4.5M12 3v13.5" /></svg>
                    Choose File
                </label>
                <input type="file" id="importFileInput" accept=".json,.csv,.txt">
                <div id="fileNameDisplay">No file chosen</div>
                <p style="font-size: 0.9rem; color: var(--secondary-text); text-align: left; margin-top: 10px;">Supports .json (exported from here), .csv, and .txt files.</p>
            </div>
        </div>
        <div class="form-row" style="margin-bottom: 0;">
            <div class="form-group" style="flex: 2;">
                <label for="importDeckName">New Deck Name</label>
                <input type="text" id="importDeckName" placeholder="e.g., Biology Chapter 5">
            </div>
            <div class="form-group">
                <label for="importDeckCategory">Category</label>
                <select id="importDeckCategory"></select>
            </div>
            <div class="form-group">
                <label for="importDeckTypeHint">Deck Type</label>
                <select id="importDeckTypeHint">
                    <option value="General">General / Q&A</option>
                    <option value="Vocabulary">Vocabulary</option>
                    <option value="Sequence">Sequence / Ordered List</option>
                </select>
            </div>
        </div>
        <div class="modal-actions">
            <button class="btn btn-success" onclick="importData()">Import and Create Deck</button>
        </div>
    </div>
</div>

<div id="confirmActionModal" class="modal">
    <div class="modal-content text-center">
        <h2 id="confirmActionTitle">Confirm Action</h2>
        <p id="confirmActionText"></p>
        <div class="modal-actions">
            <button id="confirmActionCancelBtn" class="btn btn-secondary" onclick="cancelAction()">Cancel</button>
            <button id="confirmActionConfirmBtn" class="btn btn-danger">Confirm</button>
        </div>
    </div>
</div>

<div id="editCardModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="closeEditCardModal()">&times;</span>
        <h2>Edit Flashcard</h2>
        <div class="form-group">
            <label for="editCardQuestion">Question</label>
            <textarea id="editCardQuestion" class="question-input"></textarea>
        </div>
        <div class="form-group">
            <label for="editCardAnswer">Answer</label>
            <textarea id="editCardAnswer" class="solution-input"></textarea>
        </div>
        <div class="modal-actions" style="margin-top: 15px;">
            <button class="btn btn-secondary" onclick="closeEditCardModal()">Cancel</button>
            <button class="btn btn-success" onclick="saveEditedCard()">Save Changes</button>
        </div>
    </div>
</div>

<div id="editAiCardModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="closeEditAiCardModal()">&times;</span>
        <h2>Edit AI Flashcard</h2>
        <div class="form-group">
            <label for="editAiCardQuestion">Question</label>
            <textarea id="editAiCardQuestion" class="question-input"></textarea>
        </div>
        <div class="form-group">
            <label for="editAiCardAnswer">Answer</label>
            <textarea id="editAiCardAnswer" class="solution-input"></textarea>
        </div>
        <div class="modal-actions" style="margin-top: 15px;">
            <button class="btn btn-secondary" onclick="closeEditAiCardModal()">Cancel</button>
            <button class="btn btn-success" onclick="saveAiEditedCard()">Save Changes</button>
        </div>
    </div>
</div>

<div id="takeABreakModal" class="modal">
    <div class="modal-content text-center">
         <span class="close" onclick="this.parentElement.parentElement.classList.remove('show')">&times;</span>
         <h2>Focus is Waning</h2>
         <p>Taking breaks is great for improving learning. Take a moment to recharge your batteries!</p>
         <div class="modal-actions">
            <button class="btn btn-secondary" onclick="document.getElementById('takeABreakModal').classList.remove('show')">Keep Going</button>
            <button class="btn btn-success" onclick="endSession()">End Session</button>
         </div>
    </div>
</div>

<div id="nameModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="closeNameModal()">&times;</span>
        <h2>Welcome to Lagiote Revise!</h2>
        <p>What should we call you?</p>
        <form id="nameForm">
            <div class="form-group">
                <input type="text" id="nameInput" placeholder="Enter your name" required>
            </div>
            <div class="modal-actions">
                <button type="submit" class="btn">Get Started</button>
            </div>
        </form>
    </div>
</div>

<div id="addCategoryModal" class="modal">
    <div class="modal-content">
        <span class="close" onclick="closeAddCategoryModal()">&times;</span>
        <h2>Add New Category</h2>
        <div class="form-group">
            <label for="newCategoryInput">Category Name</label>
            <input type="text" id="newCategoryInput" placeholder="e.g., Biology">
        </div>
        <div class="modal-actions">
            <button class="btn" onclick="saveNewCategory()">Add Category</button>
        </div>
    </div>
</div>

<div id="customPromptModal" class="modal">
    <div class="modal-content" style="max-width: 700px;">
        <span class="close" onclick="closeCustomPromptModal()">&times;</span>
        <h2>Custom AI Prompt</h2>
        <p>Enter your custom prompt below. The application will append the document content to your prompt.</p>
        <div class="form-group">
            <textarea id="customPromptTextarea" style="min-height: 250px;"></textarea>
        </div>
        <div class="modal-actions">
            <button class="btn" onclick="saveCustomPrompt()">Save Prompt</button>
        </div>
    </div>
</div>

<div id="deckSettingsModal" class="modal">
    <div class="modal-content" style="max-width: 600px;">
        <span class="close" onclick="closeDeckSettingsModal()">&times;</span>
        <h2>Deck Settings</h2>
        <div id="deckSettingsForm">
             <div class="settings-section">
                <h4>Learn Mode Options</h4>

                <div class="form-group">
                    <label for="deckSettingsCardsPerRound">Cards Per Round (Learn Mode)</label>
                    <input type="number" id="deckSettingsCardsPerRound" value="10" min="3" max="20">
                </div>
                
                <div class="settings-section">
                    <h4>Adaptive Learning</h4>
                    <fieldset class="settings-option-group">
                        <legend>Adaptive Question Formats</legend>
                        <div class="checkbox-group">
                            <input type="checkbox" id="adaptiveAutoToggle">
                            <label for="adaptiveAutoToggle">Automatic Selection (Recommended)</label>
                        </div>
                        <hr style="border: none; border-top: 1px solid var(--border-color); margin: 10px 0;">
                        <div class="checkbox-group">
                            <input type="checkbox" id="adaptiveMcqToggle">
                            <label for="adaptiveMcqToggle">Allow Multiple Choice Questions</label>
                        </div>
                        <div class="checkbox-group">
                            <input type="checkbox" id="adaptiveClozeToggle">
                            <label for="adaptiveClozeToggle">Allow Fill-in-the-blank (Cloze)</label>
                        </div>
                    </fieldset>
                </div>
                <div class="form-group">
                    <fieldset class="settings-option-group">
                        <legend>Default Study Method</legend>
                        
                        <div class="radio-option-row" onclick="document.getElementById('deckSettingsStudyModeFlashcard').checked = true;">
                            <input type="radio" id="deckSettingsStudyModeFlashcard" name="deckSettingsStudyMode" value="flashcard" checked>
                            <label for="deckSettingsStudyModeFlashcard">Flashcard Mode</label>
                        </div>
                
                        <div class="radio-option-row" onclick="document.getElementById('deckSettingsStudyModeWrite').checked = true;">
                            <input type="radio" id="deckSettingsStudyModeWrite" name="deckSettingsStudyMode" value="write">
                            <label for="deckSettingsStudyModeWrite">Type Mode</label>
                        </div>
                
                    </fieldset>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="retypeIncorrectToggle">
                    <label for="retypeIncorrectToggle">Require retyping incorrect answers</label>
                </div>
            </div>
            <div class="settings-section">
                <h4>Auto-marking (Type Mode)</h4>
                
                <h5>Auto-detection</h5><br>
                 <div class="checkbox-group">
                    <input type="checkbox" id="caseSensitiveToggle">
                    <label for="caseSensitiveToggle">Case-Sensitive Matching</label>
                </div>
                <div class="checkbox-group">
                    <input type="checkbox" id="punctuationToggle">
                    <label for="punctuationToggle">Consider Punctuation</label>
                </div>
            </div>
            <div class="settings-section">
                <h4>Review Mode</h4>
                <div class="form-group">
                     <label for="reviewOrder">Card Order</label>
                     <select id="reviewOrder">
                         <option value="random">Random</option>
                         <option value="alphabetical">Alphabetical</option>
                     </select>
                </div>
            </div>

            <div class="modal-actions" style="margin-top: 20px;">
                <button class="btn btn-secondary" onclick="closeDeckSettingsModal()">Cancel</button>
                <button class="btn btn-success" onclick="saveDeckSettings()">Save Settings</button>
            </div>
        </div>
    </div>
</div>


<div id="instructionsModal" class="modal">
    <div class="modal-content">
         <span class="close" onclick="this.parentElement.parentElement.classList.remove('show')">&times;</span>
         <h2>Keyboard Shortcuts</h2>
         <p style="text-align: left; margin-top: 20px; line-height: 1.8;">
            <b>During Simple Flashcard Mode:</b><br>
            - <b>Space / Enter</b>: Show Answer<br>
            - <b> / 2</b>: Mark as Correct<br>
            - <b> / 1</b>: Mark as Incorrect<br><br>
            <b>During Type Mode:</b><br>
            - <b>Enter / </b>: Check Answer<br>
            - <b> / 2</b>: Mark as Correct (after checking)<br>
            - <b> / 1</b>: Mark as Incorrect (after checking)<br><br>
            <b>On Progress Screen:</b><br>
            - <b>Enter</b>: Start Next Round
         </p>
    </div>
</div>

<div id="analyticsModal" class="modal">
    <div class="modal-content" style="max-width: 700px;">
        <span class="close" onclick="this.parentElement.classList.remove('show')">&times;</span>
        <h2>Analytics</h2>
        <div class="stats" style="grid-template-columns: repeat(2, 1fr); margin-bottom: 30px;">
            <div class="stat">
                <div class="stat-value" id="analyticsStreak">0 days</div>
                <div class="stat-label">Current Streak</div>
            </div>
            <div class="stat">
                <div class="stat-value" id="analyticsTotalTime">0m</div>
                <div class="stat-label">Total Study Time</div>
            </div>
        </div>
        <h4>Session History</h4>
        <div id="analyticsSessionList" style="max-height: 300px; overflow-y: auto; margin-top: 15px;">
            <p>No study sessions recorded yet.</p>
        </div>
    </div>
</div>

<script>
    pdfjsLib.GlobalWorkerOptions.workerSrc = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.11.338/pdf.worker.min.js';
    
    let toastQueue = [];
    let isToastVisible = false;
    let sortableInstance = null; 
    let documentsForAi = [];
    let isOnline = navigator.onLine;
    let db;
    let decks = {};
    let categories = ["Science", "Maths", "Language",];
    let globalSettings = {};
    let analyticsData = {
        lastUsed: null,
        streak: 0,
        totalStudyTime: 0, 
        sessions: []
    };

    let lastKnownFocusScore = 1.0;
    let focusLossStartTime = null;
    let accumulatedAwayDuration = 0; 
    let currentDeckId = null;
    let currentMode = null;
    let confirmCallback = null;
    let cardToEdit = { deckId: null, cardIndex: null, from: null };
    let aiCardToEditIndex = null;
    let studyState = {
        buckets: [],
        currentRound: 1,
        currentCardIndex: 0, 
        roundCards: [], 
        settings: {},
        lastRoundIncorrect: [],
        isRetypingIncorrect: false,
        startTime: null,
        activeLearningPool: [],
        knowledgeStates: new Map(),
        incorrectInThisRound: [],
        incorrectInThisRound: [],
        sequencePhase: 'Forward Chaining', 
        sequenceCards: [],      
        sequenceChunks: [],     
        currentChunkIndex: 0,  
        sequencePhase: null,
        preGeneratedDistractors: new Map()
    };
    const DEFAULT_DECK_SETTINGS = { learnMode: 'flashcard', reviewOrder: 'random', cardsPerRound: 10, maxBuckets: 4, caseSensitive: false, punctuation: false, retypeIncorrect: true, feedbackStyle: 'simple', forgivingAutomarking: true };
    const CURRENT_ANALYSIS_VERSION = 2; 
    const smartCoachMessages = {
        greetings: [
            "Welcome back, {username}! Ready to learn something new today?",
            "Glad to see you again, {username}! Let's build that knowledge.",
            "Let's get started, {username}! Consistency is key.",
            "A new day, a new opportunity to learn. Let's do this, {username}!"
        ],
        sessionFeedback: {
            highAccuracy: [
                "Excellent work! You achieved over 90% accuracy that round. Keep up the great momentum!",
                "Fantastic session! Your focus is clearly paying off. Well done!",
                "That was a brilliant round. You've got a strong grasp on this material."
            ],
            mediumAccuracy: [
                "Good session! You're making solid progress. Every review strengthens your memory.",
                "Nice work. You pushed through and learned a lot. Let's keep building on it.",
                "Solid effort. The tricky cards are the ones that teach us the most."
            ],
            lowAccuracy: [
                "That was a tough round, but you stuck with it. That's how real learning happens!",
                "Don't be discouraged. The most challenging sessions often lead to the biggest breakthroughs.",
                "You've laid the groundwork. The next time you see these cards, they'll be more familiar."
            ]
        },
        roundFeedback: {
                highFocus: [
                    "Excellent focus that round. Keep it up!",
                    "You're on a roll! Let's keep the momentum going.",
                    "Great work. You're building strong recall."
                ],
                mediumFocus: [
                    "Good progress. Every card is a step forward.",
                    "Nice work. Let's see what's in the next round.",
                    "You're doing great. Keep up the consistent effort."
                ],
                encouragement: [
                    "You've got this. The challenging cards are the best for learning.",
                    "Keep pushing through. This is how strong memories are built.",
                    "Don't give up. Every review makes the next one easier."
                ]
            },
        milestones: {
            streak: [
                "You're on a {streak}-day streak! Amazing consistency, {username}!",
                "That's a {streak}-day streak! You're building a powerful learning habit."
            ],
            deckMastered: [
                "Incredible! You've mastered every card in the '{deckName}' deck. That's a huge achievement!",
                "Congratulations! You've officially mastered the '{deckName}' deck. Time to celebrate!"
            ],
            cardsMastered: [
                "Big milestone! You've now mastered over {count} cards in this deck. Your knowledge is growing!",
                "You just crossed the {count}-card mastery threshold in this deck. Fantastic progress!"
            ]
        }
    };

    let editorCardCounter = 0;
    let currentViewingDeckId = null;
    let activeView = 'dashboard';
    let viewHistory = [];

    class SM2Algorithm {
        constructor() {
            this.defaultInterval = 1;
            this.defaultFactor = 2.5;
        }

        calculateNextReview(card) {
            const now = new Date();
            
            if (!card.sm2Data) {
                card.sm2Data = {
                    interval: 0,
                    factor: this.defaultFactor,
                    repetition: 0,
                    dueDate: now.toISOString()
                };
            }
            
            const data = card.sm2Data;
            
            return function(quality) { 
                if (quality >= 3) { 
                    if (data.repetition === 0) {
                        data.interval = 1;
                    } else if (data.repetition === 1) {
                        data.interval = 6;
                    } else {
                        data.interval = Math.round(data.interval * data.factor);
                    }
                    data.repetition++;
                } else { 
                    data.repetition = 0;
                    data.interval = 1;
                }
                
                data.factor = data.factor + (0.1 - (5 - quality) * (0.08 + (5 - quality) * 0.02));
                if (data.factor < 1.3) data.factor = 1.3;
                
                const dueDate = new Date();
                dueDate.setDate(dueDate.getDate() + data.interval);
                data.dueDate = dueDate.toISOString();
                
                return data;
            };
        }
    }

    let practiceTestState = {
        deckId: null,
        cards: [],
        currentCardIndex: 0,
        correctCount: 0,
        incorrectCount: 0,
        startTime: null,
        testType: 'flashcard',
        numQuestions: 10
    };

    window.onload = function() {
        initDB().then(() => {
            loadSavedData();
            setupEventListeners();
            showView('dashboard', true);
            updateOnlineStatusUI();
        }).catch(error => {
            console.error("Failed to initialize the database:", error);
            showToast("Could not start the application. Database initialization failed.", "error");
        });
    };
    
    function initDB() {
        return new Promise((resolve, reject) => {
            const request = indexedDB.open('LagioteDB', 5);

            request.onerror = event => reject("Error opening DB: " + event.target.errorCode);
            
            request.onsuccess = event => {
                db = event.target.result;
                resolve();
            };

            request.onupgradeneeded = event => {
                db = event.target.result;
                const transaction = event.target.transaction;

                if (!db.objectStoreNames.contains('decks')) {
                    db.createObjectStore('decks', { keyPath: 'id' });
                }
                if (!db.objectStoreNames.contains('appData')) {
                    db.createObjectStore('appData', { keyPath: 'key' });
                }
                if (!db.objectStoreNames.contains('concepts')) {
                    db.createObjectStore('concepts', { keyPath: 'conceptID' });
                }
                if (!db.objectStoreNames.contains('userKnowledgeState')) {
                    db.createObjectStore('userKnowledgeState', { keyPath: ['userID', 'cardID'] });
                }
                if (!db.objectStoreNames.contains('interactionLogs')) {
                    const logStore = db.createObjectStore('interactionLogs', { keyPath: 'id', autoIncrement: true });
                    logStore.createIndex('by_cardID', 'cardID', { unique: false });
                    logStore.createIndex('by_timestamp', 'timestamp', { unique: false });
                    console.log("Created 'interactionLogs' object store.");
                }

                if (event.oldVersion > 0 && event.oldVersion < 5) {
                    console.log("Starting database migration for cognitive engine...");
                    const deckStore = transaction.objectStore('decks');
                    const stateStore = transaction.objectStore('userKnowledgeState');

                    deckStore.getAll().onsuccess = (e) => {
                        const allDecks = e.target.result;
                        if (!allDecks) return;

                        allDecks.forEach(deck => {
                            let deckNeedsUpdate = false;
                            deck.cards.forEach(card => {
                                if (typeof card.masteryScore === 'undefined') {
                                    deckNeedsUpdate = true;
                                    stateStore.put({
                                        userID: 'default_user', 
                                        cardID: card.id, 
                                        masteryScore: 0.5, 
                                        stability: 1.0, 
                                        lastReviewed: new Date().toISOString(),
                                        recallHistory: []
                                    });
                                }
                            });
                            if (deckNeedsUpdate) {
                                deckStore.put(deck);
                            }
                        });
                        console.log("Cognitive engine migration complete.");
                    };
                }
            };
        });
    }

    let currentInteractionLog = {};

    function startInteractionLog(cardID) {
        currentInteractionLog = {
            cardID: cardID,
            questionLoadTime: performance.now(),
            firstKeyPressTime: null,
            backspaceCount: 0,
            deleteCount: 0,
            attemptCount: (studyState.isRetypingIncorrect ? 2 : 1),
            awayDuration: accumulatedAwayDuration
        };
        
        accumulatedAwayDuration = 0;
    }


    function handleInteractionLogging(e) {
        if (currentInteractionLog.firstKeyPressTime === null && e.key.length === 1) {
            currentInteractionLog.firstKeyPressTime = performance.now();
        }

        if (e.key === 'Backspace') {
            currentInteractionLog.backspaceCount++;
        } else if (e.key === 'Delete') {
            currentInteractionLog.deleteCount++;
        }
    }
    
    async function logInteraction(logData) {
        if (!db) {
            console.error("Database not available for logging interaction.");
            return;
        }

        try {
            const transaction = db.transaction(['interactionLogs'], 'readwrite');
            const store = transaction.objectStore('interactionLogs');
            
            const logEntry = {
                userID: 'default_user', 
                cardID: logData.cardID,
                timestamp: new Date().toISOString(),
                wasCorrect: logData.wasCorrect,
                latency: logData.recallLatency,
                fluency: logData.answerFluency,
                corrections: logData.totalCorrections,
                attempts: logData.attemptCount,
                userAnswer: logData.userAnswer,
                questionType: logData.questionType || 'Flashcard',
                synced: false 
            };
            
            store.add(logEntry);

            transaction.onerror = (event) => {
                console.error("Error saving interaction log to IndexedDB:", event.target.error);
            };
        } catch (error) {
            console.error("Failed to initiate IndexedDB transaction for logging:", error);
        }


        try {
            const backendUrl = 'http://localhost:3000/api/log/interaction'; // Your local backend URL
            
            const response = await fetch(backendUrl, {
                method: 'POST',
                headers: {
                    'Content-Type': 'application/json',
                },
                body: JSON.stringify({
                    userID: 'default_user',
                    cardID: logData.cardID,
                    timestamp: new Date().toISOString(),
                    wasCorrect: logData.wasCorrect,
                    recallLatency: logData.recallLatency,
                    answerFluency: logData.answerFluency,
                    totalCorrections: logData.totalCorrections,
                    attemptCount: logData.attemptCount,
                    userAnswer: logData.userAnswer
                }),
                signal: AbortSignal.timeout(5000) 
            });

            if (!response.ok) {
                // The server responded with an error (e.g., 400, 500)
                console.warn(`Backend logging failed with status: ${response.status}`);
            } else {

            }
        } catch (error) {
            // This block will catch network errors (e.g., user is offline, server is down)
            if (error.name === 'AbortError') {
                console.warn('Backend logging timed out.');
            } else {
                console.warn('Could not send log to backend. User might be offline.', error);
            }
        }
    }

        let chartInstances = {};

        async function showInternalAnalytics() {
            showView('internalAnalyticsView');

            try {
                const [allLogs, allKnowledgeStates] = await Promise.all([
                    getAllDataFromDB('interactionLogs'),
                    getAllDataFromDB('userKnowledgeState')
                ]);

                // Check if logs exist before proceeding
                if (!allLogs || allLogs.length === 0) {
                    console.warn("No interaction logs found to generate analytics.");
                    document.getElementById('latencyHistogram').parentNode.innerHTML = '<p style="text-align: center; color: var(--secondary-text);">No interaction data available yet.</p>';
                    document.getElementById('fluencyHistogram').parentNode.innerHTML = '<p style="text-align: center; color: var(--secondary-text);">No interaction data available yet.</p>';
                    document.getElementById('correctionsHistogram').parentNode.innerHTML = '<p style="text-align: center; color: var(--secondary-text);">No interaction data available yet.</p>';
                    document.getElementById('latencyScatterPlot').parentNode.innerHTML = '<p style="text-align: center; color: var(--secondary-text);">No interaction data available yet.</p>';
                    document.getElementById('deckStatisticsResult').innerHTML = '<p>No interaction data available yet.</p>';
                    return;
                }

                renderHistograms(allLogs);
                renderLatencyScatterPlot(allLogs);
                renderInteractionsTimeSeries(allLogs);

                setupErrorAnalysisAndDeckStats(allLogs, allKnowledgeStates);

            } catch (error) {
                console.error("Failed to fetch data for analytics:", error);
                // Optionally display a more user-friendly error message
                showToast("Error loading analytics data. Please try again later.", "error");
            }
        }

        function generateDeckStatistics(deckId, allLogs, allKnowledgeStates) {
            console.log('[Test 1] Raw data from DB:', allKnowledgeStates);
            const resultContainer = document.getElementById('deckStatisticsResult');
            const selectedDeck = decks[deckId];

            if (!selectedDeck) {
                resultContainer.innerHTML = '<p>Please select a deck to see a breakdown of its flashcard statistics.</p>';
                return;
            }

            const knowledgeMap = new Map(allKnowledgeStates.map(item => [String(item.cardID), item]));
            
            const isSequence = selectedDeck.typeHint === 'Sequence';

            const cardStats = selectedDeck.cards.map(card => {
                const knowledgeState = knowledgeMap.get(String(card.id));
                console.log(`[Test 2] Lookup for card ID ${card.id}:`, knowledgeState);
                const logsForCard = allLogs.filter(log => String(log.cardID) === String(card.id));
                const correctLogs = logsForCard.filter(log => log.wasCorrect);
                const totalInteractions = logsForCard.length;
                const correctCount = correctLogs.length;

                let averageIQS = 0;
                if (correctCount > 0) {
                    const totalIQS = correctLogs.reduce((sum, log) => {
                        const iqs = calculateIQS({
                            recallLatency: log.latency || 2000,
                            answerFluency: log.fluency || 5,
                            totalCorrections: log.corrections || 0,
                            attemptCount: log.attempts || 1
                        });
                        return sum + iqs;
                    }, 0);
                    averageIQS = totalIQS / correctCount;
                }

                return {
                    question: card.question,
                    totalInteractions: totalInteractions,
                    correctPercentage: totalInteractions > 0 ? (correctCount / totalInteractions) * 100 : 0,
                    avgIQS: averageIQS,
                    stability: knowledgeState?.stability, 
                    masteryScore: knowledgeState?.masteryScore, 
                    lastReviewed: knowledgeState?.lastReviewed ? new Date(knowledgeState.lastReviewed).toLocaleDateString() : 'Never',
                    order: card.order || Infinity 
                };
                console.log('[Test 3] Final calculated stat object:', stat);
            });
            
            if (cardStats.length === 0) {
                resultContainer.innerHTML = '<p>This deck has no cards.</p>';
                return;
            }

            const cardsForStats = isSequence 
                ? [...cardStats].sort((a, b) => a.order - b.order) 
                : cardStats;

            let tableHTML = `
                <table class="stats-table">
                    <thead>
                        <tr>
                            ${isSequence ? '<th>Order</th>' : ''}
                            <th>Question</th>
                            <th>Correct %</th>
                            <th>Avg. IQS</th>
                            <th>Stability</th>
                            <th>Mastery</th>
                            <th>Last Reviewed</th>
                            <th>Interactions</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            
            cardsForStats.forEach(stat => {
                const stabilityText = typeof stat.stability === 'number' ? stat.stability.toFixed(2) : 'N/A';
                const masteryText = typeof stat.masteryScore === 'number' ? stat.masteryScore.toFixed(2) : 'N/A';

                tableHTML += `
                    <tr>
                        ${isSequence ? `<td>${stat.order}</td>` : ''}
                        <td title="${stat.question}">${stat.question}</td>
                        <td>${stat.correctPercentage.toFixed(1)}%</td>
                        <td>${(stat.avgIQS).toFixed(2)}</td>
                        <td>${stabilityText}</td>
                        <td>${masteryText}</td>
                        <td>${stat.lastReviewed}</td>
                        <td>${stat.totalInteractions}</td>
                    </tr>
                `;
            });

            tableHTML += '</tbody></table>';
            resultContainer.innerHTML = tableHTML;
        }

        function renderHistograms(logs) {
            const latencies = logs.map(log => log.latency).filter(l => l !== null);
            const fluencies = logs.map(log => log.fluency).filter(f => f > 0);
            const corrections = logs.map(log => log.corrections);

            createBarChart('latencyHistogram', 'Recall Latency', latencies, 'rgba(102, 126, 234, 0.6)');
            createBarChart('fluencyHistogram', 'Answer Fluency', fluencies, 'rgba(56, 178, 172, 0.6)');
            createBarChart('correctionsHistogram', 'Corrections Count', corrections, 'rgba(229, 62, 62, 0.6)');
        }

        function createBarChart(canvasId, label, data, color) {
            if (chartInstances[canvasId]) chartInstances[canvasId].destroy();
            
            const ctx = document.getElementById(canvasId).getContext('2d');
            
            const valueCounts = data.reduce((acc, value) => {
                acc[value] = (acc[value] || 0) + 1;
                return acc;
            }, {});
            const labels = Object.keys(valueCounts).sort((a, b) => a - b);
            const chartData = labels.map(key => valueCounts[key]);

            chartInstances[canvasId] = new Chart(ctx, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: `Frequency of ${label}`,
                        data: chartData,
                        backgroundColor: color,
                        borderColor: color.replace('0.6', '1'),
                        borderWidth: 1
                    }]
                },
                options: { scales: { y: { beginAtZero: true } } }
            });
        }

        function renderLatencyScatterPlot(logs) {
            const canvasId = 'latencyScatterPlot';
            if (chartInstances[canvasId]) chartInstances[canvasId].destroy();

            const data = logs.filter(log => log.latency !== null && log.wasCorrect !== undefined).map(log => ({
                x: log.latency,
                y: log.wasCorrect ? 1 + (Math.random() * 0.1 - 0.05) : 0 + (Math.random() * 0.1 - 0.05) // Add jitter
            }));

            if (data.length === 0) {
                const ctx = document.getElementById(canvasId).getContext('2d');
                chartInstances[canvasId] = new Chart(ctx, {
                    type: 'scatter',
                    data: { datasets: [] },
                    options: {
                        plugins: {
                            legend: { display: false },
                            tooltip: { enabled: false }
                        },
                        scales: {
                            x: { title: { display: true, text: 'Recall Latency (ms)' } },
                            y: {
                                title: { display: true, text: 'Outcome' },
                                ticks: { callback: (value) => value === 1 ? 'Correct' : (value === 0 ? 'Incorrect' : '') },
                                min: -0.2, max: 1.2
                            }
                        }
                    }
                });
                document.getElementById(canvasId).parentNode.innerHTML += '<p style="text-align: center; color: var(--secondary-text); margin-top: 10px;">No data available for scatter plot.</p>';
                return;
            }

            const ctx = document.getElementById(canvasId).getContext('2d');
            chartInstances[canvasId] = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: 'User Interaction',
                        data: data,
                        backgroundColor: (context) => {
                            if (!context.raw) return 'rgba(0,0,0,0)';
                            // Check if 'y' property exists before accessing it
                            const outcome = typeof context.raw.y !== 'undefined' ? context.raw.y : 0; 
                            return outcome > 0.5 ? 'rgba(56, 178, 172, 0.7)' : 'rgba(229, 62, 62, 0.7)';
                        },
                    }]
                },
                options: {
                    scales: {
                        x: { title: { display: true, text: 'Recall Latency (ms)' } },
                        y: {
                            title: { display: true, text: 'Outcome' },
                            ticks: {
                                callback: (value) => value === 1 ? 'Correct' : (value === 0 ? 'Incorrect' : '')
                            },
                            min: -0.2, max: 1.2
                        }
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.raw.y > 0.5) {
                                        label += 'Correct';
                                    } else {
                                        label += 'Incorrect';
                                    }
                                    label += ` (Latency: ${context.raw.x}ms)`;
                                    return label;
                                }
                            }
                        }
                    }
                }
            });
        }


        function renderInteractionsTimeSeries(logs) {
            const canvasId = 'interactionsTimeSeries';
            if (chartInstances[canvasId]) chartInstances[canvasId].destroy();

            const interactionsByDay = logs.reduce((acc, log) => {
                const day = new Date(log.timestamp).toISOString().split('T')[0];
                acc[day] = (acc[day] || 0) + 1;
                return acc;
            }, {});

            const sortedDays = Object.keys(interactionsByDay).sort();
            const chartLabels = sortedDays;
            const chartData = sortedDays.map(day => interactionsByDay[day]);

            const ctx = document.getElementById(canvasId).getContext('2d');
            chartInstances[canvasId] = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: chartLabels,
                    datasets: [{
                        label: 'Number of Interactions',
                        data: chartData,
                        fill: false,
                        borderColor: 'rgba(102, 126, 234, 1)',
                        tension: 0.1
                    }]
                }
            });
        }

        function setupErrorAnalysisAndDeckStats(allLogs, allKnowledgeStates) {
            const deckSelect = document.getElementById('errorDeckSelect');
            const cardSelect = document.getElementById('errorCardSelect');

            deckSelect.innerHTML = '<option value="">-- Select a Deck --</option>';
            Object.values(decks).forEach(deck => {
                const option = document.createElement('option');
                option.value = deck.id;
                option.textContent = deck.name;
                deckSelect.appendChild(option);
            });
            
            deckSelect.onchange = () => {
                const deckId = deckSelect.value;
                const selectedDeck = decks[deckId]; 

                cardSelect.innerHTML = '<option value="">-- Select a Card --</option>';
                if (deckId && selectedDeck) {
                    const cardsToDisplay = selectedDeck.typeHint === 'Sequence' 
                        ? [...selectedDeck.cards].sort((a, b) => a.order - b.order) 
                        : selectedDeck.cards;

                    cardsToDisplay.forEach(card => {
                        const option = document.createElement('option');
                        option.value = card.id;
                        const orderPrefix = selectedDeck.typeHint === 'Sequence' ? `[#${card.order}] ` : '';
                        option.textContent = orderPrefix + card.question.substring(0, 50) + '...';
                        cardSelect.appendChild(option);
                    });
                }
                generateErrorAnalysisReport(allLogs, null); 

                generateDeckStatistics(deckId, allLogs, allKnowledgeStates); 
            };

            cardSelect.onchange = () => {
                generateErrorAnalysisReport(allLogs, cardSelect.value);
            };

            generateDeckStatistics(null, allLogs, allKnowledgeStates);
        }

        function generateErrorAnalysisReport(logs, cardId) {
            const resultContainer = document.getElementById('errorAnalysisResult');
            if (!cardId) {
                resultContainer.innerHTML = '<p>Please select a card to see a breakdown of common incorrect answers.</p>';
                return;
            }

            const incorrectAnswers = logs
                .filter(log => log.cardID == cardId && !log.wasCorrect)
                .map(log => log.userAnswer.trim().toLowerCase());

            if (incorrectAnswers.length === 0) {
                resultContainer.innerHTML = '<p>No incorrect answers have been logged for this card yet.</p>';
                return;
            }

            const answerCounts = incorrectAnswers.reduce((acc, answer) => {
                acc[answer] = (acc[answer] || 0) + 1;
                return acc;
            }, {});

            const sortedAnswers = Object.entries(answerCounts).sort(([, a], [, b]) => b - a);

            let tableHTML = `
                <table style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr>
                            <th style="text-align: left; padding: 8px; border-bottom: 1px solid var(--border-color);">Incorrect Answer</th>
                            <th style="text-align: right; padding: 8px; border-bottom: 1px solid var(--border-color);">Frequency</th>
                        </tr>
                    </thead>
                    <tbody>
            `;
            sortedAnswers.forEach(([answer, count]) => {
                tableHTML += `
                    <tr>
                        <td style="padding: 8px; border-bottom: 1px solid var(--border-color);">${answer}</td>
                        <td style="text-align: right; padding: 8px; border-bottom: 1px solid var(--border-color);">${count}</td>
                    </tr>
                `;
            });
            tableHTML += '</tbody></table>';

            resultContainer.innerHTML = tableHTML;
        }
    
    async function saveDataToDB(storeName, data) {
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            const request = store.put(data);
            request.onsuccess = () => resolve();
            request.onerror = event => reject("Error saving data: " + event.target.error);
        });
    }

    async function getDataFromDB(storeName, key) {
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.get(key);
            request.onsuccess = event => resolve(event.target.result);
            request.onerror = event => reject("Error getting data: " + event.target.error);
        });
    }

    async function getAllDataFromDB(storeName) {
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([storeName], 'readonly');
            const store = transaction.objectStore(storeName);
            const request = store.getAll();
            request.onsuccess = event => resolve(event.target.result);
            request.onerror = event => reject("Error getting all data: " + event.target.error);
        });
    }
    
    async function deleteDataFromDB(storeName, key) {
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            const request = store.delete(key);
            request.onsuccess = () => resolve();
            request.onerror = (event) => reject("Error deleting data: " + event.target.error);
        });
    }
    
    async function clearStoreInDB(storeName) {
        return new Promise((resolve, reject) => {
            const transaction = db.transaction([storeName], 'readwrite');
            const store = transaction.objectStore(storeName);
            const request = store.clear();
            request.onsuccess = () => resolve();
            request.onerror = event => reject("Error clearing store: " + event.target.error);
        });
    }


    function setupEventListeners() {
        setupSearch();
        setupKeyboardControls();        
        document.getElementById('deckDetailTestBtn').addEventListener('click', () => openPracticeTestModal(currentViewingDeckId));
        document.getElementById('deckDetailEditBtn').addEventListener('click', () => editDeck(currentViewingDeckId));
        document.getElementById('deckDetailDeleteBtn').addEventListener('click', () => deleteDeck(currentViewingDeckId));
        document.getElementById('deckDetailSettingsBtn').addEventListener('click', () => openDeckSettingsModal(currentViewingDeckId));
        document.getElementById('headerBackBtn').addEventListener('click', goBack);
        document.getElementById('nameForm').addEventListener('submit', saveName);
        document.getElementById('darkModeToggle').addEventListener('change', toggleDarkMode);
        document.getElementById('continueBtn').addEventListener('click', continueStudy);
        document.getElementById('instructionsBtn').addEventListener('click', () => document.getElementById('instructionsModal').classList.add('show'));
        document.getElementById('accentToggleBtn').addEventListener('click', toggleAccentButtons);
        document.getElementById('testAccentToggleBtn').addEventListener('click', toggleTestAccentButtons);
        document.getElementById('switchStudyModeBtn').addEventListener('click', toggleStudyMode);
        document.getElementById('editStudyCardBtn').addEventListener('click', editCurrentStudyCard);
        document.getElementById('writeAnswerInput').addEventListener('keydown', (e) => {
            if ((e.key === 'Enter' && !e.shiftKey) || e.key === 'ArrowUp') {
                e.preventDefault();
                e.stopPropagation();
                const writeInput = document.getElementById('writeAnswerInput');
                const checkAnswerBtnVisible = !document.getElementById('checkAnswerBtn').classList.contains('hidden');
                if (!checkAnswerBtnVisible || writeInput.disabled) return;
                if (writeInput.value.trim() === '') {
                    showToast('Please enter an answer', 'error');
                    return;
                }
                autoCheckAnswer();
            }
        });
        document.addEventListener('keydown', function(event) {
            if (event.key === 'Escape') {
                // Find any visible modal and close it
                const visibleModal = document.querySelector('.modal.show');
                if (visibleModal) {
                    visibleModal.classList.remove('show');
                }
            }
        });
        document.addEventListener('visibilitychange', () => {
            if (document.hidden) {
                focusLossStartTime = Date.now();
            } else {
                if (focusLossStartTime) {
                    const awayDuration = Date.now() - focusLossStartTime;
                    accumulatedAwayDuration += awayDuration;
                    focusLossStartTime = null; 
                }
            }
        });
        document.getElementById('flashcardsContainer').addEventListener('keydown', function(event) {
            if (event.key === 'Tab' && !event.shiftKey) {
                const activeElement = document.activeElement;
                if (activeElement.classList.contains('solution-input')) {
                    const cardRow = activeElement.closest('.flashcard-editor-row');
                    if (cardRow === this.lastElementChild) {
                        event.preventDefault();
                        editorAddNewCard(); 
                    }
                }
            }
        });
        document.addEventListener('keydown', function(event) {
            const practiceTestView = document.getElementById('practiceTestView');
            if (practiceTestView.classList.contains('hidden')) {
                return;
            }

            if (event.key === 'Enter'|| 'ArrowUp') {
                const nextBtn = document.getElementById('testNextBtn');
                const checkBtn = document.getElementById('testCheckAnswerBtn');
                const showAnswerBtn = document.getElementById('testShowAnswerBtn');
                if (!nextBtn.classList.contains('hidden')) {
                    event.preventDefault();
                    nextBtn.click();
                }
                else if (!checkBtn.classList.contains('hidden')) {
                    if(event.target === document.getElementById('testAnswerInput')){
                        event.preventDefault();
                    }
                    checkBtn.click();
                }
                else if (!showAnswerBtn.classList.contains('hidden')) {
                    event.preventDefault();
                    showAnswerBtn.click();
                }
            }
        });
        document.getElementById('testInstructionsBtn').addEventListener('click', () => {
            showToast("Practice test instructions would appear here", "info");
        });

        ['deckCategory'].forEach(id => {
            document.getElementById(id).addEventListener('change', handleCategoryChange);
        });

        document.getElementById('importFileInput').addEventListener('change', function() {
            const fileNameDisplay = document.getElementById('fileNameDisplay');
            if (this.files.length > 0) {
                fileNameDisplay.textContent = this.files[0].name;
            } else {
                fileNameDisplay.textContent = 'No file chosen';
            }
        });
        document.getElementById('writeAnswerInput').addEventListener('keydown', handleInteractionLogging);

        window.addEventListener('online', () => {
                isOnline = true;
                updateOnlineStatusUI();
                showToast('You are back online! Smart features are enabled.', 'success');
            });

        window.addEventListener('offline', () => {
            isOnline = false;
            updateOnlineStatusUI();
            showToast('You are offline. AI features will be disabled.', 'error');
        });
        
        const dropZone = document.getElementById('file-drop-zone');
        const fileInput = document.getElementById('file-input');
        const selectFileBtn = document.getElementById('select-file-btn');

        dropZone.addEventListener('dragover', (e) => { e.preventDefault(); dropZone.classList.add('dragover'); });
        dropZone.addEventListener('dragleave', () => dropZone.classList.remove('dragover'));
        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.classList.remove('dragover');
            handleAiFiles(e.dataTransfer.files);
        });
        selectFileBtn.addEventListener('click', () => fileInput.click());
        fileInput.addEventListener('change', () => handleAiFiles(fileInput.files));
        document.getElementById('add-text-btn').addEventListener('click', addTextAsDocument);
        document.getElementById('process-btn').addEventListener('click', processAllDocuments);
    }
    
    function showToast(message, type = 'info', duration = 3000, icon = null) {
        if (globalSettings.enableToasts === false) {
            return;
        }
        toastQueue.push({ message, type, duration, icon }); 
        if (!isToastVisible) {
            processToastQueue();
        }
    }

    function processToastQueue() {
        if (toastQueue.length === 0) {
            isToastVisible = false;
            return;
        }

        isToastVisible = true;
        
        const toastData = toastQueue.shift();

        const toastElement = document.getElementById('dynamicToast');

        let toastContent = '';
        if (toastData.icon) {
            toastContent += `<div style="width: 20px; height: 20px;">${toastData.icon}</div>`;
        }
        toastContent += `<span>${toastData.message}</span>`;
        toastElement.innerHTML = toastContent;
        
        toastElement.className = `toast ${toastData.type}`; 
        setTimeout(() => toastElement.classList.add('show'), 10);

        setTimeout(() => {
            toastElement.classList.remove('show');
            
            setTimeout(() => {
                processToastQueue();
            }, 500); 
        }, toastData.duration);
    }

    async function runSmartCoachChecks(context, data = {}) {
        let messageShown = false;

        const showRandomMessage = (messageArray, replacements = {}, type = 'info', icon = null) => {
            if (messageShown) return;
            let message = messageArray[Math.floor(Math.random() * messageArray.length)];
            for (const key in replacements) {
                message = message.replace(`{${key}}`, replacements[key]);
            }
            showToast(message, type, 5000, icon); // The icon will be null
            messageShown = true;
        };

        switch (context) {
            case 'dashboardLoad':
                const today = new Date().toDateString();
                if (analyticsData.lastGreetingDate !== today) {
                    if (analyticsData.streak > 1) {
                        // Emoji '' removed from this call
                        showRandomMessage(smartCoachMessages.milestones.streak, { streak: analyticsData.streak, username: globalSettings.username }, 'success');
                    } else {
                        // Emoji '' removed from this call
                        showRandomMessage(smartCoachMessages.greetings, { username: globalSettings.username }, 'info');
                    }
                    analyticsData.lastGreetingDate = today;
                    await saveDataToDB('appData', { key: 'analytics', ...analyticsData });
                }
                break;

            case 'sessionEnd':
                const { deckId, correctCount, incorrectCount } = data;
                const deck = decks[deckId];
                const totalAnswered = correctCount + incorrectCount;
                if (totalAnswered === 0) return;

                const knowledgeStates = await getAllDataFromDB('userKnowledgeState');
                const cardIdsInDeck = new Set(deck.cards.map(c => c.id));
                const masteredCount = knowledgeStates.filter(s => cardIdsInDeck.has(s.cardID) && s.masteryScore >= 0.95).length;

                if (masteredCount === deck.cards.length) {
                    showRandomMessage(smartCoachMessages.milestones.deckMastered, { deckName: deck.name }, 'success');
                    break;
                }
                
                const masteryThresholds = [50, 25, 10];
                for (const threshold of masteryThresholds) {
                    if (data.masteryCountBefore < threshold && masteredCount >= threshold) {
                        showRandomMessage(smartCoachMessages.milestones.cardsMastered, { count: threshold }, 'success');
                        break;
                    }
                }
                if (messageShown) break;

                const accuracy = totalAnswered > 0 ? correctCount / totalAnswered : 0;
                if (accuracy >= 0.9) {
                    showRandomMessage(smartCoachMessages.sessionFeedback.highAccuracy, {}, 'success');
                } else if (accuracy >= 0.6) {
                    showRandomMessage(smartCoachMessages.sessionFeedback.mediumAccuracy, {}, 'info');
                } else {
                    showRandomMessage(smartCoachMessages.sessionFeedback.lowAccuracy, {}, 'info');
                }
                break;
        }
    }

    function showView(viewId, isInitial = false, callback = null) {
        if (activeView === 'editorView' && !isEditorClean() && viewId !== 'editorView') {
            showConfirmModal(
                'You have unsaved changes. Are you sure you want to leave?',
                () => transitionView(viewId, isInitial, callback)
            );
            return;
        }

        if (activeView === viewId && !isInitial) {
            if (callback) {
                callback();
            }
            return; 
        }
        
            transitionView(viewId, isInitial, callback);
        }
    
    function transitionView(viewId, isInitial = false, callback = null) {
        if (!isInitial && activeView !== viewId && viewId !=='dashboard') {
            if(viewHistory[viewHistory.length-1] !== activeView) {
                    viewHistory.push(activeView);
            }
        }
        
        const currentView = document.getElementById(activeView);
        const nextView = document.getElementById(viewId);
        
        const isDashboard = viewId === 'dashboard';
        document.querySelector('.search-bar').style.display = isDashboard ? 'flex' : 'none';
        document.getElementById('headerSettingsBtn').style.display = isDashboard ? 'flex' : 'none';
        document.getElementById('headerBackBtn').classList.toggle('hidden', viewHistory.length === 0 || isDashboard);
        
        document.getElementById('headerHomeBtn').classList.toggle('hidden', isDashboard);

        if (isInitial) {
            if(currentView) currentView.classList.remove('fade-in', 'fade-out', 'animating');
            nextView.classList.add('fade-in', 'animating');
            activeView = viewId;
            if (callback) callback(); 
            return;
        }

        if (currentView) {
            currentView.classList.add('fade-out', 'animating');
            currentView.classList.remove('fade-in');
            
            setTimeout(() => {
                currentView.style.display = 'none';
                currentView.classList.remove('fade-out', 'animating');
                nextView.style.display = 'block';
                nextView.classList.add('fade-in', 'animating');
                activeView = viewId;
                window.scrollTo(0, 0);
                if (callback) callback(); 
            }, 400); 
        }
    }
    
    function transitionSubView(currentElem, nextElem) {
        if (currentElem && !currentElem.classList.contains('hidden')) {
            currentElem.classList.add('sub-view-fade-out', 'animating');
            setTimeout(() => {
                currentElem.classList.add('hidden');
                currentElem.classList.remove('sub-view-fade-out', 'animating');
                if (nextElem) {
                    nextElem.classList.remove('hidden');
                    nextElem.classList.add('sub-view-fade-in', 'animating');
                }
            }, 400);
        } else if (nextElem) {
            nextElem.classList.remove('hidden');
            nextElem.classList.add('sub-view-fade-in', 'animating');
        }
    }

    function goBack() {
        if (activeView === 'editorView' && !isEditorClean()) {
            showConfirmModal(
                'You have unsaved changes. Are you sure you want to leave?',
                () => continueGoBack()
            );
        } else {
            continueGoBack();
        }
    }

    function continueGoBack() {
         const previousView = viewHistory.pop();
        if (previousView) {
            transitionView(previousView);
        } else {
             backToDashboard(true);
        }
    }

    function showEditor() { showView('editorView'); editorInitialize(); }

    async function showSettings() {
        const settings = await getDataFromDB('appData', 'userSettings');
         document.getElementById('usernameInput').value = settings?.username || '';
         document.getElementById('enableInStudyEditing').checked = settings?.enableInStudyEditing || false;
         
         showView('settingsView');
    }

    async function backToDashboard(isFromLogo = false) {
        if (activeView === 'editorView' && !isEditorClean()) {
            showConfirmModal(
                'You have unsaved changes. Are you sure you want to leave?',
                () => { 
                    transitionView('dashboard'); 
                    // After confirming, we still need to reset the dashboard state.
                    if (currentDeckId && currentMode) endSession();
                    resetDashboardState(true); // Call our new helper
                }
            );
            return;
        }

        if (activeView !== 'dashboard') {
            if (currentDeckId && currentMode) await endSession();
            showView('dashboard', false, () => resetDashboardState(isFromLogo));
        } else {
            resetDashboardState(isFromLogo);
        }
    }

    function resetDashboardState(clearHistory = false) {
        document.getElementById('deckDetailView').classList.add('hidden');
        document.getElementById('decksSection').classList.remove('hidden');
        document.querySelector('.create-section').classList.remove('hidden');
        
        currentViewingDeckId = null;
        updateDashboard(); 
        
        if (clearHistory) {
            viewHistory = [];
        }
        
        document.getElementById('headerBackBtn').classList.toggle('hidden', viewHistory.length === 0);
    }
    
    async function loadSavedData() {
        const settings = await getDataFromDB('appData', 'userSettings');
        globalSettings = settings || {};
        globalSettings.newCardsPerDay = globalSettings.newCardsPerDay || 20;

        if (globalSettings.username) {
            document.getElementById('welcomeMessage').textContent = `Welcome back, ${globalSettings.username}!`;
            checkName();
        } else {
            document.getElementById('nameModal').classList.add('show');
        }
        
        const savedCategories = await getDataFromDB('appData', 'categories');
        if(savedCategories) categories = savedCategories.data;
        populateCategoryDropdowns();
        
        const savedDecks = await getAllDataFromDB('decks');
        decks = {};
        const sm2 = new SM2Algorithm();
        savedDecks.forEach(deck => {
            deck.cards.forEach(card => {
                if (!card.sm2Data) {
                    card.sm2Data = sm2.calculateNextReview(card)(3); 
                }
            });
            decks[deck.id] = deck;
        });
        
        const savedAnalytics = await getDataFromDB('appData', 'analytics');
        if (savedAnalytics) analyticsData = savedAnalytics;
        updateStreak();

        if (globalSettings.darkMode) {
            document.body.classList.add('dark-mode');
            document.getElementById('darkModeToggle').checked = true;
        }
        await checkForOutdatedAnalysis();
        await updateDashboard();
        runSmartCoachChecks('dashboardLoad');
    }

    function formatDate(isoString) {
        if (!isoString) return '';
        const date = new Date(isoString);
        return date.toLocaleDateString('en-US', { year: 'numeric', month: 'long', day: 'numeric' });
    }
    
    async function exportDeck(deckId, event) {
            event.stopPropagation();
            const deck = decks[deckId];
            if (!deck) return;
            showToast('Preparing complete export...', 'info', 2000);

            const allKnowledgeStates = await getAllDataFromDB('userKnowledgeState');
            const cardIdsInDeck = new Set(deck.cards.map(c => c.id));
            
            const knowledgeStateForDeck = allKnowledgeStates.filter(state => cardIdsInDeck.has(state.cardID));

            const exportPayload = {
                deck: JSON.parse(JSON.stringify(deck)), 
                knowledgeStateData: knowledgeStateForDeck
            };

            const dataStr = JSON.stringify(exportPayload, null, 2); 
            const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
            const exportFileDefaultName = `${deck.name.replace(/ /g, '_')}_export.json`;
            
            const linkElement = document.createElement('a');
            linkElement.setAttribute('href', dataUri);
            linkElement.setAttribute('download', exportFileDefaultName);
            linkElement.click();
            
            showToast('Complete export started successfully!');
        }

    async function updateDashboard() {
        const knowledgeStates = await getAllDataFromDB('userKnowledgeState');
        const knowledgeMap = new Map(knowledgeStates.map(item => [item.cardID, item]));

        const decksContainer = document.getElementById('decksContainer');
        const deckCount = Object.keys(decks).length;
        const subtitle = document.getElementById('subtitle');
        subtitle.textContent = deckCount === 0 ? "Create your first deck to get started!" : `Your saved decks:`;
        
        if (deckCount === 0) {
            decksContainer.innerHTML = `<div class="no-decks">
                <div class="no-decks-icon"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M12 6.042A8.967 8.967 0 0 0 6 3.75c-1.052 0-2.062.18-3 .512v14.25A8.987 8.987 0 0 1 6 18c2.305 0 4.408.867 6 2.292m0-14.25a8.966 8.966 0 0 1 6-2.292c1.052 0 2.062.18 3 .512v14.25A8.987 8.987 0 0 0 18 18a8.967 8.967 0 0 0-6 2.292m0-14.25v14.25" /></svg></div>
                <div>No flashcard decks yet.<br>Create your first deck to get started!</div>
            </div>`;
            return;
        }

        decksContainer.innerHTML = '';
        const groupedDecks = {};
        for (const deck of Object.values(decks)) {
            const category = deck.category || 'Other';
            if (!groupedDecks[category]) groupedDecks[category] = [];
            groupedDecks[category].push(deck);
        }

        const sortedCategories = Object.keys(groupedDecks).sort((a,b) => categories.indexOf(a) - categories.indexOf(b));

        for (const category of sortedCategories) {
            const categoryFolder = document.createElement('div');
            categoryFolder.className = 'category-folder';
            categoryFolder.innerHTML = `<h3 class="category-title">${category}</h3><div class="decks-grid"></div>`;
            const decksGrid = categoryFolder.querySelector('.decks-grid');

            const sortedDecks = groupedDecks[category].sort((a,b) => new Date(b.created) - new Date(a.created));

            decksGrid.innerHTML = sortedDecks.map(deck => {
                
                const totalCards = deck.cards.length;
                let progressPercent = 0;
                if (totalCards > 0) {
                    let totalMasteryScore = 0;
                    deck.cards.forEach(card => {
                        const mastery = knowledgeMap.get(card.id)?.masteryScore || 0.5;
                        totalMasteryScore += mastery;
                    });
                    progressPercent = (totalMasteryScore / totalCards) * 100;
                }
                
                let actionButtonsHTML;
                if (deck.typeHint === 'Sequence') {
                    actionButtonsHTML = `
                        <button class="action-btn learn-btn spaced-btn" style="grid-column: 1 / 3;" onclick="event.stopPropagation(); startSequenceSession('${deck.id}')">
                            Practice Sequence
                        </button>
                    `;
                } else {
                    actionButtonsHTML = `
                        <button class="action-btn learn-btn" onclick="event.stopPropagation(); configureStudy('learn', '${deck.id}')">Learn</button>
                        <button class="action-btn review-btn" onclick="event.stopPropagation(); configureStudy('review', '${deck.id}')">Review</button>
                    `;
                }

                return `<div class="deck-card" data-category="${category}" data-deck-id="${deck.id}">
                    <div class="deck-card-main-clickable" onclick="showDeckDetail('${deck.id}', this.parentElement)">
                        <div class="deck-header">
                            <div class="deck-category">${category}</div>
                            <div class="deck-name">${deck.name}</div>
                            <div class="deck-info"><span>${totalCards} cards</span></div>
                        </div>
                        <div class="deck-progress-container">
                            <div class="deck-progress-label"><span>Progress</span><span>${Math.round(progressPercent)}%</span></div>
                            <div class="deck-progress-bar-outer"><div class="deck-progress-bar-inner" style="width: ${progressPercent}%;"></div></div>
                        </div>
                        <div class="deck-date">Created: ${formatDate(deck.created)}</div>
                    </div>
                    <div class="deck-actions">
                        ${actionButtonsHTML}
                        <button class="action-btn export-btn" title="Export Deck" onclick="exportDeck('${deck.id}', event)">
                            <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" width="18" height="18"><path stroke-linecap="round" stroke-linejoin="round" d="M3 16.5v2.25A2.25 2.25 0 0 0 5.25 21h13.5A2.25 2.25 0 0 0 21 18.75V16.5M16.5 12 12 16.5m0 0L7.5 12m4.5 4.5V3" /></svg>
                        </button>
                    </div>
                </div>`;
            }).join('');
            decksContainer.appendChild(categoryFolder);
        }
        updateDueCardCounts();
        
        const internalBtn = document.getElementById('internalDashboardBtn');
        if (globalSettings.devMode === true) {
            internalBtn.classList.remove('hidden');
        } else {
            internalBtn.classList.add('hidden');
        }
    }

    function showDeckDetail(deckId, cardElement) {
        const deck = decks[deckId];
        if (!deck) return;
        if (cardElement) {
            cardElement.classList.add('deck-clicked');
            cardElement.addEventListener('animationend', () => cardElement.classList.remove('deck-clicked'), { once: true });
        }
        
        currentViewingDeckId = deckId;
        showView('dashboard');
        
        document.getElementById('deckDetailTitle').textContent = deck.name;
        const categoryElement = document.getElementById('deckDetailCategory');
        const category = deck.category || "Other";
        categoryElement.textContent = category;
        categoryElement.className = `deck-detail-category ${category}`;

        const deckDetailActions = document.getElementById('deckDetailActions');
        if (!deckDetailActions) {
            console.error("Fatal Error: deckDetailActions element not found in the DOM.");
            return; 
        }

        let sequenceBtn = deckDetailActions.querySelector('.sequence-btn');
        if (deck.typeHint === 'Sequence') {
            if (!sequenceBtn) {
                sequenceBtn = document.createElement('button');
                sequenceBtn.className = 'btn sequence-btn';
                sequenceBtn.textContent = 'Practice Sequence';
                sequenceBtn.style.backgroundColor = '#dd6b20';
                sequenceBtn.onclick = () => startSequenceSession(deckId);
                const reviewBtn = deckDetailActions.querySelector('.review-btn');
                deckDetailActions.insertBefore(sequenceBtn, reviewBtn);
            }
        } else {
            if (sequenceBtn) sequenceBtn.remove();
        }
        
        const cardsList = document.getElementById('deckCardsList');
        cardsList.innerHTML = '';
        
        if (deck.cards.length === 0) {
            cardsList.innerHTML = '<p style="text-align: center; color: var(--secondary-text);">No cards in this deck yet.</p>';
        } else {
            const cardsToDisplay = (deck.typeHint === 'Sequence') 
                ? [...deck.cards].sort((a, b) => a.order - b.order) 
                : deck.cards;

            cardsToDisplay.forEach((card, index) => {
                const cardItem = document.createElement('div');
                cardItem.className = 'deck-card-item';
                const originalIndex = deck.cards.findIndex(c => c.id === card.id); // Find original index for editing
                const newBadge = card.isNew ? '<span class="new-badge">New</span>' : '';
                const questionImageHTML = card.questionImage ? `<img src="${card.questionImage}" class="card-image">` : '';
                const answerImageHTML = card.answerImage ? `<img src="${card.answerImage}" class="card-image">` : '';
                const orderText = card.order ? `${card.order}. ` : `${index + 1}. `;
                cardItem.innerHTML = `<div class="deck-card-content">
                        <div class="deck-card-question">${orderText}${card.question} ${newBadge}</div>
                        ${questionImageHTML}
                        <div class="deck-card-answer">${card.answer}</div>
                        ${answerImageHTML}
                    </div>
                    <div class="deck-card-actions">
                        <button class="deck-card-action-btn edit" title="Edit Card" onclick="editCard('${deckId}', ${originalIndex}, 'detail')"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" width="16" height="16"><path stroke-linecap="round" stroke-linejoin="round" d="m16.862 4.487 1.687-1.688a1.875 1.875 0 1 1 2.652 2.652L10.582 16.07a4.5 4.5 0 0 1-1.897 1.13L6 18l.8-2.685a4.5 4.5 0 0 1 1.13-1.897l8.932-8.931Zm0 0L19.5 7.125M18 14v4.75A2.25 2.25 0 0 1 15.75 21H5.25A2.25 2.25 0 0 1 3 18.75V8.25A2.25 2.25 0 0 1 5.25 6H10" /></svg></button>
                        <button class="deck-card-action-btn delete" title="Delete Card" onclick="deleteCardFromDetail('${deckId}', ${originalIndex})"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor" width="16" height="16"><path stroke-linecap="round" stroke-linejoin="round" d="m14.74 9-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 0 1-2.244 2.077H8.084a2.25 2.25 0 0 1-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 0 0-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 0 1 3.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 0 0-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 0 0-7.5 0" /></svg></button>
                    </div>`;
                cardsList.appendChild(cardItem);
            });
        }
        
        document.getElementById('decksSection').classList.add('hidden');
        document.querySelector('.create-section').classList.add('hidden');
        document.getElementById('deckDetailView').classList.remove('hidden');
        
        document.getElementById('headerBackBtn').classList.remove('hidden');
    }

    function editCard(deckId, cardIndex, from) {
        const deck = decks[deckId];
        if (!deck || !deck.cards[cardIndex]) return;
        cardToEdit = { deckId, cardIndex, from };
        const card = deck.cards[cardIndex];
        document.getElementById('editCardQuestion').value = card.question;
        document.getElementById('editCardAnswer').value = card.answer;
        document.getElementById('editCardModal').classList.add('show');
    }
    
    function editCurrentStudyCard() {
        const card = studyState.roundCards[studyState.currentCardIndex];
        const deck = decks[currentDeckId];
        const cardIndexInDeck = deck.cards.findIndex(c => c.id === card.id);
        if (cardIndexInDeck > -1) {
            editCard(currentDeckId, cardIndexInDeck, 'study');
        }
    }

    function closeEditCardModal() {
        document.getElementById('editCardModal').classList.remove('show');
        cardToEdit = { deckId: null, cardIndex: null, from: null };
    }

    async function saveEditedCard() {
        const { deckId, cardIndex, from } = cardToEdit;
        if (deckId === null || cardIndex === null) return;
        
        const deck = decks[deckId];
        const newQuestion = document.getElementById('editCardQuestion').value.trim();
        const newAnswer = document.getElementById('editCardAnswer').value.trim();
        
        if (newQuestion && newAnswer) {
            const originalCard = deck.cards[cardIndex];
            originalCard.question = newQuestion;
            originalCard.answer = newAnswer;
            
            if (from === 'study') {
                const updateCardInArray = (arr) => {
                    const idx = arr.findIndex(c => c.id === originalCard.id);
                    if (idx > -1) arr[idx] = { ...arr[idx], question: newQuestion, answer: newAnswer };
                };
                
                if (currentMode === 'learn' || currentMode === 'spaced') {
                    studyState.buckets.forEach(bucket => updateCardInArray(bucket));
                } else if (currentMode === 'review') {
                    updateCardInArray(studyState.stillLearning);
                    updateCardInArray(studyState.correct);
                }
                updateCardInArray(studyState.roundCards);
                showNextCard(); 
            }
            
            await saveDataToDB('decks', deck);
            if (from === 'detail' && currentViewingDeckId === deckId) showDeckDetail(deckId);
            
            closeEditCardModal();
        } else {
            showToast("Question and Answer cannot be empty.", 'error');
        }
    }

    async function deleteCardFromDetail(deckId, cardIndex) {
        const deck = decks[deckId];
        if (!deck || !deck.cards[cardIndex]) return;
        
        showConfirmModal('Are you sure you want to delete this card?', async () => {
            deck.cards.splice(cardIndex, 1);
            await saveDataToDB('decks', deck);
            showDeckDetail(deckId);
            updateDashboard();
            showToast('Card deleted.');
        });
    }

    function setupSearch() {
        document.getElementById('searchInput').addEventListener('input', function() {
            const query = this.value.toLowerCase().trim();
            document.querySelectorAll('.deck-card').forEach(cardElement => {
                const deckId = cardElement.dataset.deckId;
                if (!deckId || !decks[deckId]) return;
                const deck = decks[deckId];
                let isMatch = deck.name.toLowerCase().includes(query) || (deck.category && deck.category.toLowerCase().includes(query));
                cardElement.style.display = isMatch ? 'flex' : 'none';
            });
            document.querySelectorAll('.category-folder').forEach(folder => {
                const visibleCards = folder.querySelectorAll('.deck-card[style*="display: flex"], .deck-card:not([style])');
                folder.style.display = visibleCards.length > 0 ? 'block' : 'none';
            });
        });
    }
    
    async function createNewDeck(name, category, cards, notes = '', typeHint = 'General') {
        const deckId = Date.now().toString();
        const settings = { ...DEFAULT_DECK_SETTINGS };
        
        const tempDeck = { name, category, cards, notes, typeHint };
        showToast("Analyzing new deck content...", "info", 2000);
        await processDeckContent(tempDeck);

        const sm2 = new SM2Algorithm();
        const processedCards = tempDeck.cards.map(c => ({
            ...c,
            sm2Data: sm2.calculateNextReview(c)(3)
        }));

        const newDeck = {
            id: deckId, name, category, cards: processedCards, notes, typeHint,
            created: new Date().toISOString(),
            settings: settings,
        };
        decks[deckId] = newDeck;

        const transaction = db.transaction(['userKnowledgeState'], 'readwrite');
        const stateStore = transaction.objectStore('userKnowledgeState');
        newDeck.cards.forEach(card => {
            stateStore.put({
                userID: 'default_user',
                cardID: card.id,
                masteryScore: 0.5, 
                stability: 1.0,    
                lastReviewed: new Date().toISOString(),
                recallHistory: []
            });
        });

        await new Promise(resolve => transaction.oncomplete = resolve);

        await saveDataToDB('decks', newDeck);
        return deckId;
    }

    function editDeck(deckId) {
        const deck = decks[deckId];
        if (!deck) return;
        showView('editorView');
        document.getElementById('deckTitle').value = deck.name;
        document.getElementById('deckCategory').value = deck.category;
        document.getElementById('deckNotes').value = deck.notes || '';
        const container = document.getElementById('flashcardsContainer');
        container.innerHTML = '';
        editorCardCounter = 0;
        deck.cards.forEach(card => editorAddNewCard(card));
        currentDeckId = deckId;
    }

    function deleteDeck(deckId) {
        const deckName = decks[deckId]?.name || 'this deck';
        showConfirmModal(`Are you sure you want to permanently delete the deck "${deckName}"? This action cannot be undone.`, async () => {
            delete decks[deckId];
            await deleteDataFromDB('decks', deckId);
            if (currentViewingDeckId === deckId) {
                backToDashboard();
            } else {
                updateDashboard();
            }
            showToast(`Deck "${deckName}" deleted.`);
        });
    }

    function editorInitialize() {
        document.getElementById('deckTitle').value = '';
        populateCategoryDropdowns();
        document.getElementById('deckCategory').value = 'Other';
        document.getElementById('deckNotes').value = '';
        const container = document.getElementById('flashcardsContainer');
        container.innerHTML = '';
        editorCardCounter = 0;
        editorAddNewCard();
        editorAddNewCard();
        document.getElementById('deckTitle').focus();
        currentDeckId = null;
    }

    function isEditorClean() {
        const title = document.getElementById('deckTitle').value.trim();
        if (title) return false;
        const cardItems = document.querySelectorAll('#editorView .flashcard-item');
        for (const item of cardItems) {
            const q = item.querySelector('.question-input').value.trim();
            const a = item.querySelector('.solution-input').value.trim();
            const qImg = item.querySelector('.question-image-input').value.trim();
            const aImg = item.querySelector('.answer-image-input').value.trim();
            if (q || a || qImg || aImg) return false;
        }
        return true;
    }

    function editorAddNewCard(card = {}) {
        const { id = null, question = '', answer = '', questionImage = '', answerImage = '', order = '' } = card;
        editorCardCounter++;
        const container = document.getElementById('flashcardsContainer');

        const newRow = document.createElement('div');
        newRow.className = 'flashcard-editor-row';
        newRow.setAttribute('data-card-id', editorCardCounter);

        const questionImagePreview = questionImage ? `<img src="${questionImage}">` : '';
        const answerImagePreview = answerImage ? `<img src="${answerImage}">` : '';

        const deckType = document.getElementById('deckTypeHint').value;
        const cardNumber = document.querySelectorAll('.flashcard-editor-row').length + 1;
        const orderInputHTML = (deckType === 'Sequence') 
            ? `<input type="number" class="card-order-input" value="${order || cardNumber}" style="width: 60px; margin-right: 10px; padding: 5px 8px; text-align: center;">` 
            : '';

        newRow.innerHTML = `
            <div class="flashcard-item" data-original-id="${id || ''}">
                <div class="flashcard-number" style="display: flex; align-items: center;">
                    ${orderInputHTML}
                    <span>${cardNumber}.</span>
                </div>
                
                <textarea class="question-input" placeholder="Question (e.g., The event or item in the sequence)">${question}</textarea>
                <div class="image-controls">
                    <button class="btn btn-secondary" style="padding: 5px 10px; font-size: 12px;" onclick="triggerImageUpload(this)" tabindex="-1">Upload Image</button>
                </div>
                <div class="question-image-preview image-preview">${questionImagePreview}</div>
                <input type="file" class="image-upload-input" accept="image/*" style="display:none;" onchange="handleImageFile(this)">
                <input type="hidden" class="question-image-input" value="${questionImage}">
                
                <textarea class="solution-input" placeholder="Answer (e.g., The name of the event or item)" style="margin-top:20px;">${answer}</textarea>
                <div class="image-controls">
                    <button class="btn btn-secondary" style="padding: 5px 10px; font-size: 12px;" onclick="triggerImageUpload(this)" tabindex="-1">Upload Image</button>
                </div>
                <div class="answer-image-preview image-preview">${answerImagePreview}</div>
                <input type="file" class="image-upload-input" accept="image/*" style="display:none;" onchange="handleImageFile(this)">
                <input type="hidden" class="answer-image-input" value="${answerImage}">
            </div>
            <button class="remove-card-btn" onclick="editorRemoveCard(${editorCardCounter})"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="2" stroke="currentColor" style="width: 20px; height: 20px;"><path stroke-linecap="round" stroke-linejoin="round" d="m14.74 9-.346 9m-4.788 0L9.26 9m9.968-3.21c.342.052.682.107 1.022.166m-1.022-.165L18.16 19.673a2.25 2.25 0 0 1-2.244 2.077H8.084a2.25 2.25 0 0 1-2.244-2.077L4.772 5.79m14.456 0a48.108 48.108 0 0 0-3.478-.397m-12 .562c.34-.059.68-.114 1.022-.165m0 0a48.11 48.11 0 0 1 3.478-.397m7.5 0v-.916c0-1.18-.91-2.164-2.09-2.201a51.964 51.964 0 0 0-3.32 0c-1.18.037-2.09 1.022-2.09 2.201v.916m7.5 0a48.667 48.667 0 0 0-7.5 0" /></svg></button>
        `;
        
        container.appendChild(newRow);
        
        newRow.querySelectorAll('textarea').forEach(textarea => {
            textarea.addEventListener('paste', handleImagePaste);
        });

        if (!question && !answer) newRow.querySelector('.question-input').focus();
    }
    
    function triggerImageUpload(button) {
        button.closest('.image-controls').nextElementSibling.nextElementSibling.click();
    }

    function handleImageFile(input) {
        const file = input.files[0];
        if (file && file.type.startsWith('image/')) {
            const reader = new FileReader();
            reader.onload = e => {
                const dataUrl = e.target.result;
                const preview = input.previousElementSibling;
                const dataInput = input.nextElementSibling;
                preview.innerHTML = `<img src="${dataUrl}">`;
                dataInput.value = dataUrl;
            };
            reader.readAsDataURL(file);
        }
    }

    function handleImagePaste(event) {
        const items = (event.clipboardData || window.clipboardData).items;
        for (let i = 0; i < items.length; i++) {
            if (items[i].type.indexOf('image') !== -1) {
                event.preventDefault();
                const blob = items[i].getAsFile();
                const reader = new FileReader();
                reader.onload = (e) => {
                    const dataUrl = e.target.result;
                    const textarea = event.target;
                    const preview = textarea.nextElementSibling.nextElementSibling;
                    const dataInput = preview.nextElementSibling.nextElementSibling;
                    preview.innerHTML = `<img src="${dataUrl}">`;
                    dataInput.value = dataUrl;
                };
                reader.readAsDataURL(blob);
                break;
            }
        }
    }
    
    function triggerNotesImageUpload(button) {
        button.nextElementSibling.click();
    }

    function handleNotesImageUpload(input) {
        const file = input.files[0];
        if (file && file.type.startsWith('image/')) {
            const reader = new FileReader();
            reader.onload = e => {
                const dataUrl = e.target.result;
                const notesTextarea = document.getElementById('deckNotes');
                const imgTag = `<img src="${dataUrl}" style="max-width: 100%; border-radius: 8px;">`;
                notesTextarea.value += (notesTextarea.value ? '\n\n' : '') + imgTag;
            };
            reader.readAsDataURL(file);
        }
    }

    function editorRemoveCard(cardId) {
        const cardRow = document.querySelector(`#editorView [data-card-id="${cardId}"]`);
        if (cardRow) {
            cardRow.remove();
            editorRenumberCards();
        }
    }

    function editorRenumberCards() {
        const cardRows = document.querySelectorAll('#editorView .flashcard-editor-row');
        cardRows.forEach((row, index) => {
            const cardItem = row.querySelector('.flashcard-item');
            if (cardItem) {
                cardItem.querySelector('.flashcard-number').textContent = `${index + 1}.`;
            }
        });
    }

    async function editorSaveDeck() {
        const saveBtn = document.querySelector('.editor-container .actions-section .btn-success');
        const originalText = saveBtn.innerHTML;
        saveBtn.innerHTML = '<span class="spinner" style="border-width:2px; width:16px; height:16px;"></span> Saving...';
        saveBtn.disabled = true;

        const name = document.getElementById('deckTitle').value.trim();
        const category = document.getElementById('deckCategory').value;
        const notes = document.getElementById('deckNotes').value.trim();
        const typeHint = document.getElementById('deckTypeHint').value;

        if (!name) { 
            showToast('Please enter a title for your deck.', 'error');
            saveBtn.innerHTML = originalText;
            saveBtn.disabled = false;
            return; 
        }
        
        const cards = Array.from(document.querySelectorAll('#editorView .flashcard-item')).map(el => {
            const orderInput = el.querySelector('.card-order-input');
            const originalId = el.dataset.originalId; 
            return {
                id: originalId ? originalId : Date.now() + Math.random(),
                question: el.querySelector('.question-input').value.trim(),
                answer: el.querySelector('.solution-input').value.trim(),
                questionImage: el.querySelector('.question-image-input').value.trim(),
                answerImage: el.querySelector('.answer-image-input').value.trim(),
                order: orderInput ? parseInt(orderInput.value) : 0,
                isNew: !originalId
            };
        }).filter(c => c.question || c.questionImage);

        if (cards.length === 0) { 
            showToast('Please add at least one complete flashcard.', 'error');
            saveBtn.innerHTML = originalText;
            saveBtn.disabled = false;
            return; 
        }

        const newCards = cards.filter(c => c.isNew);
        if (newCards.length > 0) {
            try {
                await new Promise((resolve, reject) => {
                    const transaction = db.transaction(['userKnowledgeState'], 'readwrite');
                    const stateStore = transaction.objectStore('userKnowledgeState');
                    transaction.oncomplete = resolve;
                    transaction.onerror = reject;

                    newCards.forEach(card => {
                        stateStore.put({
                            userID: 'default_user',
                            cardID: card.id,
                            masteryScore: 0.5,
                            stability: 1.0,
                            lastReviewed: new Date().toISOString(),
                            recallHistory: []
                        });
                        card.isNew = false; 
                    });
                });
            } catch (error) {
                console.error("Failed to save knowledge state for new cards:", error);
                showToast("Error saving new cards' progress.", "error");
                saveBtn.innerHTML = originalText;
                saveBtn.disabled = false;
                return; 
            }
        }
        
        const tempDeck = { name, category, cards, notes, typeHint };
        showToast("Analysing deck content...", "info", 2000);
        await processDeckContent(tempDeck);

        if (currentDeckId) {
            const deck = decks[currentDeckId];
            deck.name = name;
            deck.category = category;
            deck.cards = tempDeck.cards;
            deck.notes = notes;
            deck.typeHint = typeHint;
            await saveDataToDB('decks', deck);
        } else {
            await createNewDeck(name, category, tempDeck.cards, notes, typeHint);
        }
        
        document.getElementById('deckTitle').value = '';
        document.getElementById('flashcardsContainer').innerHTML = '';
        backToDashboard();
    }
    
    async function checkName() {
        if (!globalSettings.username) {
            document.getElementById('nameModal').classList.add('show');
        } else {
            document.getElementById('welcomeMessage').textContent = `Welcome back, ${globalSettings.username}!`;
        }
    }

    async function saveName(e) {
        e.preventDefault();
        const nameInput = document.getElementById('nameInput');
        const username = nameInput.value.trim();
        document.getElementById('newCategoryInput').focus();
        if (username) {
            globalSettings.username = username;
            await saveDataToDB('appData', { key: 'userSettings', ...globalSettings });
            document.getElementById('welcomeMessage').textContent = `Welcome, ${username}!`;
            closeNameModal();
        }
    }
    
    async function saveUsername() {
        const username = document.getElementById('usernameInput').value.trim();
        if (username) {
            globalSettings.username = username;
            await saveDataToDB('appData', { key: 'userSettings', ...globalSettings });
            document.getElementById('welcomeMessage').textContent = `Welcome back, ${username}!`;
            showToast('Name saved!');
        } else showToast('Name cannot be empty.', 'error');
    }
    
    async function saveStudySettings() {
        globalSettings.enableInStudyEditing = document.getElementById('enableInStudyEditing').checked;
        globalSettings.enableInStudyEditing = document.getElementById('enableInStudyEditing').checked;
        await saveDataToDB('appData', { key: 'userSettings', ...globalSettings });
        showToast('Settings saved!');
    }

    function closeNameModal() { document.getElementById('nameModal').classList.remove('show'); }
    
    async function toggleDarkMode() {
        document.body.classList.toggle('dark-mode');
        globalSettings.darkMode = document.body.classList.contains('dark-mode');
        await saveDataToDB('appData', { key: 'userSettings', ...globalSettings });
        }
        
        async function clearAllDecks() {
            showConfirmModal('Are you sure you want to delete all decks? This is irreversible.', async () => {
                decks = {};
                await clearStoreInDB('decks');
                updateDashboard();
                backToDashboard();
            });
        }

        function populateCategoryDropdowns() {
            const dropdown = document.getElementById('deckCategory');
            const currentValue = dropdown.value;
            dropdown.innerHTML = '';
            categories.forEach(cat => dropdown.innerHTML += `<option value="${cat}">${cat}</option>`);
            dropdown.innerHTML += `<option value="add_new_category" style="font-style: italic;">+ Add New Category...</option>`;
            dropdown.value = currentValue;
        }
        
        function handleCategoryChange(event) {
            if (event.target.value === 'add_new_category') openAddCategoryModal();
        }

        function openAddCategoryModal() { 
            document.getElementById('addCategoryModal').classList.add('show'); 
            document.getElementById('newCategoryInput').focus();
        }
        function closeAddCategoryModal() { 
            populateCategoryDropdowns();
            document.getElementById('addCategoryModal').classList.remove('show'); 
        }

        async function saveNewCategory() {
            const newCatInput = document.getElementById('newCategoryInput');
            let newCat = newCatInput.value.trim();
            if (newCat) {
                newCat = newCat.charAt(0).toUpperCase() + newCat.slice(1);
                if (!categories.includes(newCat)) {
                    categories.push(newCat);
                    await saveDataToDB('appData', { key: 'categories', data: categories });
                    populateCategoryDropdowns();
                    document.getElementById('deckCategory').value = newCat;
                }
                newCatInput.value = '';
                closeAddCategoryModal();
            } else showToast('Category name cannot be empty.', 'error');
        }
        
        function configureStudy(mode, deckId) {
            currentDeckId = deckId || currentViewingDeckId;
            if (!currentDeckId) return;

            if (mode === 'learn') {
                startLearnMode(currentDeckId);
            } else if (mode === 'review') {
                startReviewMode(currentDeckId);
            } else if (mode === 'spaced') {
                startSpacedLearning(currentDeckId);
            }
        }

        async function startLearnMode(deckId) {
            currentMode = 'learn';
            currentDeckId = deckId;
            const deck = decks[deckId];

            document.getElementById('progressView').classList.add('hidden');
            document.getElementById('cardView').classList.add('hidden');
            document.getElementById('completeView').classList.add('hidden');

            if (deck.cards.length > 0 && typeof deck.cards[0].archetype === 'undefined') {
                showToast("Performing first-time analysis...", "info", 2000);
                await processDeckContent(deck);
                await saveDataToDB('decks', deck); 
            }
            
            deck.settings = {...DEFAULT_DECK_SETTINGS, ...(deck.settings || {})};
            studyState.settings = deck.settings;
            studyState.currentRound = 1;
            studyState.startTime = new Date();
            
            showView('studyMode');
            document.getElementById('studyTitle').textContent = 'Learning Mode';
            document.getElementById('studySubtitle').textContent = deck.name;
            showProgress();
        }

        async function startSpacedLearning(deckId) {
            document.getElementById('progressView').classList.add('hidden');
            document.getElementById('cardView').classList.add('hidden');
            document.getElementById('completeView').classList.add('hidden');
            currentMode = 'spaced';
            currentDeckId = deckId;
            const deck = decks[deckId];

            const allCards = [...deck.cards];
            const knowledgeStates = await getAllDataFromDB('userKnowledgeState');
            const knowledgeMap = new Map(knowledgeStates.map(item => [item.cardID, item]));

            const dueCards = allCards.filter(card => {
                const state = knowledgeMap.get(card.id);
                if (!state) return true; 
                const pRecall = calculatePRecall(state.stability, state.lastReviewed);
                return pRecall <= 0.90;
            });
            
            studyState.roundCards = shuffleArray(dueCards);
            studyState.settings = deck.settings;
            studyState.currentRound = 1;
            studyState.currentCardIndex = 0;
            studyState.startTime = new Date();

            showView('studyMode');
            document.getElementById('studyTitle').textContent = 'Spaced Learning';
            document.getElementById('studySubtitle').textContent = deck.name;
            
            if (studyState.roundCards.length > 0) {
                transitionSubView(document.getElementById('progressView'), document.getElementById('cardView'));
                showNextCard();
            } else {
                showProgress();
                showToast("No cards are due for review right now!");
            }
        }

        async function startReviewMode(deckId) {
            document.getElementById('progressView').classList.add('hidden');
            document.getElementById('cardView').classList.add('hidden');
            document.getElementById('completeView').classList.add('hidden');
            currentMode = 'review';
            currentDeckId = deckId;
            const deck = decks[deckId];
            deck.settings = {...DEFAULT_DECK_SETTINGS, ...(deck.settings || {})};
            await saveDataToDB('decks', deck);

            studyState.settings = deck.settings;
            studyState.stillLearning = [...(deck.reviewState?.stillLearning || deck.cards)];
            studyState.correct = [...(deck.reviewState?.correct || [])];
            studyState.currentRound = deck.reviewState?.currentRound || 1;
            studyState.lastRoundIncorrect = [...(deck.reviewState?.lastRoundIncorrect || [])];
            studyState.startTime = new Date();
            showView('studyMode');
            document.getElementById('studyTitle').textContent = 'Review Mode';
            document.getElementById('studySubtitle').textContent = deck.name;
            if (studyState.stillLearning.length === 0) showComplete();
            else showProgress();
        }


        async function saveStudyProgress() {
            if (!currentDeckId) return;
            const deck = decks[currentDeckId];
            if (!deck) return;

            if (currentMode === 'learn') {
                if (deck.learnState) delete deck.learnState;
            } else if (currentMode === 'review') {
                deck.reviewState = { stillLearning: studyState.stillLearning, correct: studyState.correct, currentRound: studyState.currentRound, lastRoundIncorrect: studyState.lastRoundIncorrect };
            } else if (currentMode === 'sequence') {
                deck.sequenceState = {
                    currentChunkIndex: studyState.currentChunkIndex,
                    sequencePhase: studyState.sequencePhase
                };
            }
            await saveDataToDB('decks', deck);
            await updateDashboard(); 
        }
        
        async function showProgress() {
            if (currentMode === 'learn' && studyState.currentRound > 1) {
                await runSmartCoachChecks('roundEnd');
            }
            const cardView = document.getElementById('cardView');
            const progressView = document.getElementById('progressView');
            transitionSubView(cardView, progressView);
            document.getElementById('switchStudyModeBtn').classList.add('hidden');

            const continueBtn = document.getElementById('continueBtn');
            if(studyState.currentRound === 1) {
                continueBtn.textContent = 'Start Round';
                continueBtn.classList.add('btn-prominent');
            } else {
                continueBtn.textContent = 'Continue Round';
                continueBtn.classList.remove('btn-prominent');
            }
            if(currentMode === 'learn') updateLearnProgress();
            else if (currentMode === 'review') updateReviewProgress();
            else if (currentMode === 'spaced') updateSpacedProgress();
        }
        
        function getBucketName(index, totalBuckets) {
            const names = {
                3: ["New", "Reviewing", "Mastered"],
                4: ["New", "Learning", "Reviewing", "Mastered"],
                5: ["New", "Learning", "Reviewing", "Mastered", "Legendary"]
            };
            return (names[totalBuckets] && names[totalBuckets][index]) || `Bucket ${index + 1}`;
        }

        async function updateLearnProgress() {
            const deck = decks[currentDeckId];
            const allCards = deck.cards;
            const totalCards = allCards.length;

            if (totalCards === 0) return;

            const knowledgeStates = await getAllDataFromDB('userKnowledgeState');
            const knowledgeMap = new Map(knowledgeStates.map(item => [item.cardID, item]));

            let masteredCount = 0;
            let totalMasteryScore = 0;

            allCards.forEach(card => {
                const mastery = knowledgeMap.get(card.id)?.masteryScore || 0.5;
                if (mastery >= 0.95) {
                    masteredCount++;
                }
                totalMasteryScore += mastery;
            });

            const deckMasteryPercent = (totalMasteryScore / totalCards) * 100;
            const learningCount = totalCards - masteredCount;

            document.getElementById('deckMasteryProgress').style.width = `${deckMasteryPercent}%`;
            document.getElementById('deckMasteryValue').textContent = `${Math.round(deckMasteryPercent)}%`;
            document.getElementById('masteredCardCount').textContent = masteredCount;
            document.getElementById('learningCardCount').textContent = learningCount;

            const poolList = document.getElementById('activePoolList');
            if (studyState.activeLearningPool && studyState.activeLearningPool.length > 0) {
                poolList.innerHTML = studyState.activeLearningPool.map(card => 
                    `<div class="deck-card-item" style="padding: 10px; border: none;">${card.question}</div>`
                ).join('');
            } else {
                poolList.innerHTML = `<p style="text-align: center; color: var(--secondary-text);">Click 'Continue' to start!</p>`;
            }

            const continueBtn = document.getElementById('continueBtn');
            if (learningCount === 0) {
                document.getElementById('progressTitle').textContent = 'Deck Mastered!';
                document.getElementById('activeLearningPoolDisplay').classList.add('hidden');
                continueBtn.textContent = 'Finish Session';
                continueBtn.classList.add('btn-success');
                continueBtn.onclick = showComplete;
            } else {
                document.getElementById('progressTitle').textContent = 'Learning Progress';
                document.getElementById('activeLearningPoolDisplay').classList.remove('hidden');
                continueBtn.textContent = studyState.currentRound === 1 ? 'Start Round' : 'Continue Round';
                continueBtn.classList.remove('btn-success');
                continueBtn.onclick = continueStudy;
            }
        }

        function updateReviewProgress() {
            const deck = decks[currentDeckId];
            const mastered = studyState.correct.length, remaining = studyState.stillLearning.length, total = deck.cards.length;

            const notesContainer = document.getElementById('deckNotesDisplay');
            if (deck.notes && studyState.currentRound === 1) {
                notesContainer.innerHTML = `<h3>Notes for this deck:</h3><div>${deck.notes}</div>`;
                notesContainer.classList.remove('hidden');
            } else {
                notesContainer.classList.add('hidden');
            }

            if (remaining === 0 && total > 0) {
                document.getElementById('progressTitle').textContent = 'Deck Mastered!';
                const continueBtn = document.getElementById('continueBtn');
                continueBtn.textContent = 'Finish';
                continueBtn.classList.remove('btn-prominent');
                continueBtn.classList.add('btn-success');
                continueBtn.onclick = showComplete;
                return;
            }
            document.getElementById('progressTitle').textContent = 'Review Progress';
            document.getElementById('roundInfo').textContent = `Round ${studyState.currentRound}`;
            document.getElementById('bucketsContainer').innerHTML = `<div class="bucket"><div class="bucket-number">Still Learning</div><div class="bucket-count">${remaining}</div></div><div class="bucket"><div class="bucket-number">Correct</div><div class="bucket-count">${mastered}</div></div>`;
            const progress = total > 0 ? (mastered / total) * 100 : 0;
            document.getElementById('progressBarFill').style.width = `${progress}%`;
            document.getElementById('statsContainer').innerHTML = `<div class="stat"><div class='stat-value'>${mastered}</div><div class='stat-label'>Total Mastered</div></div><div class='stat'><div class='stat-value'>${remaining}</div><div class='stat-label'>Remaining</div></div>`;
        }
        
        function updateSpacedProgress() {
            const deck = decks[currentDeckId];
            const now = new Date();
            const dueCards = deck.cards.filter(c => new Date(c.sm2Data.dueDate) <= now);
            const total = deck.cards.length;

            document.getElementById('progressTitle').textContent = 'Spaced Learning';
            document.getElementById('roundInfo').textContent = `${studyState.roundCards.length} cards in this session`;
            document.getElementById('bucketsContainer').innerHTML = ''; 
            document.getElementById('progressBarFill').style.width = total > 0 ? `${((total - dueCards.length) / total) * 100}%` : '0%';
            document.getElementById('statsContainer').innerHTML = `<div class="stat"><div class="stat-value">${dueCards.length}</div><div class="stat-label">Cards Due</div></div><div class="stat"><div class="stat-value">${total}</div><div class="stat-label">Total Cards</div></div>`;
            
            if (studyState.roundCards.length === 0) {
                document.getElementById('continueBtn').textContent = 'Finish';
                document.getElementById('continueBtn').onclick = endSession;
            } else {
                document.getElementById('continueBtn').textContent = 'Start Round';
                 document.getElementById('continueBtn').onclick = continueStudy;
            }
        }

        async function continueStudy() {
            const continueBtn = document.getElementById('continueBtn');
            continueBtn.disabled = true; // Disable the button immediately.
            continueBtn.innerHTML = '<span class="spinner" style="border-width:2px; width:16px; height:16px;"></span> Loading...';

            if (currentMode === 'learn') {
                const allCards = decks[currentDeckId].cards;
                const knowledgeStates = await getAllDataFromDB('userKnowledgeState');
                studyState.knowledgeStates = new Map(knowledgeStates.map(item => [item.cardID, item]));
                const knowledgeMap = new Map(knowledgeStates.map(item => [item.cardID, item]));
                const nonMasteredCards = allCards.map(card => ({...card, mastery: knowledgeMap.get(card.id)?.masteryScore || 0.5 })).filter(card => card.mastery < 0.95);
                nonMasteredCards.sort((a, b) => a.mastery - b.mastery);
                
                let poolSize;
                if (lastKnownFocusScore >= 0.85) poolSize = 7;
                else if (lastKnownFocusScore >= 0.65) poolSize = 5;
                else poolSize = 3;
                
                studyState.activeLearningPool = nonMasteredCards.slice(0, poolSize);
                studyState.roundCards = shuffleArray(studyState.activeLearningPool);

            } else if (currentMode === 'review') {
                let prioritized = [];
                let others = [];
                if (studyState.lastRoundIncorrect && studyState.lastRoundIncorrect.length > 0) {
                    const incorrectIds = new Set(studyState.lastRoundIncorrect.map(c => c.id));
                    studyState.stillLearning.forEach(card => {
                        if (incorrectIds.has(card.id)) prioritized.push(card);
                        else others.push(card);
                    });
                } else {
                    others = [...studyState.stillLearning];
                }
                studyState.lastRoundIncorrect = [];
                let sortedCards;
                if (studyState.settings.reviewOrder === 'alphabetical') {
                    prioritized.sort((a, b) => a.question.localeCompare(b.question));
                    others.sort((a, b) => a.question.localeCompare(b.question));
                    sortedCards = prioritized.concat(others);
                } else {
                    sortedCards = shuffleArray(prioritized).concat(shuffleArray(others));
                }
                studyState.roundCards = sortedCards;
            }
            studyState.currentCardIndex = 0;

            studyState.roundCards.forEach(card => {
                card.questionTypeToShow = selectOptimalQuestionType(card);
            });

            if (studyState.roundCards.length > 0) {
                const cardsRequiringGeneration = studyState.roundCards.filter(
                    card => card.questionTypeToShow === 'MultipleChoice' && isOnline
                );

                if (cardsRequiringGeneration.length > 0) {
                    transitionSubView(document.getElementById('progressView'), document.getElementById('preGenerationView'));

                    const updateProgressUI = (completed, total) => {
                        const percent = total > 0 ? (completed / total) * 100 : 100;
                        document.getElementById('preGenerationProgress').style.width = `${percent}%`;
                        document.getElementById('preGenerationProgressText').textContent = `${completed} / ${total}`;
                    };

                    await preGenerateAdaptiveQuestions(studyState.roundCards, updateProgressUI);

                    transitionSubView(document.getElementById('preGenerationView'), document.getElementById('cardView'));

                } else {

                    transitionSubView(document.getElementById('progressView'), document.getElementById('cardView'));
                }

                showNextCard();

            } else {
                if(currentMode === 'learn') {
                   showComplete();
                } else {
                   showProgress();
                   showToast("No cards available to study in this round.");
                }
            }

            continueBtn.disabled = false;
            continueBtn.innerHTML = studyState.currentRound === 1 ? 'Start Round' : 'Continue Round';
        }

        async function showNextCard() {
            document.getElementById('flashcardViewContainer').classList.add('hidden');
            document.getElementById('passiveReviewView').classList.add('hidden');
            document.getElementById('dragDropView').classList.add('hidden');
            document.getElementById('mcqView').classList.add('hidden');
            document.getElementById('writeAnswerInput').classList.add('hidden');
            const simpleButtons = document.getElementById('simpleAnswerButtons');
            simpleButtons.classList.remove('hidden');
            simpleButtons.querySelectorAll('button').forEach(btn => btn.classList.add('hidden'));

            const checkBtn = document.getElementById('checkAnswerBtn');
            const dontKnowBtn = document.getElementById('dontKnowBtn');
            if (currentMode === 'sequence') {
                checkBtn.onclick = checkSequenceAnswer;
                dontKnowBtn.onclick = dontKnowSequenceAnswer;
            } else {
                checkBtn.onclick = autoCheckAnswer;
                dontKnowBtn.onclick = dontKnowAnswer;
            }

            if (currentMode === 'sequence') {
                const currentChunk = studyState.sequenceChunks[studyState.currentChunkIndex];
                const card = currentChunk ? currentChunk[studyState.currentCardIndex] : null;

                switch (studyState.sequencePhase) {
                    case 'Passive Review':
                        document.getElementById('passiveReviewView').classList.remove('hidden');
                        const list = document.getElementById('passiveReviewList');
                        list.innerHTML = currentChunk.map(c => `<li>${c.answer}</li>`).join('');
                        break;
                    case 'Forward Chaining':
                    case 'Backward Chaining':
                        document.getElementById('flashcardViewContainer').classList.remove('hidden');
                        document.getElementById('writeAnswerInput').classList.remove('hidden');
                        document.getElementById('checkAnswerBtn').classList.remove('hidden');
                        document.getElementById('dontKnowBtn').classList.remove('hidden');
                        const qElement = document.getElementById('cardQuestion');
                        if (studyState.sequencePhase === 'Forward Chaining') {
                            qElement.innerHTML = (studyState.currentCardIndex === 0) ? `What is the first item in this chunk?` : `What comes after: <strong>${currentChunk[studyState.currentCardIndex - 1].answer}</strong>?`;
                        } else {
                            qElement.innerHTML = (studyState.currentCardIndex === currentChunk.length - 1) ? `What is the last item in this chunk?` : `What comes before: <strong>${currentChunk[studyState.currentCardIndex + 1].answer}</strong>?`;
                        }
                        startInteractionLog(card.id);
                        break;
                    case 'Drag and Drop':
                        document.getElementById('dragDropView').classList.remove('hidden');
                        setupDragDropView(currentChunk);
                        break;
                    case 'InterChunkReview':
                        const reviewCard = studyState.roundCards[0];
                        document.getElementById('flashcardViewContainer').classList.remove('hidden');
                        document.getElementById('writeAnswerInput').classList.remove('hidden');
                        document.getElementById('checkAnswerBtn').classList.remove('hidden');
                        document.getElementById('dontKnowBtn').classList.remove('hidden');
                        document.getElementById('cardQuestion').innerHTML = `Recall from previous chunk: What is item "${reviewCard.question}"?`;
                        startInteractionLog(reviewCard.id);
                        break;
                    case 'Weakest Link':
                        const weakestCard = studyState.roundCards[studyState.currentCardIndex];
                        document.getElementById('flashcardViewContainer').classList.remove('hidden');
                        document.getElementById('writeAnswerInput').classList.remove('hidden');
                        document.getElementById('checkAnswerBtn').classList.remove('hidden');
                        document.getElementById('dontKnowBtn').classList.remove('hidden');
                        document.getElementById('cardQuestion').innerHTML = `Recall: What is item "${weakestCard.question}"?`;
                        startInteractionLog(weakestCard.id);
                        break;
                }
                document.querySelector('#cardView .flashcard').classList.remove('is-flipped');
                if (card) document.getElementById('cardAnswer').innerHTML = card.answer;
                document.getElementById('cardAnswerContent').classList.add('hidden');
                const writeInput = document.getElementById('writeAnswerInput');
                writeInput.value = '';
                writeInput.disabled = false;
                writeInput.classList.remove('correct', 'incorrect');
                if(!writeInput.classList.contains('hidden')) setTimeout(() => writeInput.focus(), 100);
                return;
            }

            if (studyState.currentCardIndex >= studyState.roundCards.length && studyState.incorrectInThisRound.length > 0) {
                studyState.roundCards = studyState.roundCards.concat(shuffleArray(studyState.incorrectInThisRound));
                studyState.incorrectInThisRound = [];
                showToast("Let's review the ones you missed.", "info");
            }

            if (studyState.currentCardIndex >= studyState.roundCards.length) {
                studyState.currentRound++;
                await saveStudyProgress();
                await showProgress();
                return;
            }

            window.scrollTo(0, 0);
            const card = studyState.roundCards[studyState.currentCardIndex];
            const questionType = card.questionTypeToShow;

            switch (questionType) {
                case 'MultipleChoice':
                    document.getElementById('mcqView').classList.remove('hidden');
                    document.getElementById('mcqQuestion').innerHTML = card.question;
                    generateAndDisplayMCQ(card, decks[currentDeckId].cards);
                    simpleButtons.classList.add('hidden');
                    break;
                
                case 'Cloze':
                    document.getElementById('flashcardViewContainer').classList.remove('hidden');
                    const clozeText = card.question.replace(new RegExp(card.answer, 'ig'), '___________');
                    document.getElementById('cardQuestion').innerHTML = clozeText;
                    document.getElementById('writeAnswerInput').classList.remove('hidden');
                    document.getElementById('checkAnswerBtn').classList.remove('hidden');
                    document.getElementById('dontKnowBtn').classList.remove('hidden');
                    startInteractionLog(card.id);
                    break;

                case 'Type': 
                    document.getElementById('flashcardViewContainer').classList.remove('hidden');
                    document.getElementById('cardQuestion').innerHTML = card.question;
                    document.getElementById('writeAnswerInput').classList.remove('hidden');
                    document.getElementById('checkAnswerBtn').classList.remove('hidden');
                    document.getElementById('dontKnowBtn').classList.remove('hidden');
                    startInteractionLog(card.id);
                    break;

                default: 
                    document.getElementById('flashcardViewContainer').classList.remove('hidden');
                    document.getElementById('cardQuestion').innerHTML = card.question;
                    document.getElementById('showAnswerBtn').classList.remove('hidden');
                    break;
            }

            const flashcardElem = document.querySelector('#cardView .flashcard');
            flashcardElem.classList.remove('is-flipped');
            document.getElementById('cardAnswer').innerHTML = card.answer;
            document.getElementById('cardAnswerContent').classList.add('hidden');
            
            const writeInput = document.getElementById('writeAnswerInput');
            writeInput.value = '';
            writeInput.disabled = false;
            writeInput.classList.remove('correct', 'incorrect');
            if(!writeInput.classList.contains('hidden')) setTimeout(() => writeInput.focus(), 100);

            document.getElementById('cardRoundInfo').textContent = `Round ${studyState.currentRound} - Card ${studyState.currentCardIndex + 1} of ${studyState.roundCards.length}`;
        }

        async function moveToNextSequencePhase() {
            const currentChunk = studyState.sequenceChunks[studyState.currentChunkIndex];
            let nextPhase = null;

            switch (studyState.sequencePhase) {
                case null:
                    nextPhase = 'Passive Review';
                    break;
                case 'Passive Review':
                    nextPhase = 'Forward Chaining';
                    studyState.currentCardIndex = 0;
                    break;
                case 'Forward Chaining':
                    nextPhase = 'Backward Chaining';
                    studyState.currentCardIndex = currentChunk.length - 1;
                    break;
                case 'Backward Chaining':
                    nextPhase = 'Drag and Drop';
                    break;
                case 'Drag and Drop':
                    if (studyState.currentChunkIndex > 0) {
                        const reviewPool = studyState.sequenceChunks.slice(0, studyState.currentChunkIndex).flat();
                        const reviewCard = reviewPool[Math.floor(Math.random() * reviewPool.length)];

                        nextPhase = 'InterChunkReview';
                        studyState.roundCards = [reviewCard];
                        studyState.currentCardIndex = 0;
                        studyState.nextPhaseAfterReview = (studyState.currentChunkIndex + 1 < studyState.sequenceChunks.length) ? 'Passive Review' : 'CheckWeakest';
                        
                        showToast(`Chunk ${studyState.currentChunkIndex + 1} complete! Quick checkup...`, "success");
                        studyState.currentChunkIndex++;
                        break;
                    }

                    studyState.currentChunkIndex++;
                    if (studyState.currentChunkIndex < studyState.sequenceChunks.length) {
                        nextPhase = 'Passive Review';
                        showToast(`Chunk ${studyState.currentChunkIndex} complete! Starting chunk ${studyState.currentChunkIndex + 1}.`, "success");
                    } else {
                        nextPhase = 'CheckWeakest';
                    }
                    break;

                case 'InterChunkReview':
                    nextPhase = studyState.nextPhaseAfterReview;
                    studyState.nextPhaseAfterReview = null;
                    break;

                case 'CheckWeakest':
                    const knowledgeStates = await getAllDataFromDB('userKnowledgeState');
                    const knowledgeMap = new Map(knowledgeStates.map(item => [item.cardID, item]));
                    const weakestCards = studyState.sequenceCards
                        .map(card => ({ ...card, mastery: knowledgeMap.get(card.id)?.masteryScore || 0.5 }))
                        .filter(card => card.mastery < 0.90)
                        .sort((a, b) => a.mastery - b.mastery)
                        .slice(0, 5);

                    if (weakestCards.length > 0) {
                        nextPhase = 'Weakest Link';
                        studyState.roundCards = weakestCards;
                        studyState.currentCardIndex = 0;
                        showToast("All chunks practiced! Now for a quick review of the tricky items.", "info");
                    } else {
                        const deck = decks[currentDeckId];
                        if (deck.sequenceState) delete deck.sequenceState;
                        await saveDataToDB('decks', deck);
                        showComplete();
                        return;
                    }
                    break;

                case 'Weakest Link':
                    const deck = decks[currentDeckId];
                    if (deck.sequenceState) delete deck.sequenceState;
                    await saveDataToDB('decks', deck);
                    showComplete();
                    return;
            }

            studyState.sequencePhase = nextPhase;
            showNextCard();
        }

        function showAnswer() {
        document.querySelector('#cardView .flashcard').classList.add('is-flipped');
        document.getElementById('cardAnswerContent').classList.remove('hidden');

        if (currentMode === 'sequence') {
            return;
        }

        document.getElementById('showAnswerBtn').classList.add('hidden');
        document.getElementById('checkAnswerBtn').classList.add('hidden');
        
        document.getElementById('correctBtn').classList.remove('hidden');
        document.getElementById('incorrectBtn').classList.remove('hidden');
        document.getElementById('showQuestionBtn').classList.remove('hidden');
        }
        
        function showQuestion() {
            document.querySelector('#cardView .flashcard').classList.remove('is-flipped');
            
            document.getElementById('showQuestionBtn').classList.add('hidden');
            document.getElementById('correctBtn').classList.add('hidden');
            document.getElementById('incorrectBtn').classList.add('hidden');
            document.getElementById('advancedAnswerButtons').classList.add('hidden');

            const isWriteMode = (currentMode === 'learn' && studyState.settings.learnMode === 'write') || (currentMode === 'review' && studyState.settings.reviewMode === 'write');

            if (isWriteMode) {
                document.getElementById('checkAnswerBtn').classList.remove('hidden');
                document.getElementById('dontKnowBtn').classList.toggle('hidden', studyState.isRetypingIncorrect);
            } else {
                document.getElementById('showAnswerBtn').classList.remove('hidden');
            }
        }



        function autoCheckAnswer() {
            const userInput = document.getElementById('writeAnswerInput');
            const card = studyState.roundCards[studyState.currentCardIndex];
            if (!card || userInput.value.trim() === '') return;

            const submissionTime = performance.now();
            const recallLatency = currentInteractionLog.firstKeyPressTime ? Math.round(currentInteractionLog.firstKeyPressTime - currentInteractionLog.questionLoadTime) : null; 
            let answerFluency = 0;
            if (currentInteractionLog.firstKeyPressTime) {
                const typingDuration = submissionTime - currentInteractionLog.firstKeyPressTime;
                if (typingDuration > 0) {
                    const charCount = userInput.value.trim().length;
                    answerFluency = parseFloat((charCount / (typingDuration / 1000))).toFixed(2);
                }
            }
            const userAnswer = userInput.value.trim();
            const correctAnswer = card.answer.trim();

            if (studyState.isRetypingIncorrect) {
                const isCorrectRetype = (userAnswer.toLowerCase() === correctAnswer.toLowerCase());
                if (isCorrectRetype) {
                    studyState.isRetypingIncorrect = false;
                    userInput.classList.add('correct');
                    userInput.disabled = true;
                    const checkBtn = document.getElementById('checkAnswerBtn');
                    checkBtn.classList.add('feedback-correct');
                    setTimeout(() => {
                        checkBtn.classList.remove('feedback-correct'); 
                        moveCard(card, false); 
                    }, 1200); 
                } else {
                    showToast("That's not quite right. Please type the answer exactly as shown.", "error");
                    userInput.value = ''; 
                    userInput.focus();
                }
                return;
            }

            let processedUserAnswer = userAnswer;
            let processedCorrectAnswer = correctAnswer;
            if (!studyState.settings.caseSensitive) {
                processedUserAnswer = processedUserAnswer.toLowerCase();
                processedCorrectAnswer = processedCorrectAnswer.toLowerCase();
            }
            if (!studyState.settings.punctuation) {
                const punc = /[.,/#!$%^&*;:{}=\-_`~()]/g;
                processedUserAnswer = processedUserAnswer.replace(punc, "");
                processedCorrectAnswer = processedCorrectAnswer.replace(punc, "");
            }
            const isCorrect = processedUserAnswer === processedCorrectAnswer;
            const questionTypeForLog = document.getElementById('flashcardViewContainer').classList.contains('hidden') ? 'MultipleChoice' : (document.getElementById('cardQuestion').innerHTML.includes('___________') ? 'Cloze' : 'Type');

            logInteraction({ cardID: card.id, wasCorrect: isCorrect, userAnswer, recallLatency, answerFluency, totalCorrections: 0, attemptCount: 1, questionType: questionTypeForLog });
            
            userInput.classList.toggle('correct', isCorrect);
            userInput.classList.toggle('incorrect', !isCorrect);
            userInput.disabled = true;

            document.querySelector('#cardView .flashcard').classList.add('is-flipped');
            document.getElementById('cardAnswerContent').classList.remove('hidden');
            
            document.getElementById('checkAnswerBtn').classList.add('hidden');
            document.getElementById('dontKnowBtn').classList.add('hidden');

            if (isCorrect) {
                showToast("Correct!", "success");
                setTimeout(() => moveCard(card, true, questionTypeForLog), 1200);
            } else {
                if (studyState.settings.retypeIncorrect) {
                    studyState.isRetypingIncorrect = true;
                    userInput.disabled = false;
                    setTimeout(() => {
                        userInput.value = '';
                        userInput.focus();
                        document.getElementById('checkAnswerBtn').classList.remove('hidden');
                    }, 1000);
                    showToast("Not quite. Type the correct answer to continue.", "error", 3000);
                } else {
                    showToast("Not quite.", "error");
                    setTimeout(() => moveCard(card, false, questionTypeForLog), 2000);
                }
            }
        }

        async function updateUserBaseline() {
            const allLogs = await getAllDataFromDB('interactionLogs');
            const relevantLogs = allLogs.filter(log => log.wasCorrect && log.latency !== null && log.fluency > 0);

            if (relevantLogs.length < 20) return;

            const totalLatency = relevantLogs.reduce((sum, log) => sum + log.latency, 0);
            const totalFluency = relevantLogs.reduce((sum, log) => sum + log.fluency, 0);

            const avgLatency = totalLatency / relevantLogs.length;
            const avgFluency = totalFluency / relevantLogs.length;
            
            globalSettings.userBaseline = {
                latency: avgLatency * 1.2, 
                fluency: avgFluency * 0.9  
            };

            await saveDataToDB('appData', { key: 'userSettings', ...globalSettings });
            console.log("User baseline updated:", globalSettings.userBaseline);
        }

        async function moveCard(card, correct) {
            const cardInDeck = decks[currentDeckId].cards.find(c => c.id === card.id);
            if(cardInDeck) cardInDeck.isNew = false;
     
            const lastLog = currentInteractionLog; 
            const userBaseline = globalSettings.userBaseline || { latency: 1500, fluency: 10 };
            const iqs = calculateIQS({
                recallLatency: lastLog.recallLatency || 2000,
                answerFluency: lastLog.answerFluency || 5,
                totalCorrections: lastLog.backspaceCount + lastLog.deleteCount,
                attemptCount: lastLog.attemptCount || 1
            }, userBaseline);
            
            await updateKnowledgeState(card, correct, iqs);

            const sm2 = new SM2Algorithm();
            const quality = correct ? 4 : 1; 
            if(cardInDeck) cardInDeck.sm2Data = sm2.calculateNextReview(cardInDeck)(quality);
            
            if (currentMode === 'sequence') {
                const currentChunk = studyState.sequenceChunks[studyState.currentChunkIndex];
                
                if (studyState.sequencePhase === 'Forward Chaining') {
                    if (correct) {
                        studyState.currentCardIndex++;
                        if (studyState.currentCardIndex >= currentChunk.length) {
                            moveToNextSequencePhase(); 
                        } else {
                            showNextCard();
                        }
                    } else {
                        showToast("Not quite. Let's try that one again.", "error");
                        showNextCard(); 
                    }
                } else if (studyState.sequencePhase === 'Backward Chaining') {
                    if (correct) {
                        studyState.currentCardIndex--;
                        if (studyState.currentCardIndex < 0) {
                            moveToNextSequencePhase(); 
                        } else {
                            showNextCard();
                        }
                    } else {
                        showToast("Not quite. Let's try that one again.", "error");
                        showNextCard(); 
                    }
                } else if (studyState.sequencePhase === 'InterChunkReview') {
                    studyState.sequencePhase = studyState.nextPhaseAfterReview;
                    studyState.nextPhaseAfterReview = null;
                    moveToNextSequencePhase(); 
                } else if (studyState.sequencePhase === 'Weakest Link') {
                    studyState.currentCardIndex++;
                    if (studyState.currentCardIndex >= studyState.roundCards.length) {
                        moveToNextSequencePhase(); 
                    } else {
                        showNextCard();
                    }
                }
            } else {
                if (currentMode === 'learn' && !correct) {
                    studyState.incorrectInThisRound.push({ ...card });
                }
                
                if (currentMode === 'review') {
                    if (correct) {
                        const index = studyState.stillLearning.findIndex(c => c.id === card.id);
                        if (index > -1) {
                            studyState.stillLearning.splice(index, 1);
                            studyState.correct.push(card);
                        }
                    } else {
                         if (!studyState.lastRoundIncorrect.some(c => c.id === card.id)) {
                            studyState.lastRoundIncorrect.push(card);
                        }
                    }
                }

                studyState.currentCardIndex++;
                showNextCard();
                updateFocusMeter();
            }
            
            await saveDataToDB('decks', decks[currentDeckId]);
        }

        function dontKnowAnswer() {
            const card = studyState.roundCards[studyState.currentCardIndex];
            if (!card) return;

            logInteraction({
                cardID: card.id,
                wasCorrect: false,
                recallLatency: null, 
                answerFluency: 0,
                totalCorrections: 0,
                attemptCount: 1,
                userAnswer: "[Don't Know]"
            });

            showAnswer();
            
            if ((currentMode === 'learn' || currentMode === 'review') && studyState.settings.retypeIncorrect) {
                studyState.isRetypingIncorrect = true;
                const writeInput = document.getElementById('writeAnswerInput');
                writeInput.value = '';
                writeInput.disabled = false;
                writeInput.focus();
                
                document.getElementById('correctBtn').classList.add('hidden');
                document.getElementById('incorrectBtn').classList.add('hidden');
                document.getElementById('dontKnowBtn').classList.add('hidden');
                document.getElementById('checkAnswerBtn').classList.remove('hidden');

                showToast("Type the correct answer to continue.", "error");
            } else {
                markIncorrect(true); 
            }
        }

        
        async function markSpaced(quality) {
            if (!isActionAllowed()) return;
            const card = studyState.roundCards[studyState.currentCardIndex];
            const cardInDeck = decks[currentDeckId].cards.find(c => c.id === card.id);
            if (cardInDeck) {
                const sm2 = new SM2Algorithm();
                cardInDeck.sm2Data = sm2.calculateNextReview(cardInDeck)(quality);
                await saveDataToDB('decks', decks[currentDeckId]);
            }
            studyState.currentCardIndex++;
            showNextCard();
        }

        function markCorrect(isAutomated = false) {
            if (!isAutomated && !isActionAllowed()) return;

            const btn = document.getElementById('correctBtn');
            btn.classList.add('feedback-correct');
            setTimeout(() => {
                btn.classList.remove('feedback-correct');
                if (currentMode === 'spaced') {
                    markSpaced(4);
                } else {
                    moveCard(studyState.roundCards[studyState.currentCardIndex], true);
                }
            }, 200);
        }
        function markIncorrect(isAutomated = false) {
            if (!isAutomated && !isActionAllowed() && document.getElementById('writeAnswerInput').value.trim() !== '') return;

            const isWriteMode = (currentMode === 'learn' && studyState.settings.learnMode === 'write') || (currentMode === 'review' && studyState.settings.reviewMode === 'write');

            if (!isAutomated && isWriteMode && studyState.settings.retypeIncorrect) {
                studyState.isRetypingIncorrect = true;
                const writeInput = document.getElementById('writeAnswerInput');
                writeInput.value = '';
                writeInput.disabled = false;
                writeInput.focus();

                document.getElementById('correctBtn').classList.add('hidden');
                document.getElementById('incorrectBtn').classList.add('hidden');
                document.getElementById('dontKnowBtn').classList.add('hidden'); 
                document.getElementById('checkAnswerBtn').classList.remove('hidden');

                showToast("Type the correct answer to continue.", "error");
                return;
            }

            const btn = document.getElementById('incorrectBtn');
            btn.classList.add('feedback-incorrect');
            setTimeout(() => {
                btn.classList.remove('feedback-incorrect');
                if (currentMode === 'spaced') {
                    markSpaced(1);
                } else {
                    moveCard(studyState.roundCards[studyState.currentCardIndex], false);
                }
            }, 200);
        }
        
        function populateAccentButtons() {
            const accents = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''];
            const container = document.getElementById('accentButtonsContainer');
            container.innerHTML = accents.map(char => `<button onclick="insertAccent('${char}', 'writeAnswerInput')">${char}</button>`).join('');
        }

        function insertAccent(char, targetId) {
            const textarea = document.getElementById(targetId);
            if (!textarea) return; // Exit if the textarea isn't on the page
            const start = textarea.selectionStart;
            const end = textarea.selectionEnd;
            textarea.value = textarea.value.substring(0, start) + char + textarea.value.substring(end);
            textarea.selectionStart = textarea.selectionEnd = start + 1;
            textarea.focus();
        }

        async function toggleAccentButtons() {
            globalSettings.showAccents = !globalSettings.showAccents;
            await saveDataToDB('appData', { key: 'userSettings', ...globalSettings });
            updateAccentButtonsVisibility();
        }

        function updateAccentButtonsVisibility() {
            const container = document.getElementById('accentButtonsContainer');
            if (globalSettings.showAccents) {
                populateAccentButtons();
                container.classList.remove('hidden');
            } else {
                container.classList.add('hidden');
            }
        }

        function populateTestAccentButtons() {
            const accents = ['', '', '', '', '', '', '', '', '', '', '', '', '', '', '', '', ''];
            const container = document.getElementById('testAccentButtonsContainer');
            container.innerHTML = accents.map(char => `<button onclick="insertAccent('${char}', 'testAnswerInput')">${char}</button>`).join('');
        }

        async function toggleTestAccentButtons() {
            globalSettings.showAccents = !globalSettings.showAccents;
            await saveDataToDB('appData', { key: 'userSettings', ...globalSettings });
            updateTestAccentButtonsVisibility();
        }

        function updateTestAccentButtonsVisibility() {
            const container = document.getElementById('testAccentButtonsContainer');
            if (globalSettings.showAccents) {
                populateTestAccentButtons();
                container.classList.remove('hidden');
            } else {
                container.classList.add('hidden');
            }
        }

        function showComplete() {
            const currentSubView = document.querySelector('#studyMode .sub-view:not(.hidden)');
            const completeView = document.getElementById('completeView');
            transitionSubView(currentSubView, completeView);
            document.getElementById('finalStats').innerHTML = `<div class="stat"><div class="stat-value">${studyState.currentRound}</div><div class="stat-label">Total Rounds</div></div><div class="stat"><div class="stat-value">${decks[currentDeckId].cards.length}</div><div class="stat-label">Cards Mastered</div></div>`;
        }

        async function endSession() {
            if (currentDeckId && studyState.startTime) {
                const deck = decks[currentDeckId];
                const cardIdsInDeck = new Set(deck.cards.map(c => c.id));
                const knowledgeStates = await getAllDataFromDB('userKnowledgeState');
                // Calculate how many cards were mastered *before* this session's final updates.
                const masteryCountBefore = knowledgeStates.filter(s => cardIdsInDeck.has(s.cardID) && s.masteryScore >= 0.95).length;
                
                // Now, call the coach with this crucial "before" data.
                await runSmartCoachChecks('sessionEnd', {
                    deckId: currentDeckId,
                    masteryCountBefore: masteryCountBefore 
                });
            }

            if (studyState.startTime) {
                const duration = Math.round((new Date() - studyState.startTime) / 1000);
                analyticsData.totalStudyTime += duration;
                analyticsData.sessions.unshift({
                    date: new Date().toISOString(),
                    deckName: decks[currentDeckId]?.name || 'Unknown Deck',
                    mode: currentMode,
                    duration: duration
                });
                if (analyticsData.sessions.length > 50) analyticsData.sessions.pop();
                await saveDataToDB('appData', { key: 'analytics', ...analyticsData });
            }
            
            await saveStudyProgress();
            await updateUserBaseline();
            
            studyState.isRetypingIncorrect = false;
            backToDashboard();
        }

        function resetProgress() {
            showConfirmModal('Are you sure you want to reset your progress for this deck?', () => restartStudy());
        }
        
        async function restartStudy() {
            const deck = decks[currentDeckId];
            if (!deck) return;

            showToast("Resetting progress for this deck...", "info");

            try {
                const transaction = db.transaction(['userKnowledgeState'], 'readwrite');
                const store = transaction.objectStore('userKnowledgeState');
                
                const resetPromises = deck.cards.map(card => {
                    return new Promise((resolve, reject) => {
                        // This is the default state for a brand new card.
                        const defaultState = {
                            userID: 'default_user',
                            cardID: card.id,
                            masteryScore: 0.5,
                            stability: 1.0,
                            lastReviewed: new Date().toISOString(),
                            recallHistory: []
                        };
                        
                        const request = store.put(defaultState);
                        request.onsuccess = resolve;
                        request.onerror = reject;
                    });
                });

                await Promise.all(resetPromises);

                if (currentMode === 'learn') {
                } else if (currentMode === 'review') {
                    deck.reviewState = { stillLearning: [...deck.cards], correct: [], currentRound: 1, lastRoundIncorrect: [] };
                    await saveDataToDB('decks', deck);
                } else if (currentMode === 'spaced') {
                    const sm2 = new SM2Algorithm();
                    deck.cards.forEach(card => card.sm2Data = sm2.calculateNextReview({})(3));
                    await saveDataToDB('decks', deck);
                }

                showToast("Progress has been reset.", "success");
                
                if (currentMode === 'learn') startLearnMode(currentDeckId);
                else if (currentMode === 'review') startReviewMode(currentDeckId);
                else if (currentMode === 'spaced') startSpacedLearning(currentDeckId);

            } catch (error) {
                console.error("Failed to reset knowledge state:", error);
                showToast("An error occurred while resetting progress.", "error");
            }
        }
        
        function isActionAllowed() {
            if (activeView !== 'studyMode' || document.getElementById('cardView').classList.contains('hidden')) {
                return false;
            }
            const correctBtnHidden = document.getElementById('correctBtn').classList.contains('hidden');
            const advancedBtnsHidden = document.getElementById('advancedAnswerButtons').classList.contains('hidden');
            return !correctBtnHidden || !advancedBtnsHidden;
        }

        function setupKeyboardControls() {
            document.addEventListener('keydown', (e) => {
                if (document.querySelector('.modal.show')) return;

                if (activeView === 'studyMode' && !document.getElementById('progressView').classList.contains('hidden')) {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        document.getElementById('continueBtn').click();
                    }
                    return;
                }

                if (activeView !== 'studyMode' || document.getElementById('cardView').classList.contains('hidden')) return;

                if (currentMode === 'sequence' && (e.key === 'Enter' || e.key === 'ArrowUp')) {
                    const writeInput = document.getElementById('writeAnswerInput');
                    if (!writeInput.classList.contains('hidden') && !writeInput.disabled) {
                        e.preventDefault();
                        checkSequenceAnswer();
                        return; 
                    }
                }

                const advancedButtons = document.getElementById('advancedAnswerButtons');
                const simpleCorrectBtn = document.getElementById('correctBtn');
                const showAnswerBtn = document.getElementById('showAnswerBtn');

                if (!advancedButtons.classList.contains('hidden')) {
                    e.preventDefault(); 
                    switch (e.key) {
                        case '1': markSpaced(1); break;
                        case '2': markSpaced(2); break;
                        case '3': markSpaced(3); break;
                        case '4': markSpaced(4); break;
                    }
                    return;
                }

                if (!simpleCorrectBtn.classList.contains('hidden')) {
                    e.preventDefault();
                    if (e.key === 'ArrowLeft' || e.key === '1') markIncorrect();
                    else if (e.key === 'ArrowRight' || e.key === '2') markCorrect();
                    return;
                }

                if (!showAnswerBtn.classList.contains('hidden')) {
                    if (document.activeElement.tagName === 'TEXTAREA') return;
                    if (e.key === ' ' || e.key === 'Enter') {
                        e.preventDefault();
                        showAnswer();
                    }
                }
            });
        }

    async function toggleStudyMode() {
        if (currentMode !== 'learn') return;
        const deck = decks[currentDeckId];
        if (!deck) return;

        studyState.settings.learnMode = studyState.settings.learnMode === 'write' ? 'flashcard' : 'write';
        deck.settings.learnMode = studyState.settings.learnMode;
        
        await saveDataToDB('decks', deck);
        showToast(`Switched to ${studyState.settings.learnMode} mode.`);
        
        showNextCard();
    }
        
    function shuffleArray(array) {
        const newArray = [...array];
        for (let i = newArray.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [newArray[i], newArray[j]] = [newArray[j], newArray[i]]; }
            return newArray;
        }

        function openDeckSettingsModal(deckId) {
            const deck = decks[deckId];
            if (!deck) return;
            const settings = {...DEFAULT_DECK_SETTINGS, ...(deck.settings || {})};
            
            document.getElementById('caseSensitiveToggle').checked = settings.caseSensitive;
            document.getElementById('punctuationToggle').checked = settings.punctuation;
            document.getElementById('retypeIncorrectToggle').checked = settings.retypeIncorrect;
            document.getElementById('reviewOrder').value = settings.reviewOrder;
            document.querySelector(`input[name="deckSettingsStudyMode"][value="${settings.learnMode}"]`).checked = true;
            document.getElementById('deckSettingsCardsPerRound').value = settings.cardsPerRound;
            
            const adaptiveModes = settings.adaptiveModes || { auto: true, mcq: true, cloze: true };
            document.getElementById('adaptiveAutoToggle').checked = adaptiveModes.auto;
            document.getElementById('adaptiveMcqToggle').checked = adaptiveModes.mcq;
            document.getElementById('adaptiveClozeToggle').checked = adaptiveModes.cloze;
            setupAdaptiveSettings();             
            document.getElementById('deckSettingsModal').classList.add('show');
            setupRadioCardSelection('deckSettingsStudyMode');
        }

        function closeDeckSettingsModal() { document.getElementById('deckSettingsModal').classList.remove('show'); }

        async function saveDeckSettings() {
            const deck = decks[currentViewingDeckId];
            if (!deck) return;
            await completeSaveDeckSettings(deck);
        }
        
        async function completeSaveDeckSettings(deck) {
            deck.settings.caseSensitive = document.getElementById('caseSensitiveToggle').checked;
            deck.settings.punctuation = document.getElementById('punctuationToggle').checked;
            deck.settings.retypeIncorrect = document.getElementById('retypeIncorrectToggle').checked;
            deck.settings.reviewOrder = document.getElementById('reviewOrder').value;
            deck.settings.learnMode = document.querySelector('input[name="deckSettingsStudyMode"]:checked').value;
            deck.settings.adaptiveModes = {
                auto: document.getElementById('adaptiveAutoToggle').checked,
                mcq: document.getElementById('adaptiveMcqToggle').checked,
                cloze: document.getElementById('adaptiveClozeToggle').checked
            };
            deck.settings.cardsPerRound = document.getElementById('deckSettingsCardsPerRound').value;

            await saveDataToDB('decks', deck);
            updateDashboard();
            closeDeckSettingsModal();
            showToast('Settings saved!');
        }

        function showImportModal() {
            const dropdown = document.getElementById('importDeckCategory');
            dropdown.innerHTML = '';
            categories.forEach(cat => dropdown.innerHTML += `<option value="${cat}">${cat}</option>`);
            dropdown.innerHTML += `<option value="add_new_category" style="font-style: italic;">+ Add New Category...</option>`;
            dropdown.onchange = handleCategoryChange; 

            document.getElementById('importModal').classList.add('show');
        }

        async function importData() {
            const name = document.getElementById('importDeckName').value.trim();
            const category = document.getElementById('importDeckCategory').value; 
            const typeHint = document.getElementById('importDeckTypeHint').value; 

            if(!name) { showToast('Please provide a name for the new deck.', 'error'); return; }

            const fileInput = document.getElementById('importFileInput');
            const pastedText = document.getElementById('importPastedText').value;

            if (fileInput.files.length > 0) {
                const file = fileInput.files[0];
                const reader = new FileReader();
                reader.onload = async function(e) {
                    try {
                        if (file.name.endsWith('.json')) {
                            const importedData = JSON.parse(e.target.result);
                            
                            if (importedData.deck && importedData.knowledgeStateData) {
                                const deckData = importedData.deck;
                                const knowledgeData = importedData.knowledgeStateData;

                                const oldIdToNewIdMap = new Map();
                                deckData.cards.forEach(card => {
                                    const oldId = card.id;
                                    const newId = Date.now() + Math.random();
                                    card.id = newId;
                                    oldIdToNewIdMap.set(oldId, newId);
                                });

                                const newDeckId = await createNewDeck(name, category, deckData.cards, deckData.notes || '', typeHint);

                                const transaction = db.transaction(['userKnowledgeState'], 'readwrite');
                                const store = transaction.objectStore('userKnowledgeState');
                                knowledgeData.forEach(state => {
                                    const newCardId = oldIdToNewIdMap.get(state.cardID);
                                    if (newCardId) {
                                        state.cardID = newCardId;
                                        store.put(state);
                                    }
                                });
                                
                                showToast(`Deck "${name}" and its learning progress restored!`, 'success');

                            } else {
                                if (!importedData.name || !Array.isArray(importedData.cards)) throw new Error('Invalid JSON format.');
                                await createNewDeck(name, category, importedData.cards, importedData.notes || '', typeHint);
                                showToast(`Deck "${name}" imported successfully with ${importedData.cards.length} cards!`);
                            }

                        } else if (file.name.endsWith('.csv') || file.name.endsWith('.txt')) {
                            const cards = parseTextData(e.target.result, file.name.endsWith('.csv') ? ',' : '\t');
                             if (cards.length > 0) {
                                await createNewDeck(name, category, cards, '', typeHint);
                                showToast(`Deck "${name}" imported successfully with ${cards.length} cards!`);
                            } else { throw new Error('No valid cards found in file.'); }
                        }
                        closeImportModal();
                        updateDashboard();
                    } catch (error) { showToast(`Error importing file: ${error.message}`, 'error'); }
                };
                reader.readAsText(file);
            } else if (pastedText.trim()) {
                 try {
                    const cards = parseTextData(pastedText.trim(), '\t');
                    if (cards.length > 0) {
                        await createNewDeck(name, category, cards, '', typeHint);
                        showToast(`Deck "${name}" created successfully with ${cards.length} cards!`);
                        closeImportModal();
                        updateDashboard();
                    } else { throw new Error('No valid cards found in text.'); }
                 } catch (error) { showToast(`Error parsing text: ${error.message}`, 'error'); }
            } else {
                showToast('Please select a file or paste text to import.', 'error');
            }
        }
        function closeImportModal() { document.getElementById('importModal').classList.remove('show'); }
        function switchImportTab(tabName) {
            document.getElementById('importContentPaste').classList.toggle('hidden', tabName !== 'paste');
            document.getElementById('importContentFile').classList.toggle('hidden', tabName !== 'file');
            document.getElementById('importTabPaste').classList.toggle('active', tabName === 'paste');
            document.getElementById('importTabFile').classList.toggle('active', tabName === 'file');
        }

        function parseTextData(text, separator) {
            return text.split('\n').map(line => {
                const parts = line.split(separator);
                if (parts.length >= 2 && parts[0].trim() && parts[1].trim()) {
                    return { id: Date.now() + Math.random(), question: parts[0].trim(), answer: parts[1].trim(), isNew: true };
                }
                return null;
            }).filter(Boolean);
        }

        async function compressImage(dataUrl, maxSizeMB = 1) {
            return new Promise((resolve) => {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    const ctx = canvas.getContext('2d');
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.drawImage(img, 0, 0);

                    let quality = 0.9;
                    let compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
                    
                    while (compressedDataUrl.length > maxSizeMB * 1024 * 1024 && quality > 0.1) {
                        quality -= 0.1;
                        compressedDataUrl = canvas.toDataURL('image/jpeg', quality);
                    }
                    resolve(compressedDataUrl);
                };
                img.onerror = () => resolve(dataUrl); 
                img.src = dataUrl;
            });
        }

        function showConfirmModal(text, onConfirm, title = "Confirm Action") {
            const modal = document.getElementById('confirmActionModal');
            document.getElementById('confirmActionTitle').textContent = title;
            document.getElementById('confirmActionText').textContent = text;
            
            const confirmBtn = document.getElementById('confirmActionConfirmBtn');
            const newConfirmBtn = confirmBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);

            newConfirmBtn.addEventListener('click', () => {
                onConfirm();
                cancelAction();
            });
            
            modal.classList.add('show');
        }

        function cancelAction() {
            document.getElementById('confirmActionModal').classList.remove('show');
        }

        function openPracticeTestModal(deckId) {
            practiceTestState.deckId = deckId;
            document.getElementById('numQuestions').max = decks[deckId].cards.length;
            document.getElementById('numQuestions').value = Math.min(10, decks[deckId].cards.length);
            document.getElementById('practiceTestModal').classList.add('show');
        }

        function closePracticeTestModal() {
            document.getElementById('practiceTestModal').classList.remove('show');
        }

        function startPracticeTest() {
            const deckId = practiceTestState.deckId;
            const deck = decks[deckId];
            const testType = document.getElementById('testType').value;
            const numQuestions = parseInt(document.getElementById('numQuestions').value);
            
            if (numQuestions > deck.cards.length) {
                showToast("Not enough cards in deck", "error");
                return;
            }
            
            practiceTestState.cards = shuffleArray([...deck.cards]).slice(0, numQuestions);
            practiceTestState.testType = testType;
            practiceTestState.numQuestions = numQuestions;
            practiceTestState.currentCardIndex = 0;
            practiceTestState.correctCount = 0;
            practiceTestState.incorrectCount = 0;
            practiceTestState.startTime = new Date();
            
            closePracticeTestModal();
            
            showView('practiceTestView');
            document.getElementById('testSubtitle').textContent = deck.name;
            
            updateTestProgress();
            document.getElementById('testProgressView').classList.remove('hidden');
            document.getElementById('testCardView').classList.add('hidden');
            document.getElementById('testCompleteView').classList.add('hidden');
        }

        function updateTestProgress() {
            const total = practiceTestState.numQuestions;
            const current = practiceTestState.currentCardIndex;
            const correct = practiceTestState.correctCount;
            const incorrect = practiceTestState.incorrectCount;
            
            document.getElementById('testInfo').textContent = `${current} of ${total} questions`;
            document.getElementById('testProgressBar').style.width = total > 0 ? `${(current / total) * 100}%` : '0%';
            document.getElementById('testCorrectCount').textContent = correct;
            document.getElementById('testIncorrectCount').textContent = incorrect;
        }

        function startTest() {
            transitionSubView(
                document.getElementById('testProgressView'), 
                document.getElementById('testCardView')
            );
            showNextTestQuestion();
        }

        function showNextTestQuestion() {
            if (practiceTestState.currentCardIndex >= practiceTestState.cards.length) {
                finishTest();
                return;
            }

            const card = practiceTestState.cards[practiceTestState.currentCardIndex];
            const testType = practiceTestState.testType;
            let currentTestType = testType;
            if (testType === 'mixed') {
                currentTestType = Math.random() > 0.5 ? 'multiple_choice' : 'type';
            }

            document.querySelector('#testCardView .flashcard').classList.remove('is-flipped');
            document.getElementById('testQuestion').innerHTML = card.question;
            document.getElementById('testAnswer').innerHTML = card.answer;
            document.getElementById('testAnswerContent').classList.add('hidden');
            document.getElementById('testOptions').classList.add('hidden');
            document.getElementById('testAnswerInput').classList.add('hidden');
            document.getElementById('testShowAnswerBtn').classList.add('hidden');
            document.getElementById('testCheckAnswerBtn').classList.add('hidden');
            document.getElementById('testCorrectBtn').classList.add('hidden');
            document.getElementById('testIncorrectBtn').classList.add('hidden');
            document.getElementById('testNextBtn').classList.add('hidden');
            document.getElementById('testAccentToggleBtn').classList.add('hidden'); 
            testAnswerInput.classList.remove('correct', 'incorrect');
            document.getElementById('testCardInfo').textContent =
                `Question ${practiceTestState.currentCardIndex + 1} of ${practiceTestState.numQuestions}`;

            if (currentTestType === 'multiple_choice') {
                const options = generateMultipleChoiceOptions(card, practiceTestState.cards);
                displayMultipleChoiceOptions(options);
            } else if (currentTestType === 'type') {
                document.getElementById('testAnswerInput').classList.remove('hidden');
                document.getElementById('testAnswerInput').value = '';
                document.getElementById('testAnswerInput').disabled = false;
                document.getElementById('testCheckAnswerBtn').classList.remove('hidden');
                document.getElementById('testAnswerInput').focus();

                // --- ADD THESE TWO LINES TO SHOW ACCENT FEATURES ---
                document.getElementById('testAccentToggleBtn').classList.remove('hidden');
                updateTestAccentButtonsVisibility(); // Check if buttons should be shown

            } else {
                document.getElementById('testShowAnswerBtn').classList.remove('hidden');
            }
        }

        function generateMultipleChoiceOptions(correctCard, allCards) {
            const options = new Set([correctCard.answer]);
            const wrongAnswers = shuffleArray(allCards.filter(card => card.id !== correctCard.id));
            
            for (const wrongCard of wrongAnswers) {
                if (options.size < 4) {
                    options.add(wrongCard.answer);
                } else {
                    break;
                }
            }
            return shuffleArray(Array.from(options));
        }

        function displayMultipleChoiceOptions(options) {
            const optionsContainer = document.getElementById('testOptions');
            optionsContainer.innerHTML = '';
            optionsContainer.classList.remove('hidden');
            
            options.forEach((option) => {
                const button = document.createElement('button');
                button.className = 'btn btn-secondary';
                button.textContent = option;
                button.onclick = () => {
                    checkTestAnswer(option);
                    document.querySelectorAll('#testOptions button').forEach(btn => btn.disabled = true);
                };
                optionsContainer.appendChild(button);
            });
        }

        function checkTestAnswer(selectedOption = null) {
            const card = practiceTestState.cards[practiceTestState.currentCardIndex];
            const isMultipleChoice = selectedOption !== null;
            
            const userInput = isMultipleChoice ? selectedOption : document.getElementById('testAnswerInput').value.trim();
            const correctAnswer = card.answer.trim();
            
            const isCorrect = userInput.toLowerCase() === correctAnswer.toLowerCase();
            
            if (isMultipleChoice) {
                document.querySelectorAll('#testOptions button').forEach(btn => {
                    if (btn.textContent === selectedOption) {
                        btn.className = isCorrect ? 'btn btn-success' : 'btn btn-danger';
                    }
                    if (btn.textContent === correctAnswer && !isCorrect) {
                        btn.className = 'btn btn-success';
                    }
                });
            } else {
                document.getElementById('testAnswerInput').classList.toggle('correct', isCorrect);
                document.getElementById('testAnswerInput').classList.toggle('incorrect', !isCorrect);
                document.getElementById('testAnswerInput').disabled = true;
            }
            
            document.getElementById('testCheckAnswerBtn').classList.add('hidden');
            document.getElementById('testAnswerContent').classList.remove('hidden');
            document.querySelector('#testCardView .flashcard').classList.add('is-flipped');
            document.getElementById('testNextBtn').classList.remove('hidden');
            
            if (isCorrect) practiceTestState.correctCount++;
            else practiceTestState.incorrectCount++;
        }

        function showTestAnswer() {
            document.querySelector('#testCardView .flashcard').classList.add('is-flipped');
            document.getElementById('testAnswerContent').classList.remove('hidden');
            document.getElementById('testShowAnswerBtn').classList.add('hidden');
            document.getElementById('testCorrectBtn').classList.remove('hidden');
            document.getElementById('testIncorrectBtn').classList.remove('hidden');
        }

        function markTestCorrect() {
            practiceTestState.correctCount++;
            nextTestQuestion();
        }

        function markTestIncorrect() {
            practiceTestState.incorrectCount++;
            nextTestQuestion();
        }

        function nextTestQuestion() {
            practiceTestState.currentCardIndex++;
            updateTestProgress();
            showNextTestQuestion();
        }

        async function finishTest() {
            const endTime = new Date();
            const timeTaken = Math.round((endTime - practiceTestState.startTime) / 1000);
            const totalAnswered = practiceTestState.correctCount + practiceTestState.incorrectCount;
            const accuracy = totalAnswered > 0 ? Math.round((practiceTestState.correctCount / totalAnswered) * 100) : 0;
            const score = practiceTestState.numQuestions > 0 ? Math.round((practiceTestState.correctCount / practiceTestState.numQuestions) * 100) : 0;
            
            document.getElementById('testScore').textContent = score;
            document.getElementById('testCorrectFinal').textContent = practiceTestState.correctCount;
            document.getElementById('testTotalFinal').textContent = practiceTestState.numQuestions;
            document.getElementById('testTime').textContent = `${timeTaken}s`;
            document.getElementById('testAccuracy').textContent = `${accuracy}%`;
            
            analyticsData.totalStudyTime += timeTaken;
            analyticsData.sessions.unshift({
                date: new Date().toISOString(),
                deckName: decks[practiceTestState.deckId].name,
                mode: 'Practice Test',
                duration: timeTaken,
                accuracy: accuracy
            });
             if (analyticsData.sessions.length > 50) analyticsData.sessions.pop();
            await saveDataToDB('appData', { key: 'analytics', ...analyticsData });
            
            transitionSubView(
                document.getElementById('testCardView'), 
                document.getElementById('testCompleteView')
            );
        }

        function restartTest() {
            practiceTestState.currentCardIndex = 0;
            practiceTestState.correctCount = 0;
            practiceTestState.incorrectCount = 0;
            practiceTestState.startTime = new Date();
            
            transitionSubView(
                document.getElementById('testCompleteView'), 
                document.getElementById('testProgressView')
            );
        }

        function endTest() {
            showView('dashboard');
        }
        
        async function updateStreak() {
            const today = new Date().setHours(0, 0, 0, 0);
            const lastUsedDate = analyticsData.lastUsed ? new Date(analyticsData.lastUsed).setHours(0, 0, 0, 0) : null;

            if (lastUsedDate) {
                const yesterday = new Date(today);
                yesterday.setDate(yesterday.getDate() - 1);

                if (lastUsedDate === yesterday.getTime()) {
                    analyticsData.streak++;
                } else if (lastUsedDate < yesterday.getTime()) {
                    analyticsData.streak = 1;
                }
            } else {
                analyticsData.streak = 1;
            }

            analyticsData.lastUsed = new Date(today).toISOString();
            await saveDataToDB('appData', { key: 'analytics', ...analyticsData });
        }

        function showAnalyticsModal() {
            document.getElementById('analyticsStreak').textContent = `${analyticsData.streak} day${analyticsData.streak === 1 ? '' : 's'}`;
            const totalMinutes = Math.round(analyticsData.totalStudyTime / 60);
            document.getElementById('analyticsTotalTime').textContent = `${totalMinutes}m`;

            const sessionList = document.getElementById('analyticsSessionList');
            if (analyticsData.sessions.length > 0) {
                sessionList.innerHTML = analyticsData.sessions.map(s => {
                    const date = new Date(s.date).toLocaleString();
                    const duration = `${Math.round(s.duration / 60)}m`;
                    const accuracyText = s.accuracy !== undefined ? ` - ${s.accuracy}% acc` : '';
                    return `<div class="deck-card-item">${date}: Studied "${s.deckName}" (${s.mode}) for ${duration}${accuracyText}</div>`;
                }).join('');
            } else {
                sessionList.innerHTML = '<p style="color: var(--secondary-text); text-align: center;">No study sessions recorded yet.</p>';
            }

            document.getElementById('analyticsModal').classList.add('show');
        }

        window.onclick = function(event) {
            document.querySelectorAll('.modal').forEach(modal => { if (event.target === modal) modal.classList.remove('show'); });
        }
        function levenshteinDistance(s1, s2) {
            s1 = s1.toLowerCase();
            s2 = s2.toLowerCase();

            const costs = [];
            for (let i = 0; i <= s1.length; i++) {
                let lastValue = i;
                for (let j = 0; j <= s2.length; j++) {
                    if (i === 0) {
                        costs[j] = j;
                    } else {
                        if (j > 0) {
                            let newValue = costs[j - 1];
                            if (s1.charAt(i - 1) !== s2.charAt(j - 1)) {
                                newValue = Math.min(Math.min(newValue, lastValue), costs[j]) + 1;
                            }
                            costs[j - 1] = lastValue;
                            lastValue = newValue;
                        }
                    }
                }
                if (i > 0) costs[s2.length] = lastValue;
            }
            return costs[s2.length];
        }

        function setupRadioCardSelection(radioGroupName) {
            const radioInputs = document.querySelectorAll(`input[name="${radioGroupName}"]`);
            
            function updateSelection() {
                radioInputs.forEach(input => {
                    const parentCard = input.closest('.checkbox-group');
                    if (parentCard) {
                        parentCard.classList.toggle('is-selected', input.checked);
                    }
                });
            }

            radioInputs.forEach(input => {
                input.addEventListener('change', updateSelection);
                const parentCard = input.closest('.checkbox-group');
                if (parentCard) {
                    parentCard.addEventListener('click', () => {
                        if (!input.checked) {
                            input.checked = true;
                            input.dispatchEvent(new Event('change'));
                        }
                    });
                }
            });
            
            updateSelection();
        }

        // --- REPLACE THE ENTIRE FUNCTION WITH THIS ---
        function calculateIQS(logData, userBaseline = { latency: 1500, fluency: 10 }) {
            const recallLatency = (typeof logData.recallLatency === 'number') ? logData.recallLatency : userBaseline.latency;
            const answerFluency = (typeof logData.answerFluency === 'number') ? logData.answerFluency : 0;
            const totalCorrections = (typeof logData.totalCorrections === 'number') ? logData.totalCorrections : 0;
            const attemptCount = (typeof logData.attemptCount === 'number' && logData.attemptCount > 0) ? logData.attemptCount : 1;
            const v_latency = 1 - (Math.min(recallLatency / userBaseline.latency, 2) / 2);
            const v_fluency = Math.min(answerFluency / userBaseline.fluency, 1.5) / 1.5;
            const v_corrections = 1 / (1 + totalCorrections);
            const v_attempts = 1 / attemptCount;
            const W_latency = 0.30;
            const W_fluency = 0.20;
            const W_corrections = 0.25;
            const W_attempts = 0.25;
            const iqs = (W_latency * v_latency) + (W_fluency * v_fluency) + (W_corrections * v_corrections) + (W_attempts * v_attempts);

            return isNaN(iqs) ? 0.5 : Math.max(0, Math.min(1, iqs));
        }

        async function fetchLatestDownloads() {
            const repo = 'TJ7755/Lagiote-Revise';
            const apiUrl = `https://api.github.com/repos/${repo}/releases`;
            const container = document.getElementById('download-buttons-container');

            container.innerHTML = `<p style="color: var(--secondary-text);">Loading latest downloads...</p>`;


            try {
                const response = await fetch(apiUrl);
                if (!response.ok) throw new Error(`GitHub API error: ${response.status}`);
                const data = await response.json();

                if (!Array.isArray(data) || data.length === 0) {
                    container.innerHTML = `<p style="color: var(--secondary-text);">No releases found for this repository.</p>`;
                    return;
                }
                const latestRelease = data[0];
                
                if (latestRelease && latestRelease.assets && latestRelease.assets.length > 0) {
                    container.innerHTML = ''; 
                    
                    const winAsset = latestRelease.assets.find(a => a.name.endsWith('.exe'));
                    const macAsset = latestRelease.assets.find(a => a.name.endsWith('.dmg'));

                    if (winAsset) {
                        const winBtn = document.createElement('a');
                        winBtn.href = winAsset.browser_download_url;
                        winBtn.className = 'btn';
                        winBtn.innerHTML = `Download for Windows`;
                        container.appendChild(winBtn);
                    }
                    
                    if (macAsset) {
                        const macBtn = document.createElement('a');
                        macBtn.href = macAsset.browser_download_url;
                        macBtn.className = 'btn';
                        macBtn.innerHTML = `Download for Mac`;
                        container.appendChild(macBtn);
                    }

                    if (!winAsset && !macAsset) {
                        container.innerHTML = `<p style="color: var(--secondary-text);">No compatible downloads found in the latest release.</p>`;
                    }
                    
                } else {
                    container.innerHTML = `<p style="color: var(--secondary-text);">Could not find any download files in the latest release.</p>`;
                }
            } catch (error) {
                console.error('Failed to fetch downloads:', error);
                container.innerHTML = `<p style="color: var(--secondary-text);">Failed to load downloads. Please try again later.</p>`;
            }
        }
        
        function calculateFocusScore(log) {
            const TARGET_LATENCY = 3000; 
            const MAX_LATENCY = 15000;   
            const latency = log.latency === null ? TARGET_LATENCY : log.latency;

            let latencyScore = 1.0;
            if (latency > TARGET_LATENCY) {
                if (latency >= MAX_LATENCY) {
                    latencyScore = 0.0;
                } else {
                    latencyScore = 1.0 - ((latency - TARGET_LATENCY) / (MAX_LATENCY - TARGET_LATENCY));
                }
            }

            const awayDuration = log.awayDuration || 0;
            if (awayDuration > 0) {
                const PENALTY_PER_SECOND = 0.20; 
                const distractionPenalty = (awayDuration / 1000) * PENALTY_PER_SECOND;
                
                const finalScore = Math.max(0, latencyScore - distractionPenalty);
                return finalScore;
            }
            
            return latencyScore;
        }

        function updateFocusMeter() {
            if (!db) return;
            const transaction = db.transaction(['interactionLogs'], 'readonly');
            const store = transaction.objectStore('interactionLogs');
            const request = store.getAll();
            request.onsuccess = () => {
                const allLogs = request.result;
                const recentLogs = allLogs.slice(-7);
                if (recentLogs.length < 3) return;

                const focusScores = recentLogs.map(log => calculateFocusScore(log));
                const averageFocusScore = focusScores.reduce((sum, score) => sum + score, 0) / focusScores.length;
                
                lastKnownFocusScore = averageFocusScore;

                const focusDot = document.getElementById('focusDot');
                if (averageFocusScore >= 0.85) {
                    focusDot.style.backgroundColor = '#38a169';
                } else if (averageFocusScore >= 0.65) {
                    focusDot.style.backgroundColor = '#f6ad55';
                } else {
                    focusDot.style.backgroundColor = '#fc8181';
                    if (studyState.currentCardIndex > 5) {
                        document.getElementById('takeABreakModal').classList.add('show');
                    }
                }
            };
        }

        async function updateKnowledgeState(card, wasCorrect, iqs = 0.5, questionType = 'Flashcard') {
            if (!db) return;

            return new Promise((resolve, reject) => {
                const transaction = db.transaction(['userKnowledgeState'], 'readwrite');
                const store = transaction.objectStore('userKnowledgeState');
                
                transaction.oncomplete = () => {
                    resolve(); 
                };
                transaction.onerror = (event) => {
                    console.error("Database transaction error:", event.target.error);
                    reject(event.target.error); 
                };

                const request = store.get(['default_user', card.id]);

                request.onsuccess = () => {
                    let state = request.result;

                    if (!state) { 
                        state = {
                            userID: 'default_user', cardID: card.id, masteryScore: 0.5,
                            stability: 1.0, lastReviewed: new Date().toISOString(), recallHistory: []
                        };
                    }

                    // Defensively get oldMastery and oldStability
                    const oldMastery = (typeof state.masteryScore === 'number' && !isNaN(state.masteryScore)) ? state.masteryScore : 0.5;
                    const oldStability = (typeof state.stability === 'number' && !isNaN(state.stability)) ? state.stability : 1.0;

                    let performanceModifier;
                    if (wasCorrect) {
                        // High reward for harder questions
                        const gainModifiers = { 'MultipleChoice': 1.0, 'Cloze': 1.25, 'Type': 1.5, 'Flashcard': 1.0 };
                        performanceModifier = gainModifiers[questionType] || 1.0;
                    } else {
                        const lossModifiers = { 'MultipleChoice': 1.5, 'Cloze': 1.25, 'Type': 1.0, 'Flashcard': 1.0 };
                        performanceModifier = lossModifiers[questionType] || 1.0;
                    }

                    let performanceWeight;
                    if (oldMastery < 0.6) performanceWeight = 0.4;
                    else if (oldMastery < 0.9) performanceWeight = 0.25;
                    else performanceWeight = 0.1;

                    // Apply our dynamic modifier to the learning rate
                    performanceWeight *= performanceModifier;

                    const raw_performance = wasCorrect ? (0.5 + (iqs * 0.5)) : 0; 
                    const performance = raw_performance;
                    const newMastery = (oldMastery * (1 - performanceWeight)) + (performance * performanceWeight);

                    let newStability;
                    if (wasCorrect) newStability = oldStability + (0.1 * oldMastery * performanceModifier); // Also boost stability gain
                    else newStability = oldStability - (0.2 * oldMastery);
                    
                    state.masteryScore = Math.max(0.01, Math.min(0.99, newMastery)); 
                    state.stability = Math.max(0.1, newStability); 
                    state.lastReviewed = new Date().toISOString();
                    state.recallHistory.push({ date: state.lastReviewed, wasCorrect });

                    store.put(state);
                };
                
                request.onerror = (event) => {
                    console.error("Could not retrieve knowledge state for card:", event.target.error);
                    reject(event.target.error);
                };
            });
        }

        function calculatePRecall(stability, lastReviewedISO) {
            if (!lastReviewedISO || !stability) return 0.5; 
            const now = new Date();
            const lastReviewed = new Date(lastReviewedISO);
            const elapsedDays = (now.getTime() - lastReviewed.getTime()) / (1000 * 3600 * 24);

            return Math.pow(2, -elapsedDays / stability);
        }

        async function updateDueCardCounts() {
            const knowledgeStates = await getAllDataFromDB('userKnowledgeState');
            const knowledgeMap = new Map(knowledgeStates.map(item => [item.cardID, item]));

            for (const deckId in decks) {
                const deck = decks[deckId];
                let dueCount = 0;
                deck.cards.forEach(card => {
                    const state = knowledgeMap.get(card.id);
                    if (!state) { 
                        dueCount++;
                    } else {
                        const pRecall = calculatePRecall(state.stability, state.lastReviewed);
                        if (pRecall <= 0.90) {
                            dueCount++;
                        }
                    }
                });

                const spacedBtn = document.querySelector(`.deck-card[data-deck-id="${deckId}"] .spaced-btn`);
                if (spacedBtn) {
                    const existingBadge = spacedBtn.querySelector('.due-badge');
                    if (existingBadge) existingBadge.remove();

                    if (dueCount > 0) {
                        const badge = document.createElement('span');
                        badge.className = 'due-badge';
                        badge.textContent = dueCount;
                        badge.style.cssText = 'background-color: var(--danger-color); color: white; border-radius: 50%; padding: 2px 6px; font-size: 10px; margin-left: 8px;';
                        spacedBtn.appendChild(badge);
                    }
                }
            }
        }

        function determineCardArchetype(card, deckTypeHint = 'General') {
            if (deckTypeHint === 'Sequence') return 'SequenceItem';

            const q = card.question.trim();
            const a = card.answer.trim();

            if (q.split(' ').length <= 3 && a.split(' ').length > 3) {
                return 'Vocabulary';
            }
            if (q.endsWith('?')) {
                return 'Q&A';
            }
            if (a.split(' ').length <= 3 && q.split(' ').length > 3) {
                return 'Definition';
            }
            if (q.includes('...') || q.includes('___')) {
                return 'Cloze';
            }
            
            return 'General';
        }

        let nlp_pipeline = null;
        async function processDeckContent(deck) {
            const concepts = {};
            let conceptCounter = 0;

            for (const card of deck.cards) {
                card.archetype = determineCardArchetype(card, deck.typeHint || 'General');

                const firstWord = card.question.split(' ')[0].toLowerCase();
                if (!concepts[firstWord]) {
                    concepts[firstWord] = `c${conceptCounter++}`;
                }
                card.conceptID = concepts[firstWord];
            }
            deck.analysisVersion = CURRENT_ANALYSIS_VERSION;
            console.log("Deck content processed:", deck);
        }

        async function startSequenceSession(deckId) {
            currentMode = 'sequence';
            currentDeckId = deckId;
            const deck = decks[deckId];
            
            const sequenceCards = [...deck.cards].sort((a, b) => a.order - b.order);

            if (sequenceCards.length < 2) {
                showToast("A sequence requires at least 2 cards.", "error");
                return;
            }

            const chunkSize = 5;
            studyState.sequenceChunks = [];
            for (let i = 0; i < sequenceCards.length; i += chunkSize) {
                studyState.sequenceChunks.push(sequenceCards.slice(i, i + chunkSize));
            }

            studyState.settings = deck.settings;
            studyState.sequenceCards = sequenceCards;
            studyState.currentRound = 1;
            studyState.startTime = new Date();

            if (deck.sequenceState && deck.sequenceState.currentChunkIndex < studyState.sequenceChunks.length) {
                studyState.currentChunkIndex = deck.sequenceState.currentChunkIndex;
                studyState.sequencePhase = deck.sequenceState.sequencePhase;
                showToast(`Resuming from Chunk ${studyState.currentChunkIndex + 1}...`, "info");
            } else {
                studyState.currentChunkIndex = 0;
                studyState.sequencePhase = null; 
            }
            
            showView('studyMode');
            document.getElementById('studyTitle').textContent = 'Sequence Learner';
            document.getElementById('studySubtitle').textContent = deck.name;
            
            document.getElementById('progressView').classList.add('hidden'); 
            transitionSubView(null, document.getElementById('cardView'));
            
            if (studyState.sequencePhase) {
                showNextCard(); 
            } else {
                moveToNextSequencePhase(); 
            }
        }

        function selectOptimalQuestionType(card) {
            const settings = studyState.settings.adaptiveModes || { auto: true, mcq: true, cloze: true };
            const mastery = studyState.knowledgeStates.get(card.id)?.masteryScore || 0.5;
            const allCardsInDeck = decks[currentDeckId].cards;

            if (!settings.auto) {
                if (settings.cloze && canGenerateQuestionType('Cloze', card, allCardsInDeck)) return 'Cloze';
                if (settings.mcq && canGenerateQuestionType('MultipleChoice', card, allCardsInDeck)) return 'MultipleChoice';
                return studyState.settings.learnMode === 'write' ? 'Type' : 'Flashcard';
            }

            if (mastery < 0.6) {
                if (canGenerateQuestionType('MultipleChoice', card, allCardsInDeck)) {
                    return 'MultipleChoice';
                }
            }

            if (mastery < 0.85) {
                if (canGenerateQuestionType('Cloze', card, allCardsInDeck)) {
                    return 'Cloze';
                }
            }

            if (canGenerateQuestionType('Type', card, allCardsInDeck)) {
                return 'Type';
            }

            return 'Flashcard';
        }

        async function generateAndDisplayMCQ(correctCard, allCardsInDeck) {
            const optionsContainer = document.getElementById('mcqOptions');
            
            const preGeneratedDistractors = studyState.preGeneratedDistractors.get(correctCard.id);

            if (preGeneratedDistractors && preGeneratedDistractors.length >= 3) {
                const finalOptions = shuffleArray([correctCard.answer, ...preGeneratedDistractors.slice(0, 3)]);
                displayMCQButtons(finalOptions, correctCard);
            } else {
                if (isOnline) {
                    showToast("Couldn't generate smart options, using random.", "error");
                }
                console.warn("No pre-generated distractors found in cache (or offline), falling back to random.");
                
                const options = new Set([correctCard.answer]);
                const randomFill = shuffleArray(allCardsInDeck.filter(card => card.id !== correctCard.id));
                for (const randomCard of randomFill) {
                    if (options.size < 4) options.add(randomCard.answer);
                    else break;
                }
                const finalOptions = shuffleArray(Array.from(options));
                displayMCQButtons(finalOptions, correctCard);
            }
        }

        function displayMCQButtons(options, correctCard) {
            const optionsContainer = document.getElementById('mcqOptions');
            optionsContainer.innerHTML = ''; 

            options.forEach(optionText => {
                const button = document.createElement('button');
                button.className = 'btn btn-secondary';
                button.textContent = optionText;
                button.onclick = () => {
                    optionsContainer.querySelectorAll('button').forEach(btn => btn.disabled = true);
                    
                    const isCorrect = (optionText === correctCard.answer);
                    
                    button.classList.remove('btn-secondary');
                    button.classList.add(isCorrect ? 'btn-success' : 'btn-danger');

                    if (!isCorrect) {
                        optionsContainer.querySelectorAll('button').forEach(btn => {
                            if (btn.textContent === correctCard.answer) {
                                btn.classList.remove('btn-secondary');
                                btn.classList.add('btn-success');
                            }
                        });
                    }
                    
                    logInteraction({ cardID: correctCard.id, wasCorrect: isCorrect, userAnswer: optionText, questionType: 'MultipleChoice', recallLatency: null, answerFluency: 0, totalCorrections: 0, attemptCount: 1 });
                    setTimeout(() => moveCard(correctCard, isCorrect, 'MultipleChoice'), 1500);
                };
                optionsContainer.appendChild(button);
            });
        }

        function setupAdaptiveSettings() {
            const autoToggle = document.getElementById('adaptiveAutoToggle');
            const mcqToggle = document.getElementById('adaptiveMcqToggle');
            const clozeToggle = document.getElementById('adaptiveClozeToggle');

            function handleAutoToggle() {
                const isAuto = autoToggle.checked;
                mcqToggle.disabled = isAuto;
                clozeToggle.disabled = isAuto;
                if (isAuto) {
                    mcqToggle.checked = true;
                    clozeToggle.checked = true;
                }
            }
            autoToggle.onchange = handleAutoToggle;
            handleAutoToggle(); 
        }
        function canGenerateQuestionType(type, card, allCardsInDeck) {
            switch (type) {
                case 'MultipleChoice':
                    return allCardsInDeck.length >= 4;
                case 'Cloze':
                    return card.question.toLowerCase().includes(card.answer.toLowerCase());
                case 'Type':
                    return true;
                default:
                    return false;
            }
        }

        async function checkForOutdatedAnalysis() {
            let decksToUpdate = [];
            for (const deckId in decks) {
                const deck = decks[deckId];
                if (!deck.analysisVersion || deck.analysisVersion < CURRENT_ANALYSIS_VERSION) {
                    decksToUpdate.push(deck);
                }
            }

            if (decksToUpdate.length > 0) {
                showToast(`Upgrading ${decksToUpdate.length} deck(s) with new intelligence features...`, "info", 3000);
                for (const deck of decksToUpdate) {
                    await processDeckContent(deck);
                    await saveDataToDB('decks', deck);
                }
                showToast("Deck upgrades complete!", "success");
                await updateDashboard(); 
            }
        }

        function calculateCosineSimilarity(vecA, vecB) {
            let dotProduct = 0;
            let magnitudeA = 0;
            let magnitudeB = 0;
            for (let i = 0; i < vecA.length; i++) {
                dotProduct += vecA[i] * vecB[i];
                magnitudeA += vecA[i] * vecA[i];
                magnitudeB += vecB[i] * vecB[i];
            }
            magnitudeA = Math.sqrt(magnitudeA);
            magnitudeB = Math.sqrt(magnitudeB);
            if (magnitudeA && magnitudeB) {
                return dotProduct / (magnitudeA * magnitudeB);
            } else {
                return 0;
            }
        }

        class NlpPipeline {
            static task = 'feature-extraction';
            static model = 'Xenova/all-MiniLM-L6-v2';
            static instance = null;

            static async getInstance(progress_callback = null) {
                if (this.instance === null) {
                    const { pipeline } = await import('https://cdn.jsdelivr.net/npm/@xenova/transformers@2.17.1');
                    this.instance = pipeline(this.task, this.model, { progress_callback });
                }
                return this.instance;
            }
        }
        async function preGenerateAdaptiveQuestions(roundCards, progressCallback) {
            if (!isOnline) {
                console.log("Offline mode: Skipping pre-generation.");
                progressCallback(1, 1);
                return;
            }

            studyState.preGeneratedDistractors.clear();

            const cardsToGenerate = roundCards.filter(card => card.questionTypeToShow === 'MultipleChoice');
            
            if (cardsToGenerate.length === 0) {
                progressCallback(1, 1);
                return;
            }

            let completedJobs = 0;
            const totalJobs = cardsToGenerate.length;
            progressCallback(completedJobs, totalJobs);

            const generationPromises = cardsToGenerate.map(card => {
                return window.electronAPI.generateDistractors({
                    question: card.question,
                    answer: card.answer
                }).then(distractors => {
                    if (distractors && distractors.length >= 3) {
                        studyState.preGeneratedDistractors.set(card.id, distractors);
                    }
                }).catch(error => {
                    console.error(`Failed to pre-generate for card: ${card.question}`, error);
                }).finally(() => {
                    completedJobs++;
                    progressCallback(completedJobs, totalJobs);
                });
            });

            await Promise.all(generationPromises);
        }

        function updateOnlineStatusUI() {
            const statusDot = document.getElementById('onlineStatusDot');
            const statusText = document.getElementById('onlineStatusText');

            if (isOnline) {
                statusDot.style.backgroundColor = 'var(--success-color)';
                statusText.textContent = 'Online';
                statusText.style.color = 'var(--secondary-text)';
            } else {
                statusDot.style.backgroundColor = 'var(--danger-color)';
                statusText.textContent = 'Offline';
                statusText.style.color = 'var(--danger-color)';
            }
        }

        function showAiGenerator() {
            showView('aiGenerator');
            documentsForAi = []; 
            renderDocumentList();
            renderAiGeneratedCards([]); 
            document.getElementById('flashcard-summary').classList.add('hidden');
        }

        function switchAiTab(tabName) {
            document.getElementById('aiContentInput').classList.toggle('hidden', tabName !== 'input');
            document.getElementById('aiContentCustomise').classList.toggle('hidden', tabName !== 'customise');
            document.getElementById('aiTabInput').classList.toggle('active', tabName === 'input');
            document.getElementById('aiTabCustomise').classList.toggle('active', tabName === 'customise');
        }

        function renderDocumentList() {
            const listContainer = document.getElementById('document-list');

            if (documentsForAi.length === 0) {
                listContainer.innerHTML = `
                    <div id="empty-doc-list" class="list-empty-state">
                        <div class="list-empty-state-icon"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M19.5 14.25v-2.625a3.375 3.375 0 0 0-3.375-3.375h-1.5A1.125 1.125 0 0 1 13.5 7.125v-1.5a3.375 3.375 0 0 0-3.375-3.375H8.25m2.25 0H5.625c-.621 0-1.125.504-1.125 1.125v17.25c0 .621.504 1.125 1.125 1.125h12.75c.621 0 1.125-.504 1.125-1.125V11.25a9 9 0 0 0-9-9Z" /></svg></div>
                        <p>Your uploaded documents will appear here.</p>
                    </div>`;
            } else {
                listContainer.innerHTML = documentsForAi.map((doc, index) => `
                    <div class="document-item" data-doc-id="${doc.id}">
                        <div class="document-item-header">
                            <span class="document-name">
                                <span class="document-status-icon">${doc.status === 'processing' ? '<div class="spinner"></div>' : (doc.status === 'done' ? '' : '')}</span>
                                ${doc.name}
                            </span>
                            <button class="remove-doc-btn" onclick="removeDocument(${index})">&times;</button>
                        </div>
                        <div class="document-info">${doc.type}</div>
                    </div>
                `).join('');
            }
            document.getElementById('doc-list-count').textContent = `Documents (${documentsForAi.length})`;
            document.getElementById('process-btn').disabled = documentsForAi.length === 0;
        }

        async function handleAiFiles(files) {
            for (const file of files) {
                const doc = {
                    id: Date.now() + Math.random(),
                    name: file.name,
                    type: file.type || 'text/plain',
                    content: null,
                    status: 'processing'
                };
                documentsForAi.push(doc);
                renderDocumentList();

                try {
                    doc.content = await readFileContent(file);
                    doc.status = 'done';
                } catch (error) {
                    console.error("Error reading file:", error);
                    doc.status = 'error';
                    showToast(`Failed to read ${file.name}`, 'error');
                }
                renderDocumentList(); 
            }
        }

        function readFileContent(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        if (file.type === 'application/pdf') {
                            const pdf = await pdfjsLib.getDocument({ data: e.target.result }).promise;
                            let text = '';
                            for (let i = 1; i <= pdf.numPages; i++) {
                                const page = await pdf.getPage(i);
                                const content = await page.getTextContent();
                                text += content.items.map(item => item.str).join(' ') + '\n';
                            }
                            resolve(text);
                        } else if (file.type === 'application/vnd.openxmlformats-officedocument.wordprocessingml.document') {
                            const result = await mammoth.extractRawText({ arrayBuffer: e.target.result });
                            resolve(result.value);
                        } else if (file.type.startsWith('text/')) {
                            const decoder = new TextDecoder('utf-8');
                            resolve(decoder.decode(e.target.result));
                        } else if (file.type.startsWith('image/')) {
                            resolve(e.target.result); // This is already correct (reads as Data URL)
                        } else {
                            reject(new Error(`Unsupported file type: ${file.type}`));
                        }
                    } catch (error) {
                        reject(error);
                    }
                };
                reader.onerror = reject;

                if (file.type.startsWith('image/')) {
                    reader.readAsDataURL(file);
                } else {
                    reader.readAsArrayBuffer(file);
                }
            });
        }

        function addTextAsDocument() {
            const text = document.getElementById('ai-text-input').value.trim();
            if (!text) return;
            const doc = {
                id: Date.now() + Math.random(),
                name: `Pasted Text - ${new Date().toLocaleTimeString()}`,
                type: 'text/plain',
                content: text,
                status: 'done'
            };
            documentsForAi.push(doc);
            renderDocumentList();
            document.getElementById('ai-text-input').value = '';
        }

        function removeDocument(index) {
            documentsForAi.splice(index, 1);
            renderDocumentList();
        }
        async function processAllDocuments() {
            if (documentsForAi.length === 0) {
                showToast("Please add at least one document.", "error");
                return;
            }

            if (!isOnline) {
                showToast("You are offline. AI generation requires internet.", "error");
                return;
            }

            // --- Show Loading State ---
            const processBtn = document.getElementById('process-btn');
            const btnText = document.getElementById('process-text');
            const processIcon = document.getElementById('process-icon');
            const loaderIcon = document.getElementById('loader-icon');
            processBtn.disabled = true;
            btnText.textContent = 'Processing...';
            processIcon.classList.add('hidden');
            loaderIcon.classList.remove('hidden');
            document.getElementById('flashcard-summary').classList.add('hidden');

            try {
                // Add a 30-second timeout for the API call
                const timeoutPromise = new Promise((_, reject) => setTimeout(() => reject(new Error("Request timed out")), 30000));
                const apiPromise = window.electronAPI.generateDeck({ documents: documentsForAi });
                const generatedCards = await Promise.race([timeoutPromise, apiPromise]);

                if (!generatedCards || generatedCards.length === 0) {
                    throw new Error("AI did not return any cards.");
                }

                renderAiGeneratedCards(generatedCards);
                document.getElementById('flashcard-summary').classList.remove('hidden');
            } catch (error) {
                console.error("Deck generation failed:", error);
                showToast("Sorry, the AI failed to generate cards. Please try again or check your connection.", "error");
            } finally {
                // --- Reset UI State ---
                processBtn.disabled = false;
                btnText.textContent = 'Process All';
                processIcon.classList.remove('hidden');
                loaderIcon.classList.add('hidden');
            }
        }

        function renderAiGeneratedCards(cards) {
            const listContainer = document.getElementById('flashcard-list');
            listContainer.dataset.cards = JSON.stringify(cards); // Store the data

            if (cards.length === 0) {
                listContainer.innerHTML = `
                    <div id="empty-flashcard-list" class="list-empty-state">
                        <div class="list-empty-state-icon"><svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor"><path stroke-linecap="round" stroke-linejoin="round" d="M9.813 15.904 9 18.75l-.813-2.846a4.5 4.5 0 0 0-3.09-3.09L2.25 12l2.846-.813a4.5 4.5 0 0 0 3.09-3.09L9 5.25l.813 2.846a4.5 4.5 0 0 0 3.09 3.09L15.75 12l-2.846.813a4.5 4.5 0 0 0-3.09 3.09ZM18.259 8.715 18 9.75l-.259-1.035a3.375 3.375 0 0 0-2.455-2.456L14.25 6l1.036-.259a3.375 3.375 0 0 0 2.455-2.456L18 2.25l.259 1.035a3.375 3.375 0 0 0 2.456 2.456L21.75 6l-1.035.259a3.375 3.375 0 0 0-2.456 2.456Z" /></svg></div>
                        <p>Generated cards will appear here after processing.</p>
                    </div>`;
            } else {
                // If there are cards, build the list HTML.
                listContainer.innerHTML = cards.map((card, index) => `
                    <div class="generated-card" data-index="${index}">
                        <div class="question">${card.question}</div>
                        <div class="answer">${card.answer}</div>
                        <div class="generated-card-actions">
                            <button class="generated-card-action-btn delete" title="Delete Card" onclick="deleteGeneratedCard(${index})">&times;</button>
                        </div>
                    </div>
                `).join('');
            }
            document.getElementById('flashcard-count').textContent = `Generated Flashcards (${cards.length})`;
        }

        function deleteGeneratedCard(index) {
            const listContainer = document.getElementById('flashcard-list');
            const cards = JSON.parse(listContainer.dataset.cards);
            cards.splice(index, 1);
            renderAiGeneratedCards(cards);
        }

        async function saveAiGeneratedDeck() {
            const listContainer = document.getElementById('flashcard-list');
            const cards = JSON.parse(listContainer.dataset.cards);
            const deckName = documentsForAi.length > 0 ? documentsForAi[0].name.split('.')[0] : "New AI Deck";

            if (cards.length === 0) {
                showToast("There are no cards to save.", "error");
                return;
            }

            const finalCards = cards.map(c => ({
                id: Date.now() + Math.random(),
                question: c.question,
                answer: c.answer,
                isNew: true
            }));

            await createNewDeck(deckName, 'Other', finalCards);
            showToast(`Deck "${deckName}" created successfully!`, 'success');
            backToDashboard();
        }

        function setupDragDropView(chunk) {
            const list = document.getElementById('dragDropList');
            const shuffledChunk = shuffleArray([...chunk]);
            list.innerHTML = shuffledChunk.map(card => 
                `<div class="deck-card-item drag-item" data-id="${card.id}">${card.answer}</div>`
            ).join('');

            if (sortableInstance) {
                sortableInstance.destroy();
            }
            sortableInstance = new Sortable(list, {
                animation: 150,
                ghostClass: 'drag-ghost',
                chosenClass: 'drag-chosen',
            });
        }

        function checkDragDropOrder() {
            const currentChunk = studyState.sequenceChunks[studyState.currentChunkIndex];
            const listItems = document.querySelectorAll('#dragDropList .deck-card-item');
            let isCorrect = true;

            listItems.forEach((item, index) => {
                const cardId = item.dataset.id;
                if (cardId !== currentChunk[index].id) {
                    isCorrect = false;
                    item.style.border = '2px solid var(--danger-color)';
                } else {
                    item.style.border = '2px solid var(--success-color)';
                }
            });

            if (isCorrect) {
                showToast("Perfect Order!", "success");
                setTimeout(moveToNextSequencePhase, 1500);
            } else {
                showToast("Not quite right. Try again.", "error");
            }
        }

        function checkSequenceAnswer() {
            const userInput = document.getElementById('writeAnswerInput');
            const currentChunk = studyState.sequenceChunks[studyState.currentChunkIndex];
            const card = (studyState.sequencePhase === 'Weakest Link') 
                ? studyState.roundCards[studyState.currentCardIndex]
                : currentChunk[studyState.currentCardIndex];

            if (!card || userInput.value.trim() === '') return;

            const userAnswer = userInput.value.trim();
            const correctAnswer = card.answer.trim();
            
            const isCorrect = (userAnswer.toLowerCase() === correctAnswer.toLowerCase());

            logInteraction({ cardID: card.id, wasCorrect: isCorrect, userAnswer: userAnswer, questionType: 'Sequence' });
            
            userInput.classList.toggle('correct', isCorrect);
            userInput.classList.toggle('incorrect', !isCorrect);
            userInput.disabled = true;
            showAnswer();
            const delay = isCorrect ? 800 : 2000;
            setTimeout(() => {
                moveCard(card, isCorrect);
            }, 800); 
        }

        function dontKnowSequenceAnswer() {
            const currentChunk = studyState.sequenceChunks[studyState.currentChunkIndex];
            const card = (studyState.sequencePhase === 'Weakest Link') 
                ? studyState.roundCards[studyState.currentCardIndex]
                : currentChunk[studyState.currentCardIndex];

            if (!card) return;

            logInteraction({ cardID: card.id, wasCorrect: false, userAnswer: "[Don't Know]", questionType: 'Sequence' });
            showAnswer();
            document.querySelector('#cardView .flashcard').classList.add('is-flipped');
            document.getElementById('cardAnswerContent').classList.remove('hidden');
            document.getElementById('writeAnswerInput').disabled = true;

            showToast("The correct answer is shown above.", "error");

            setTimeout(() => {
                moveCard(card, false);
            }, 2000);
        }


        async function showInsightsView() {
            // This is our main controller function for the view.
            const setupInsights = async () => {
                const deckSelect = document.getElementById('insightsDeckSelect');
                deckSelect.innerHTML = '<option value="">-- Select a Deck --</option>';
                Object.values(decks).forEach(deck => {
                    deckSelect.innerHTML += `<option value="${deck.id}">${deck.name}</option>`;
                });

                const allKnowledgeStates = await getAllDataFromDB('userKnowledgeState');
                const knowledgeMap = new Map(allKnowledgeStates.map(item => [item.cardID, item]));
                
                // Hide content until a deck is selected.
                document.getElementById('insightsContent').classList.add('hidden');
                document.getElementById('insightsPlaceholder').classList.remove('hidden');
                
                // We define this as a separate function to keep the code clean.
                const handleDeckSelection = (deckId) => {
                    if (!deckId) {
                        document.getElementById('insightsContent').classList.add('hidden');
                        document.getElementById('insightsPlaceholder').classList.remove('hidden');
                        return;
                    }
                    renderMasteryBreakdownChart(deckId, knowledgeMap);
                    // This function will now add its own event listeners.
                    updateCardDetailListForInsights(deckId, knowledgeMap);
                    renderForgettingCurveChart(null, deckId); 
                    document.getElementById('insightsContent').classList.remove('hidden');
                    document.getElementById('insightsPlaceholder').classList.add('hidden');
                };

                // Remove previous listeners to prevent memory leaks if this view is reloaded.
                const newDeckSelect = deckSelect.cloneNode(true);
                deckSelect.parentNode.replaceChild(newDeckSelect, deckSelect);

                // Add the event listener WITHOUT '{ once: true }'.
                newDeckSelect.addEventListener('change', () => {
                    handleDeckSelection(newDeckSelect.value);
                });
            };

            showView('insightsView', false, setupInsights);
        }

        function updateCardDetailListForInsights(deckId, knowledgeMap) {
            const list = document.getElementById('insightsCardList');
            const deck = decks[deckId];
            list.innerHTML = ''; // Clear the list first.

            deck.cards.forEach(card => {
                const state = knowledgeMap.get(card.id);
                const masteryPercent = Math.round((state?.masteryScore || 0.5) * 100);
                const stability = state?.stability?.toFixed(1) || 'N/A';

                const cardItem = document.createElement('div');
                cardItem.className = 'deck-card-item';
                
                cardItem.innerHTML = `
                    <div style="flex-grow: 1;">${card.question}</div>
                    <div style="color:var(--secondary-text); font-weight:500;">Mastery: ${masteryPercent}% | Stability: ${stability}d</div>
                `;

                // If the card has learning data, add the listener.
                if (state) {
                    cardItem.style.cursor = 'pointer';
                    cardItem.addEventListener('click', () => {
                        // All variables (state, deckId) are correctly in scope here.
                        renderForgettingCurveChart(state, deckId);
                    });
                }
                list.appendChild(cardItem);
            });
        }

        function renderForgettingCurveChart(cardState, deckId) {
            const canvasId = 'forgettingCurveChart';
            const cardDetailP = document.getElementById('cardDetailForCurve');
            if (chartInstances[canvasId]) chartInstances[canvasId].destroy();
            const ctx = document.getElementById(canvasId).getContext('2d');

            if (!cardState || !cardState.stability || !deckId) {
                cardDetailP.textContent = 'Select a card from the list to see its predicted curve.';
                chartInstances[canvasId] = new Chart(ctx, { data: { labels: [], datasets: [] }, options: { plugins: { legend: { display: false } } } }); 
                return;
            }
            
            const card = decks[deckId]?.cards.find(c => c.id === cardState.cardID);
            if (!card) {
                cardDetailP.textContent = 'Error: Could not find card details.';
                return;
            }
            cardDetailP.textContent = `Predicted curve for: "${card.question}"`;

            const stability = cardState.stability;
            const labels = [];
            const data = [];
            for (let t = 0; t <= stability * 3; t += Math.max(1, Math.round(stability / 10))) {
                labels.push(t);
                const pRecall = Math.pow(2, -t / stability);
                data.push(pRecall * 100);
            }

            chartInstances[canvasId] = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Probability of Recall (%)',
                        data: data,
                        borderColor: 'var(--primary-color)',
                        backgroundColor: 'rgba(102, 126, 234, 0.1)',
                        fill: true,
                        tension: 0.4
                    }]
                },
                options: {
                    scales: {
                        y: { min: 0, max: 100, title: { display: true, text: 'Recall Probability (%)' } },
                        x: { title: { display: true, text: 'Days Since Last Review' } }
                    },
                    plugins: { legend: { display: false } }
                }
            });
        }

        function renderMasteryBreakdownChart(deckId, knowledgeMap) {
            const canvasId = 'masteryBreakdownChart';
            if (chartInstances[canvasId]) chartInstances[canvasId].destroy();
            
            const deck = decks[deckId];
            let counts = { novice: 0, learning: 0, mastered: 0 };
            deck.cards.forEach(card => {
                const mastery = knowledgeMap.get(card.id)?.masteryScore || 0.5;
                if (mastery < 0.6) counts.novice++;
                else if (mastery < 0.95) counts.learning++;
                else counts.mastered++;
            });

            const ctx = document.getElementById(canvasId).getContext('2d');
            chartInstances[canvasId] = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: ['Novice (0-60%)', 'Learning (60-95%)', 'Mastered (95%+)'],
                    datasets: [{
                        data: [counts.novice, counts.learning, counts.mastered],
                        backgroundColor: ['#fc8181', '#f6ad55', '#68d391'],
                        borderColor: 'var(--card-bg)',
                        borderWidth: 4
                    }]
                },
                options: { responsive: true, cutout: '70%', plugins: { legend: { display: false } } }
            });

            // Update custom legend
            const legend = document.getElementById('masteryLegend');
            legend.innerHTML = `
                <div style="display:flex; align-items:center; margin-bottom: 5px;"><div style="width:12px; height:12px; background-color:#fc8181; border-radius:50%; margin-right:8px;"></div>Novice: ${counts.novice} cards</div>
                <div style="display:flex; align-items:center; margin-bottom: 5px;"><div style="width:12px; height:12px; background-color:#f6ad55; border-radius:50%; margin-right:8px;"></div>Learning: ${counts.learning} cards</div>
                <div style="display:flex; align-items:center;"><div style="width:12px; height:12px; background-color:#68d391; border-radius:50%; margin-right:8px;"></div>Mastered: ${counts.mastered} cards</div>
            `;
        }

    </script>
</body>
</html>